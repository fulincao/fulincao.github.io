

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://fulincao.github.io/</id>
  <title>fulincao</title>
  <subtitle>fulincao's blog</subtitle>
  <updated>2022-06-29T18:15:09+08:00</updated>
  <author>
    <name>fulincao</name>
    <uri>https://fulincao.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://fulincao.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://fulincao.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator>
  <rights> © 2022 fulincao </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>关于WAVE那些事情</title>
    <link href="https://fulincao.github.io/posts/wave/" rel="alternate" type="text/html" title="关于WAVE那些事情" />
    <published>2022-06-24T00:00:00+08:00</published>
  
    <updated>2022-06-24T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/wave/</id>
    <content src="https://fulincao.github.io/posts/wave/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="音频" />
    
  

  
    <summary>
      





      最近了解下wav文件, 记录下wave文件的格式和一些简单的音频处理

格式

  Wav Format
Wave文件格式


wave一般由两部分组成，一部分是头部，一部分是数据



wave文件头部一般如下所示:


  
    
      位置
      一般内容
      解释
    
  
  
    
      4 bytes
      “RIFF”
      文件类型格式
    
    
      4 bytes
      filesize
      其值为filesize字段后的大小，真正的文件大小为filesize + 8 bytes
    
    
      4 bytes
      WAVE
      文件格式
    
    
      4 bytes
      “fmt “
      chunk id,fmt即...
    </summary>
  

  </entry>

  
  <entry>
    <title>动态加载class</title>
    <link href="https://fulincao.github.io/posts/poco/" rel="alternate" type="text/html" title="动态加载class" />
    <published>2022-06-10T00:00:00+08:00</published>
  
    <updated>2022-06-13T19:33:31+08:00</updated>
  
    <id>https://fulincao.github.io/posts/poco/</id>
    <content src="https://fulincao.github.io/posts/poco/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="C++编程" />
    
  

  
    <summary>
      





      了解一下apollo mainboard的启动流程,觉得挺灵活的。在此记录一下,并自己简单实现了一下demo。

mainboard 启动流程


  启动命令mainboad -d xxx.dag
  读取dag文件，尤其是module_library字段和class_name
  通过poco动态加载module_library，并在module_library中加载class_name
  实例化对象Component
  调用其Init,Proc函数
mainboard根据dag文件动态加载不同的class，执行不同的操作。具有极大的灵活方便且统一调度。同时所有component都基于一个基类ComponentBase，约束了其行为。



  示例dag文件
    module_config {
  module_library : "XXXX.so"
  compone...
    </summary>
  

  </entry>

  
  <entry>
    <title>匈牙利算法</title>
    <link href="https://fulincao.github.io/posts/hungarian/" rel="alternate" type="text/html" title="匈牙利算法" />
    <published>2022-06-09T00:00:00+08:00</published>
  
    <updated>2022-06-09T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/hungarian/</id>
    <content src="https://fulincao.github.io/posts/hungarian/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="算法" />
    
    <category term="关联算法" />
    
  

  
    <summary>
      





      匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。本质是为了解决二分图匹配问题。大致理解如下:
有n个男的，m个女的。男的只能跟女的配对，且只能一对一配对。同时，如果男女配对需要消耗彩礼cost，不同男女之间的彩礼是不一样的。问如何尽可能的配对，同时配对所消耗的彩礼最小。匈牙利本质就是解决这种问题。具体可以看匈牙利算法详解,此算法常用于目标关联，目标融合，目标匹配等场景。本文主要记录如何实现。

cost相同，尽可能匹配多

#include &amp;lt;bits/stdc++.h&amp;gt;
#define INF 0x3f3f3f3f;
using namespace std;
int L[505][505];
int boy[505];
int used[505];
int k,m,n;  //可能的组合数k，女生数m，男生数n 

// 二分图匹配 
bool fi...
    </summary>
  

  </entry>

  
  <entry>
    <title>类型转换</title>
    <link href="https://fulincao.github.io/posts/class-cast/" rel="alternate" type="text/html" title="类型转换" />
    <published>2022-02-25T00:00:00+08:00</published>
  
    <updated>2022-06-07T19:40:47+08:00</updated>
  
    <id>https://fulincao.github.io/posts/class-cast/</id>
    <content src="https://fulincao.github.io/posts/class-cast/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="C++编程" />
    
  

  
    <summary>
      





      C++ 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：


  
    
      关键字
      说明
    
  
  
    
      static_cast
      用于良性转换，一般不会导致意外发生，风险很低。
    
    
      const_cast
      用于 const 与非 const、volatile 与非 volatile 之间的转换。
    
    
      reinterpret_cast
      高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。
    
    
      dynamic_cast
      借助 RTTI，用于类型安全的向下转型（Downcasting）。
    
  



  具...
    </summary>
  

  </entry>

  
  <entry>
    <title>智能指针</title>
    <link href="https://fulincao.github.io/posts/smart-pointer/" rel="alternate" type="text/html" title="智能指针" />
    <published>2022-02-24T00:00:00+08:00</published>
  
    <updated>2022-02-24T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/smart-pointer/</id>
    <content src="https://fulincao.github.io/posts/smart-pointer/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="C++编程" />
    
  

  
    <summary>
      





      RAII与引用计数

  现代c++教程


在传统 C++ 中，需要手动释放资源，有可能就忘记了去释放资源而导致泄露。所以通常的做法是对于一个对象而言，在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。

凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 new 和 delete 去 『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针就包括 std::shared_ptr、std::unique_ptr、std::weak_ptr，使用它们需要包含头文件 。

std::shared_ptr
std::shared_ptr是一种智能指针，它能够记录多少个shared_ptr共同指向一个对...
    </summary>
  

  </entry>

</feed>


