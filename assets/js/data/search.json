[
  
  {
    "title": "相机标定",
    "url": "/posts/camera_calibrate/",
    "categories": "计算机视觉",
    "tags": "标定",
    "date": "2022-11-27 00:00:00 +0800",
    





    "snippet": "记录下相机标定过程  opencv标定文档opencv相机标定demo      首先准备一张棋盘表格    打印在标定板上，得到横纵向角点数目，同时测量格子大小        固定相机位置，改变棋盘格的位置方向拍的清晰覆盖整个棋盘格的照片，至少16张分布在图像的各个位置         标定  #!/usr/bin/env python# Python 2/3 compatibilityfrom __future__ import print_functionimport numpy as npimport cv2 as cvimport argparse# built-in modulesimport osimport sysimport getoptfrom glob import glob# 罗格利斯旋转向量转旋转矩阵def Rodriguez(rvecs):    # 旋转向量模长    θ = (rvecs[0] * rvecs[0] + rvecs[1] * rvecs[1] + rvecs[2] * rvecs[2])**(1/2)    # 旋转向量的单位向量    r = rvecs / θ    # 旋转向量单位向量的反对称矩阵    anti_r = np.array([        [0, -r[2], r[1]],        [r[2], 0, -r[0]],        [-r[1], r[0], 0]    ])    # 旋转向量转旋转矩阵(Rodriguez公式)     # np.outer(r, r) = r @ r.T 向量外积    M = np.eye(3) * np.cos(θ) + (1 - np.cos(θ)) * np.outer(r, r) + np.sin(θ) * anti_r    return Mdef main():    usge = &#39;&#39;&#39;    camera calibration for distorted images with chess board samples    reads distorted images, calculates the calibration and write undistorted images    usage:        calibrate.py &amp;lt;image mask&amp;gt; [--output_dir &amp;lt;output path&amp;gt;] [--square_size &amp;lt;&amp;gt;] [--threads &amp;lt;&amp;gt;]    example values:        --output_dir:  ./output/        --square_size: 1.0        --pattern_size: (5,9)        &amp;lt;image mask&amp;gt; defaults to ./data/    &#39;&#39;&#39;    arg_parser = argparse.ArgumentParser(        description=usge, formatter_class=argparse.RawTextHelpFormatter)    arg_parser.add_argument(&quot;-o&quot;, &quot;--output_dir&quot;, default=&quot;./output&quot;)    arg_parser.add_argument(&quot;-s&quot;, &quot;--square_size&quot;, default=0.12, type=float)    arg_parser.add_argument(&quot;-t&quot;, &quot;--threads&quot;, default=1, type=int)    arg_parser.add_argument(&quot;-p&quot;, &quot;--pattern_size&quot;, default=&quot;(5,9)&quot;, help=&quot;chessboard corners pattern size&quot;)    arg_parser.add_argument(&quot;img_dir&quot;)    args = arg_parser.parse_args()    img_names = [ os.path.join(args.img_dir, n) for n in os.listdir(args.img_dir)]    print(&quot;find image:&quot;, len(img_names))    debug_dir = args.output_dir    if debug_dir and not os.path.isdir(debug_dir):        os.mkdir(debug_dir)    square_size = float(args.square_size)    pattern_size = (5, 9)  # 定义角点尺寸    pattern_size = eval(args.pattern_size)    pattern_points = np.zeros((np.prod(pattern_size), 3), np.float32)    pattern_points[:, :2] = np.indices(pattern_size).T.reshape(-1, 2)    pattern_points *= square_size  # 设置每个角点的坐标，z轴为0    print(square_size, pattern_size)    print(pattern_points.shape)    # print(pattern_points)    obj_points = []    img_points = []    # TODO: use imquery call to retrieve results    h, w = cv.imread(img_names[0], cv.IMREAD_GRAYSCALE).shape[:2]    def processImage(fn):        print(&#39;processing %s... &#39; % fn)        img = cv.imread(fn, 0)        if img is None:            print(&quot;Failed to load&quot;, fn)            return None        assert w == img.shape[1] and h == img.shape[0], (&quot;size: %d x %d ... &quot; % (            img.shape[1], img.shape[0]))        # found, corners = cv.findChessboardCorners(img, pattern_size, flags=cv.CALIB_CB_ADAPTIVE_THRESH        #                                           + cv.CALIB_CB_EXHAUSTIVE)        # found, corners = cv.findCirclesGrid(img, pattern_size)        found, corners = cv.findChessboardCorners(img, pattern_size, flags=cv.CALIB_CB_ADAPTIVE_THRESH) # 查找所有角点        if found:            term = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 30, 0.001)            corners2 = cv.cornerSubPix(img, corners, (11, 11), (-1, -1), term) # 获取亚像素角点            # print(np.allclose(corners, corners2))             corners = corners2        if debug_dir:            vis = cv.cvtColor(img, cv.COLOR_GRAY2BGR)            cv.drawChessboardCorners(vis, pattern_size, corners, found) # 绘制角点            name = os.path.basename(fn)            outfile = os.path.join(debug_dir, name + &#39;_chess.png&#39;) # 保存角点照片            cv.imwrite(outfile, vis)            # cv.imshow(&quot;img&quot;, vis)            # cv.waitKey(0)        if not found:            print(&#39;chessboard not found&#39;)            return None        print(&#39;           %s... OK&#39; % fn)        return (corners.reshape(-1, 2), pattern_points)    threads_num = int(args.threads)    if threads_num &amp;lt;= 1:        chessboards = [processImage(fn) for fn in img_names]    else:        print(&quot;Run with %d threads...&quot; % threads_num)        from multiprocessing.dummy import Pool as ThreadPool        pool = ThreadPool(threads_num)        chessboards = pool.map(processImage, img_names)    chessboards = [x for x in chessboards if x is not None]    for (corners, pattern_points) in chessboards:        img_points.append(corners)        obj_points.append(pattern_points)    # calculate camera distortion    rms, camera_matrix, dist_coefs, rvecs, tvecs = cv.calibrateCamera(        obj_points, img_points, (w, h), None, None) # 标定相机，(均方根误差，内参矩阵，畸变参数（k1,k2,p1,p2,k3）, 每张图片的旋转向量，位移矩阵)    np.set_printoptions(precision=3, suppress=True) # 设置numpy打印精度    camera_matrix = np.around(camera_matrix, 3)    dist_coefs = np.around(dist_coefs, 3)    rvecs = np.around(rvecs, 3)    print(&quot;\\nRMS:&quot;, rms)    print(&quot;camera matrix:\\n&quot;, camera_matrix)    print(&quot;distortion coefficients: &quot;, dist_coefs.ravel())    print(&quot;trastion matrix:\\n&quot;, rvecs.ravel(), rvecs.shape)       dst = cv.Rodrigues(rvecs[1])  # 旋转向量转旋转矩阵    print(dst)    # for x in rvecs:    #     dst = Rodriguez(x)    #     print(dst.ravel())    mean_error = 0 # 计算平均误差    for i in range(len(obj_points)):        imgpoints2, _ = cv.projectPoints(            obj_points[i], rvecs[i], tvecs[i], camera_matrix, dist_coefs) # 重投影        # error = cv.norm(img_points[i]*1.0, imgpoints2*1.0, cv.NORM_L2)/len(imgpoints2)        error = np.linalg.norm(imgpoints2 - img_points[i]) / len(imgpoints2)        mean_error += error    print(&quot;total error: {}&quot;.format(mean_error/len(obj_points)))    # undistort the image with the calibration    print(&#39;&#39;)     for fn in img_names if debug_dir else []:        name = os.path.basename(fn)        img_found = os.path.join(debug_dir, name + &#39;_chess.png&#39;)        outfile = os.path.join(debug_dir, name + &#39;_undistorted.png&#39;)        img = cv.imread(img_found)        if img is None:            continue        h, w = img.shape[:2]        # print(h, w)        # newcameramtx, roi = cv.getOptimalNewCameraMatrix(        #     camera_matrix, dist_coefs, (w, h), 1, (w, h))        # 解畸变验证参数是否正确        dst = cv.undistort(img, camera_matrix, dist_coefs, None)        # # crop and save the image        # x, y, w, h = roi        # dst = dst[y:y+h, x:x+w]        # print(&#39;Undistorted image written to: %s&#39; % outfile)        cv.imwrite(outfile, dst)    print(&#39;Done&#39;)if __name__ == &#39;__main__&#39;:    main()    cv.destroyAllWindows()"
  },
  
  {
    "title": "坐标变换",
    "url": "/posts/coordinate_transform/",
    "categories": "坐标系统",
    "tags": "旋转矩阵, 平移",
    "date": "2022-11-02 00:00:00 +0800",
    





    "snippet": "最近又碰到了坐标变换，发现已经忘了许多，在此在记录下。常用的变换有: 平移,缩放,旋转。  CSDN旋转矩阵mathworld旋转矩阵平移平移直接加即可\\(\\begin{bmatrix}x_b  \\\\y_b  \\\\z_b \\end{bmatrix} =\\begin{bmatrix}x_a  \\\\y_a  \\\\z_a \\end{bmatrix} + \\begin{bmatrix}\\Delta x  \\\\\\Delta y  \\\\\\Delta z\\end{bmatrix}\\)其中$\\Delta x,\\Delta y,\\Delta z$为b坐标轴在a坐标轴上的偏移。缩放缩放直接乘就好\\(\\begin{bmatrix}x_b  \\\\y_b  \\\\z_b \\end{bmatrix} =\\begin{bmatrix}s_x &amp;amp; 0 &amp;amp; 0  \\\\0 &amp;amp; s_y &amp;amp; 0  \\\\0 &amp;amp; 0 &amp;amp; s_z\\end{bmatrix} \\begin{bmatrix}x_a  \\\\y_a  \\\\z_a \\end{bmatrix}\\)其中$s_x,s_y,s_x$为b坐标轴在a坐标轴上的缩放倍数。旋转  欧拉角旋转矩阵推导三维旋转可以分解为在三个不同的平面单独旋转:      在xy平面绕z轴逆时针旋转(heading或yaw)    此时:  \\(\\begin{aligned}  x_b = OC &amp;amp;= OB + BC \\\\  &amp;amp;= OB + AD \\\\   &amp;amp;= x_a * \\cos\\theta + y_a * \\sin\\theta  \\end{aligned}\\)    \\(\\begin{aligned}  y_b = CP = OG &amp;amp;= OF - GF \\\\  &amp;amp;= OF - HE \\\\   &amp;amp;= y_a * \\cos\\theta - x_a * \\sin\\theta  \\end{aligned}\\)  因此:  \\(\\begin{bmatrix}  x_b  \\\\  y_b   \\end{bmatrix} =  \\begin{bmatrix}  \\cos\\theta &amp;amp;  \\sin\\theta \\\\  -\\sin\\theta &amp;amp; \\cos\\theta  \\\\  \\end{bmatrix} *   \\begin{bmatrix}  x_a  \\\\  y_a   \\end{bmatrix}\\)  转成三维令旋转方向为顺时针($\\theta=-\\theta$)有:  \\(tr_{yaw} =   \\begin{bmatrix}  \\cos\\theta &amp;amp;  -\\sin\\theta &amp;amp; 0 \\\\  \\sin\\theta &amp;amp; \\cos\\theta &amp;amp; 0 \\\\  0 &amp;amp; 0 &amp;amp; 1   \\end{bmatrix}\\)    在zx平面绕y轴逆时针旋转(elevation或pitch)    与z轴旋转一致，把z轴当成x, x轴当成y轴,因此有:  \\(tr_{pitch} =   \\begin{bmatrix}  \\cos\\theta &amp;amp;  0&amp;amp; \\sin\\theta \\\\  0 &amp;amp; 1 &amp;amp; 0 \\\\  -\\sin\\theta &amp;amp; 0 &amp;amp; \\cos\\theta  \\end{bmatrix}\\)  在yz平面绕x轴逆时针旋转(bank或roll)    与z轴旋转一致，把y轴当成x, z轴当成y轴,因此有:  \\(tr_{roll} =   \\begin{bmatrix}  1 &amp;amp; 0 &amp;amp; 0 \\\\  0 &amp;amp;\\cos\\theta &amp;amp;  -\\sin\\theta  \\\\  0 &amp;amp; \\sin\\theta &amp;amp; \\cos\\theta \\\\  \\end{bmatrix}\\)因此按ZYX顺序旋转得到的旋转矩阵为:\\(\\begin{aligned}    Z_{1}Y_{2}X_{3} = R &amp;amp;= tr_{yaw} * tr_{pitch} * tr_{roll} \\\\    &amp;amp;= \\begin{bmatrix}c_{1}c_{2}&amp;amp;c_{1}s_{2}s_{3}-c_{3}s_{1}&amp;amp;s_{1}s_{3}+c_{1}c_{3}s_{2}\\\\c_{2}s_{1}&amp;amp;c_{1}c_{3}+s_{1}s_{2}s_{3}&amp;amp;c_{3}s_{1}s_{2}-c_{1}s_{3}\\\\-s_{2}&amp;amp;c_{2}s_{3}&amp;amp;c_{2}c_{3}\\end{bmatrix}\\end{aligned}\\)同时旋转矩阵转欧拉角为:\\(\\begin{aligned}yaw &amp;amp;=\\arctan \\left({\\frac {R_{21}}{R_{11}}}\\right) \\\\pitch &amp;amp;=\\arctan \\left({\\frac {-R_{31}}{\\sqrt {1-R_{31}^{2}}}}\\right) \\\\roll &amp;amp;=\\arctan \\left({\\frac {R_{32}}{R_{33}}}\\right)\\end{aligned}\\)"
  },
  
  {
    "title": "MFCC",
    "url": "/posts/mfcc/",
    "categories": "音频处理",
    "tags": "mfcc, 梅尔频率倒谱系数",
    "date": "2022-08-11 00:00:00 +0800",
    





    "snippet": "最近了解下梅尔倒谱系数在此记录下。梅尔倒频谱（Mel-Frequency Cepstrum, MFC）:一个可用来代表短期音频的频谱，其原理基于用非线性的梅尔刻度（mel scale）表示的对数频谱及其线性余弦转换（linear cosine transform）上。梅尔频率倒谱系数（Mel-Frequency Cepstral Coefficients, MFCC）： 是一组用来创建梅尔倒频谱的关键系数。由音乐信号当中的片段，可以得到一组足以代表此音乐信号之倒频谱（Cepstrum），而梅尔倒频谱系数即是从这个倒频谱中推得的倒频谱（也就是频谱的频谱）。与一般的倒频谱不同 ，梅尔倒频谱最大的特色在于，于梅尔倒频谱上的频带是均匀分布于梅尔刻度上的，也就是说，这样的频带相较于一般所看到、线性的倒频谱表示方法，和人类非线性的听觉系统更为接近。应用: 是一种广泛用于自动语音和说话人识别的特征,在音频压缩的技术中，便常常使用梅尔倒频谱来处理。例如：可以自动辨认一个人透过电话说的数字。梅尔倒频谱系数通常也可以作为声纹识别（Speaker Recognition），也就是用来识别某段语音频号的发话者是谁。  梅尔倒频谱 Mel-frequency-cepstrum步骤  梅尔倒谱实现步骤  梅尔倒谱系数通常是用一下方法得到的:      对音频信号进行预加重，一般都是说为了补偿高频分量的损失    分帧加窗, 消除各个帧两端可能会造成的信号不连续性    做FFT,计算功率谱和对应的能量    计算梅尔滤波器组    将滤波器组对功率谱进行滤波    将滤波结果取log    做dct变换    保留dct2-13的系数    做lifting    附加功率谱的能量  预加重对语音信息进行预加重通常使用如下方式:\\(\\begin{aligned}y(i) = x(i) - \\alpha * x(i-1)\\end{aligned}\\)  $\\alpha$ 通常为0.97def pre_add_weight(signal, alpha=0.97):    &quot;&quot;&quot;    预加重    https://zhuanlan.zhihu.com/p/34798429    &quot;&quot;&quot;    signal = np.insert(signal, 0, 0)    return signal[1:] - alpha * signal[:-1]分帧加窗  分帧: 对语音信号进行25ms(帧长)分一帧，同时每次滚动10ms（步长）,即相邻两帧重叠一部分，对末尾不足正常帧长的补0。  加窗:通常是为了消除各个帧两端可能会造成的信号不连续性。常用的窗函数是汉明窗(hamming)  \\(\\begin{aligned}  w(n) = \\alpha - (1 - \\alpha) * \\cos( \\dfrac{2 * \\pi * n}{N-1}), \\qquad(0 \\leq n \\leq N - 1)  \\end{aligned}\\)          其中$\\alpha=0.5386$称做hamming窗,$\\alpha=0.5$叫作hann窗,N为窗长度，通常为了简化计算令$\\alpha=0.54$      def hamming(N):    &quot;&quot;&quot;    生成汉明窗(hamming windows)    https://zh.wikipedia.org/wiki/%E7%AA%97%E5%87%BD%E6%95%B0#Hamming%E7%AA%97    http://t.zoukankan.com/dylancao-p-14212421.html    &quot;&quot;&quot;    return 0.54 - 0.46 * np.cos(np.arange(0, N) * np.pi * 2 / (N - 1))def split_frame(signal, win_len, win_step, win_func=hamming):    &quot;&quot;&quot;    分帧加窗    &quot;&quot;&quot;    hamming_win = win_func(win_len)    sig_len = len(signal)    pad_len = 0    num_frames = 0    if sig_len &amp;lt; win_len:        pad_len = win_len - sig_len        num_frames = 1    else:        pad_n = math.ceil((sig_len - win_len) / win_step)        pad_len = pad_n * win_step + win_len - sig_len        num_frames = pad_n + 1    pad_signal = np.zeros(sig_len + pad_len)    pad_signal[:sig_len] = signal       frames = []    for i in range(num_frames):        r = pad_signal[i*win_step:i*win_step+win_len] * hamming_win             frames.append(pad_signal[i*win_step:i*win_step+win_len] * hamming_win)    return np.array(frames)计算功率谱计算功率谱，需要先做FFT，然后将结果按照如下公式计算:\\[\\begin{aligned}P(k) = \\dfrac{1}{N}|S(k)|^2\\end{aligned}\\]def power_spectral(frames, n_fft=512):    &quot;&quot;&quot;    计算功率图谱    &quot;&quot;&quot;    n_fft = n_fft or frames.shape[1]    pow_spec = np.fft.rfft(frames, n_fft)  # n_fft / 2 + １    pow_spec = np.abs(pow_spec)    return 1.0 / n_fft * np.square(pow_spec)生成梅尔滤波器组将线性频率映射到基于听觉感知的Mel非线性频率中，然后转换到倒谱上。普通频率和Mel频率的转换如下:\\(\\begin{aligned}Mel(f) &amp;amp;= 2595 * \\log_{10}(1 + f/700) \\\\Mel^{-1}(m) &amp;amp;=  700 * (10^{m/2595} - 1)\\end{aligned}\\)通常步骤如下:  将最低频率和最高频率转到Mel频率(low_mel, high_mel)  根据Mel滤波器组的个数(n_filt)生成n_filt + 2 个等距分布low_mel和high_mel之间的点(mel_points)  将生成的mel_points根据FFT size和采样率(sample_rate)转到频率下得到fft_bins，转换公式如下: \\(\\begin{aligned} bin = floor((n\\_fft + 1) * mel2hz(mel\\_points) / sample\\_rate) \\end{aligned}\\)  根据如下公式生成梅尔滤波器组\\(\\begin{aligned} H_j(i) &amp;amp;= 0 \\qquad(i &amp;lt; bin(j)) \\\\        &amp;amp;= \\dfrac{i - bin(j)}{bin(j+1) - bin(j)} \\qquad(bin(j) \\leq i &amp;lt; bin(j+1)) \\\\        &amp;amp;= \\dfrac{bin(j+2) - i}{bin(j+2) - bin(j+1)} \\qquad(bin(j+1) \\leq i &amp;lt; bin(j+2)) \\\\         &amp;amp;= 0 \\qquad( i \\geq bin(j+2)) \\end{aligned}\\)          其中j下标代表滤波器个数，i下标代表滤波器长度(n_fft // 2 + 1)      def get_mel_filter_banks(low_freq, high_freq, sample_rate, n_filt=26, n_fft=512):    low_mel = hz2mel(low_freq)    high_mel = hz2mel(high_freq)    mel_points = np.linspace(low_mel, high_mel, n_filt + 2)    # f(i) = floor((nfft+1)*h(i)/samplerate)    bin = np.floor((n_fft+1)*mel2hz(mel_points) / sample_rate)    fbank = np.zeros([n_filt, n_fft//2+1])    for j in range(0, n_filt):        for i in range(int(bin[j]), int(bin[j+1])):            fbank[j, i] = (i - bin[j]) / (bin[j+1]-bin[j])        for i in range(int(bin[j+1]), int(bin[j+2])):            fbank[j, i] = (bin[j+2]-i) / (bin[j+2]-bin[j+1])    return fbank离散余弦变换(DCT)一般都是使用DCT-II，这里参考matlab的实现公式。下面有个简单的实现帮助理解，时间复杂度O(nn)不够快，因此实际使用的是Scipy.fftpack.dct 复杂度O(nlong)，这个之后再去学习下。表示如下: \\(\\begin{aligned}y(k) = \\sqrt{\\dfrac{2}{N}}\\sum_{n=0}^{N-1}x_n* \\dfrac{1}{\\sqrt{1 + \\theta_{k0}}}\\cos(\\dfrac{\\pi}{N} * (n + \\dfrac{1}{2}) * k) \\qquad(k=0,...N-1)\\end{aligned}\\)def matlab_dct2(x):    &quot;&quot;&quot;    https://ww2.mathworks.cn/help/signal/ref/dct.html#responsive_offcanvas    https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2    系数为 sqrt(2/n) 同时增加克罗内克函数(Kronecker) delta(k,0)    see also scipy.fftpack.dct(x, type=2, norm=&#39;ortho&#39;)    &quot;&quot;&quot;    N = len(x)    y = np.zeros(N)    for k in range(N):        t0 = x * np.cos(np.pi * (np.arange(N) + 1/2) * k / N)        # for Kronecker        kronecker_delta = k == 0        t0 = t0 * 1 / np.sqrt(kronecker_delta + 1)        y[k] = np.sqrt(2 / N) * np.sum(t0)    return ylifter对倒谱进行正弦提升def lifter(cepstra, L=22):    nframes, ncoeff = np.shape(cepstra)    n = np.arange(ncoeff)    lift = 1 + (L/2.) * np.sin(np.pi*n/L)    return lift*cepstra实现通过以上步骤可以得到实现def mfcc(signal, sample_rate, win_durtation=0.025, win_step=0.010, num_cep=13, n_filter=26, win_func=hamming, pre_weight=0.97):        win_len = round(sample_rate * win_durtation)    win_step = round(sample_rate * win_step)    signal = pre_add_weight(signal, pre_weight)    frames = split_frame(signal, win_len, win_step, win_func=hamming)        n_fft = win_len    pow_spec = power_spectral(frames, n_fft=win_len)    energy = np.sum(pow_spec, 1)    energy = np.where(energy == 0,np.finfo(float).eps,energy) # if energy is zero, we get problems with log    mel_filter_banks = get_mel_filter_banks(0, sample_rate // 2, sample_rate, n_filt=n_filter, n_fft=n_fft)        feat = np.dot(pow_spec, mel_filter_banks.T)    feat = np.where(feat == 0,np.finfo(float).eps,feat) # if feat is zero, we get problems with log    feat = np.log(feat)    feat = scipy.fftpack.dct(feat, type=2, norm=&#39;ortho&#39;)    feat = feat[:, :num_cep]    feat = lifter(feat)    feat[:,0] = np.log(energy) # replace first cepstral coefficient with log of frame energy    return featif __name__ == &quot;__main__&quot;:    # test    import python_speech_features    import python_speech_features.sigproc    import scipy.signal    import matplotlib.pyplot as plt    samplerate = 1000    sig = np.linspace(0, 1, samplerate)    sig = np.sin(sig)    frames = split_frame(sig, 20, 10)        feat1 = python_speech_features.mfcc(sig,samplerate=samplerate, nfft=25, winfunc=hamming, nfilt=26)    feat2 = mfcc(sig, samplerate, n_filter=26)    # print(feat1[:5])    # print(feat2[:5])    print(np.allclose(feat1, feat2))"
  },
  
  {
    "title": "低通滤波",
    "url": "/posts/low_pass_filter/",
    "categories": "信号处理",
    "tags": "低通滤波",
    "date": "2022-08-05 00:00:00 +0800",
    





    "snippet": "最近了解了下低通滤波在这里记录下低通滤波器（英语：Low-pass filter）：容许低频信号通过，但减弱（或减少）频率高于截止频率的信号的通过。对于不同滤波器而言，每个频率的信号的减弱程度不同。当使用在音频应用时，它有时被称为高频剪切滤波器，或高音消除滤波器。高通滤波器则相反，而带通滤波器则是高通滤波器同低通滤波器的组合。低通滤波器在信号处理中的作用等同于其它领域如金融领域中移动平均数（moving average）所起的作用；这两个工具都通过剔除短期波动、保留长期发展趋势提供了信号的平滑形式。此处记录两种低通滤波器的实现:一种是巴特沃斯滤波器，一种是移动平均滤波器  低通滤波器巴特沃斯滤波器移动平均值巴特沃斯滤波器巴特沃斯滤波器是一种通频带之频率响应曲线平坦无纹波的信号处理滤波器。它也被称作最大平坦滤波器。这种滤波器最先由英国工程师、物理学家斯替芬·巴特沃斯在1930年发表的论文《滤波器放大器理论研究》中提出的。特性：巴特沃斯滤波器的特点是通频带内的频率响应曲线最大限度平坦，没有纹波，而在阻频带则逐渐下降为零。在对数波特图上，从某一边界角频率开始，幅度随着角频率的增加而线性减少至负无穷。n阶巴特沃斯低通滤波增益$G(w)$为:\\[\\begin{aligned}G_n(w) = \\dfrac{1}{\\sqrt{1 + (w/w_c)^{2n}}}\\end{aligned}\\]其中:  $G$表示增益率也是滤波器的放大率  $n$表示滤波器的级数  $w$为信号的频率  $w_c$为截止频率因此实现如下:def low_pass_filter_by_butter(x, butter_n, cutoff,fs=48000):    fft_x = np.fft.rfft(x)  # 取fft，求得数据的频率的幅值    freqs = np.linspace(0, fs//2, len(fft_x)) # 采样率通常情况下是频率的2倍    xb = []    for i in range(len(fft_x)):        g = 1 / math.sqrt(1 + (freqs[i] / cutoff)**(2*butter_n) ) * fft_x[i] # 计算增益        xb.append(g)    filter_x = np.fft.irfft(xb, n=len(x)) # irfft还原到时域数据    return filter_x移动平均滤波器移动平均（英语：Moving average，缩写：MA）：又称滚动平均值、滑动平均，在统计学中是一种通过创建整个数据集中不同子集的一系列平均数来分析数据点的计算方法。它也是有限脉冲响应滤波器的一种。变化包括: 简单移动平均、指数移动平均、加权移动平均，以及累积移动平均（描述如下）给定一个数列和一个固定子集大小，移动平均数的第一个元素是由数列的初始固定子集的平均值得到的。然后通过“向前移位”修改子集，即排除序列的第一个数，并在子集中包含下一个值。特性: 移动平均通常与时间序列数据一起使用，以消除短期波动，突出长期趋势或周期。短期和长期之间的阈值取决于应用，移动平均的参数将相应地设置。例如，它通常用于对财务数据进行技术分析，如股票价格、收益率或交易量。它也用于经济学中研究国内生产总值、就业或其他宏观经济时间序列。数学上，移动平均是卷积的一种类型，因此它可以被看作是用于信号处理的低通滤波器的一个例子。当与非时间序列数据一起使用时，移动平均滤波器的频率分量更高，但与时间没有任何特定的联系，尽管通常暗含某种排序。简单地看，它可以看作是把数据变得更平滑。移动平均表达形式如下:\\[\\begin{aligned}MA_k(n) &amp;amp;= \\dfrac{1}{k}\\sum_{i=n-k+1}^{n}X(i) \\\\MA_k(n+1) &amp;amp;= MA_k(n) + \\dfrac{1}{k}(X(n+1) - X(n-k+1))\\end{aligned}\\]其中:  $k$表示滤波器的窗口长度  $MA_k$表示移动平均的输出  $n$为当前下标  $X$为输入序列因此实现如下:def running_mean(x, windowSize):    # from http://stackoverflow.com/questions/13728392/moving-average-or-running-mean    cumsum = np.cumsum(np.insert(x, 0, np.zeros(windowSize)))     return (cumsum[windowSize:] - cumsum[:-windowSize]) / windowSize移动平均滤波器跟截止频率的关系可以参看what-is-the-cut-off-frequency-of-a-moving-average-filter此处有完整的证明。因此两者关系如下:\\[\\begin{aligned}F_{co} &amp;amp;= \\dfrac{F_{cutoff} }{fs} \\qquad(1) \\\\k &amp;amp;= \\dfrac{\\sqrt{0.196202 + F_{co}^{2}}}{F_{co}} \\qquad(2)\\end{aligned}\\]其中:  $k$表示滤波器的窗口长度  $fs$表示数据的采样率  $F_{cutoff}$为截止频率因此实现如下:def low_pass_filter_by_moving_average(x, cutoff, fs=48000):    # get window size    # from http://dsp.stackexchange.com/questions/9966/what-is-the-cut-off-frequency-of-a-moving-average-filter    freqRatio = (cutoff/fs)    N = int(math.sqrt(0.196202 + freqRatio**2)/freqRatio)    filtered = running_mean(x, N)    # filtered = np.hstack([filtered, np.zeros(N-1)])    return filtered相比巴特沃斯滤波器，移动平均少了求傅立叶的操作，直接在原数据上操作。测试测试代码如下:def run():    framerate = 1000 # 假定采样率为1000    cutoff = 50 # 截止频率    base_x = np.linspace(0, 1, 1000)    x = np.sin(2*math.pi * 100*base_x) + np.cos(2*math.pi *10*base_x) # 生成频率100的正弦波和10的余弦波的叠加数据    x_10 = np.cos(2*math.pi *10*base_x)     hz = np.linspace(0, framerate, len(x)) # 频率轴    time = np.arange(0, len(x)) * (1 / framerate) # 时间轴    origin_fft_x = np.fft.fft(x) # 原始数据的fft        filter_x = low_pass_filter_by_butter(x, 4, cutoff, fs=1000) # 4阶butter过滤50hz以下的    fft_x = np.fft.fft(filter_x)    plt.subplot(311)  # 绘图    plt.plot(time, x)    plt.title(&quot;origin_signal&quot;)    plt.subplot(312)    plt.plot(time, x_10, label=&quot;origin_filted&quot;)    plt.plot(time, filter_x, label=&quot;butter_filted&quot;)        plt.title(&quot;filted_signal&quot;)    plt.legend()    plt.subplot(313)    plt.plot(hz, origin_fft_x, label=&quot;origin&quot;)    plt.plot(hz, fft_x, label=&quot;butter_filted&quot;)    plt.legend()    plt.title(&quot;fft&quot;)    plt.show()    filter_x = low_pass_filter_by_moving_average(x, cutoff, fs=1000) # moving average 过滤50hz以下的    fft_x = np.fft.fft(filter_x)    plt.subplot(311)    plt.plot(time, x)    plt.title(&quot;origin_signal&quot;)    plt.subplot(312)    plt.plot(time, x_10, label=&quot;origin_filted&quot;)    plt.plot(time, filter_x, label=&quot;moving_filted&quot;)        plt.title(&quot;filted_signal&quot;)    plt.legend()    plt.subplot(313)    plt.plot(hz, origin_fft_x, label=&quot;origin&quot;)    plt.plot(hz, fft_x, label=&quot;moving_filted&quot;)    plt.legend()    plt.title(&quot;fft&quot;)    plt.show()测试结果:巴特沃斯:移动平均:其他  高通滤波通常可以直接用原数据减低通滤波的数据  带通滤波就是取两个截止频率之间的使用scipy:import scipy.signalimport numpy as npcutoff_1, cutoff_2 = 80, 200sr = 1000base_x = np.linspace(0, 1, 1000)data = np.sin(2*math.pi * 100*base_x) + np.cos(2*math.pi *10*base_x) # 生成频率100# 带通滤波b, a = scipy.signal.butter(4, [cutoff_1/sr*2, cutoff_2/sr*2], &#39;bandpass&#39;)fix_x = scipy.signal.filtfilt(b, a, data)# 高通滤波sos = scipy.signal.butter(4, cutoff_1, &#39;hp&#39;, fs=sr, output=&#39;sos&#39;)fix_x = scipy.signal.sosfilt(sos, data)# 低通滤波sos = scipy.signal.butter(4, cutoff_1, &#39;lp&#39;, fs=sr, output=&#39;sos&#39;)fix_x = scipy.signal.sosfilt(sos, data)"
  },
  
  {
    "title": "音频处理",
    "url": "/posts/audio_process/",
    "categories": "音频处理",
    "tags": "fft, 音频处理",
    "date": "2022-08-03 00:00:00 +0800",
    





    "snippet": ""
  },
  
  {
    "title": "Jekyll博客环境搭建",
    "url": "/posts/jekyll_install/",
    "categories": "环境问题",
    "tags": "jekyll",
    "date": "2022-07-22 00:00:00 +0800",
    





    "snippet": "  安装ruby          sudo apt update      sudo apt install build-essential      sudo apt install ruby ruby-dev        安装 jekyll          gem sources –add http://gems.ruby-china.com/ –remove https://rubygems.org/      gem -u      gem sources -l      sudo gem install jekyll      sudo gem install bundler      cd BLOG_DIR &amp;amp;&amp;amp; bundle install      build jekyll                  bundle exec jekyll s # bundle 执行          bundle exec jekyll b -d “deploy” –config _config.yml &amp;amp;&amp;amp; cd deploy &amp;amp;&amp;amp; jekyll s # 发布到某个目录再执行                    "
  },
  
  {
    "title": "布隆过滤器",
    "url": "/posts/bloom_filter/",
    "categories": "算法和数据结构",
    "tags": "hash, 布隆过滤器",
    "date": "2022-07-22 00:00:00 +0800",
    





    "snippet": "  布隆过滤器基本定义: 布隆过滤器(Bloom Filter)是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。基本原理:布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。优点:  插入和查询都是时间都是常数(O(k))  节省很大的空间  散列函数相互之间无依赖，可以并行实现  不存储元素本身，某些对保密要求非常严格的场合有优势  多个相同的布隆过滤器可以直接合并  可以表示全集缺点:  会有很多假正例，即不在过滤器中的会被误判  无法删除元素用途:  网页爬虫对海量URL的去重，避免爬取相同的URL地址  反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱  缓存击穿，将已存在的缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉  过滤海量无效访问，宁可错杀一千也不放过一个实现:#include &amp;lt;string&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;class BlooomFilters{    public:        BlooomFilters() = delete;        // num_of_hash ~= table_length / n * ln2        BlooomFilters(int table_length, int num_of_hash){            mod = table_length;            k = num_of_hash;            bloom_table = new uint8_t[table_length / 8 + 1];            memset(bloom_table, 0, table_length / 8 + 1);        }        ~BlooomFilters(){            delete bloom_table;            bloom_table = nullptr;        }        // seed 优先使用 2^n -1 (java 使用31),通过不同的seed达到多个hash函数的目的        uint32_t bkdr_hash(uint32_t seed, std::string str) {            int len = str.length();            uint32_t hash = 0;            for( int i = 0; i &amp;lt; len; i++) {                hash = hash * seed + str[i];            }            return hash % mod;        }        bool hash(std::string str) {            for( size_t i = 0; i &amp;lt; k; i++ ){                uint32_t seed = (1 &amp;lt;&amp;lt; (i + 3)) - 1;                uint32_t hash_val = bkdr_hash(seed, str);                // 将hash值对应的位置1                bloom_table[hash_val / 8] |= 1 &amp;lt;&amp;lt; hash_val % 8;            }            return true;        }        // 会有假正例         bool has_hashed(std::string str){            uint32_t equal = 1;            for (size_t i = 0; i &amp;lt; k; i++)            {                uint32_t seed = (1 &amp;lt;&amp;lt; (i + 3)) - 1;                uint32_t hash_val = bkdr_hash(seed, str);                equal = equal &amp;amp;&amp;amp; bloom_table[hash_val / 8] &amp;amp; (1 &amp;lt;&amp;lt; hash_val % 8);                // printf(&quot;%d %d\\n&quot;,bloom_table[hash_val / 8], 1 &amp;lt;&amp;lt; hash_val %8);            }            // printf(&quot;################\\n&quot;);            return equal;        }    private:        uint8_t* bloom_table;        uint32_t mod, k;};int main(int argc, char const *argv[]){        std::string s = &quot;hello world&quot;;    std::string a = &quot;123456789&quot;;    std::string b = &quot;abcedefkljg&quot;;    BlooomFilters bf(1008611, 5);    bf.hash(s);    bf.hash(a);    bf.hash(b);    printf(&quot;%d %d %d\\n&quot;, bf.has_hashed(s), bf.has_hashed(a), bf.has_hashed(b));    printf(&quot;%d %d %d\\n&quot;, bf.has_hashed(&quot;fjlajflajf&quot;), bf.has_hashed(&quot;roquroqfa&quot;), bf.has_hashed(&quot;ghnnv,anv&quot;));    return 0;}"
  },
  
  {
    "title": "机器学习模型评估指标",
    "url": "/posts/model_evaluation_metrics/",
    "categories": "机器学习",
    "tags": "混淆矩阵, 机器学习, 分类, 回归",
    "date": "2022-07-20 00:00:00 +0800",
    





    "snippet": "做了很多次模型评估，在此记录一下。模型评估主要分为两类: 分类，回归分类分类常用的指标有:  Accuracy（准确率)  Precision（精确率）  Recall, Sensitivity（召回率，真正率，查全率，TPR）  Specificity （FPR，假正率）  F-Score （F值，Recall和Precision的调和值）  ROC曲线（Receiver Operating Characteristic，横轴为FPR，纵轴为TPR）  AUC （Area Under Curve，ROC曲线下的面积)首先根据定义计算混淆矩阵            实际\\预测      正      负                  正      TP      FN              负      FP      TN        True Positive (真正，TP)：将正类预测为正类数  True Negative(真负，TN)：将负类预测为负类数  False Positive(假正，FP)：将负类预测为正类数  False Negative(假负，FN)：将正类预测为负类数然后计算各指标      Accuracy\\(\\begin{aligned} Accuracy = \\dfrac{TP + TN}{TP + FN + FP + TN}\\end{aligned}\\)        Precision\\(\\begin{aligned} Precision = \\dfrac{TP}{TP + FP}\\end{aligned}\\)        Recall(TPR)\\(\\begin{aligned} Recall = \\dfrac{TP}{TP + FN}\\end{aligned}\\)        FPR\\(\\begin{aligned} FPR = \\dfrac{FP}{FP + TN}\\end{aligned}\\)        F-score\\(\\begin{aligned} F-score &amp;amp;= \\dfrac{(1 + \\beta^2)Precision * Recall}{\\beta^2Precision + Recall} \\\\ F1-score &amp;amp;= 2*\\dfrac{Precision * Recall}{Precision + Recall} \\qquad(\\beta = 1)\\end{aligned}\\)    ROC曲线          按照分类阈值从0到1分别计算不同的TPR和FPR，以FPR为横轴，TPR为纵轴将这些点连起来如此      ROC曲线能够尽量降低不同测试集带来的干扰，更加客观地衡量模型本身的性能        AUC          ROC曲线下的面积为AUC值      AUC值越大的分类器，正确率越高      回归回归常用的指标有:      MSE（Mean Square Error,均方误差）\\(\\begin{aligned}MSE = \\dfrac{1}{n}\\sum_{i=1}^{n}(\\hat{y_i} - y_i)^2\\end{aligned}\\)    RMSE（Root Mean Square Error, 均方根误差）\\(\\begin{aligned}RMSE = \\sqrt{\\dfrac{1}{n}\\sum_{i=1}^{n}(\\hat{y_i} - y_i)^2}\\end{aligned}\\)  MAE（Mean Absolute Error，平均绝对误差)\\(\\begin{aligned}MAE = \\dfrac{1}{n}\\sum_{i=1}^{n}|\\hat{y_i} - y_i|\\end{aligned}\\)"
  },
  
  {
    "title": "FFT",
    "url": "/posts/fft/",
    "categories": "信号处理",
    "tags": "fft, 信号处理, 傅立叶变换",
    "date": "2022-06-30 00:00:00 +0800",
    





    "snippet": "最近了解了下fft,在此记录下:离散傅里叶变换(Discrete Fourier Transform): 缩写为DFT，是傅里叶变换在时域和频域上都呈离散的形式，将信号的时域采样变换为其DTFT的频域采样。在形式上，变换两端（时域和频域上）的序列是有限长的，而实际上这两组序列都应当被认为是离散周期信号的主值序列。即使对有限长的离散信号作DFT，也应当将其看作其周期延拓的变换，傅立叶变换的结果通常是对称的。在实际应用中通常采用快速傅里叶变换计算DFT。快速傅里叶变换(Fast Fourier Transform, FFT): 是快速计算序列的离散傅里叶变换（DFT）或其逆变换的方法[1]。傅里叶分析将信号从原始域（通常是时间或空间）转换到频域的表示或者逆过来转换。FFT会通过把DFT矩阵分解为稀疏（大多为零）因子之积来快速计算此类变换。[2] 因此，它能够将计算DFT的复杂度从只用DFT定义计算需要的  $O(n^{2})$，降低到$O(n\\log n)$，其中$n$为数据大小。快速傅里叶变换广泛的应用于工程、科学和数学领域。这里的基本思想在1965年才得到普及，但早在1805年就已推导出来。[3] 1994年美国数学家吉尔伯特·斯特朗把FFT描述为“我们一生中最重要的数值算法”[4]，它还被IEEE科学与工程计算期刊列入20世纪十大算法  离散傅立叶变换快速傅立叶变换20世纪十大算法DFT对于$N$点序列${x[n]}_{0{\\leq}n&amp;lt;N}$，它的离散傅里叶变换(DFT)为  \\(\\begin{aligned}\\hat{x}[k] = \\sum\\limits_{n=0}^{N-1}e^{\\dfrac{-i2{\\pi}nk}{N}}x[n] \\qquad k = 0,1,..,N-1.\\end{aligned}\\)其中$e$是自然对数的底数，$i$是虚数单位。通常以符号$\\mathcal{F}$表示这一变换，即:\\(\\begin{aligned}    \\hat{x} = \\mathcal{F}x\\end{aligned}\\)离散傅里叶变换的逆变换(IDFT)为:\\(\\begin{aligned}    x[n] = \\dfrac{1}{N}\\sum\\limits_{k=0}^{N-1}e^{\\dfrac{i2{\\pi}nk}{N}}\\hat{x}[k] \\qquad n = 0,1,..,N-1.\\end{aligned}\\)可以记为：\\(\\begin{aligned}    x = \\mathcal{F}^{-1}\\hat{x}\\end{aligned}\\)实际上，DFT和IDFT变换式中和式前面的归一化系数并不重要。在上面的定义中，DFT和IDFT前的系数分别为$1$和$\\dfrac{1}{N}$有时会将这两个系数都改成$\\dfrac{1}{\\sqrt{N}}$。实现def dft(x):    &quot;&quot;&quot;    离散傅立叶变换    https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2    https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2    https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html    &quot;&quot;&quot;    N = len(x)    # print(&quot;dft data size: &quot;, N)    # 循环方式    y = np.zeros(N, dtype=&quot;complex_&quot;)    for k in range(N):        t0 = x * np.exp(-2j * np.pi * k * np.arange(N)/N)        # t1 = x * np.power(-1, -2 * k * np.arange(n)/n)  e^(i * pi) = -1 的替换，没有虚数        y[k] = np.sum(t0)    # 矩阵方式 虽然优雅，内存消耗极大O(n*n)    # n = np.arange(N)    # k = n.reshape((N, 1))    # e = np.exp(-2j * np.pi * k * n / N)    # y = e @ x    return yFFT用FFT计算DFT会得到与直接用DFT定义计算相同的结果,最重要的区别是FFT更快，直接用DFT求解需要$O(N^2)$,而用FFT则是能够在$O(N\\log{N})$内计算出来。其中库利-图基(Cooley and Tukey)算法是最常见的FFT算法.这一方法以分治法为策略递归地将长度为$N=N_{1}N_{2}$的离散傅里叶变换分解为长度为$N_{1}$的$N_{2}$个较短序列的离散傅里叶变换,因此:\\(\\begin{aligned}\\hat{x}[k] &amp;amp;= \\sum\\limits_{n=0}^{N-1}e^{\\dfrac{-i2{\\pi}nk}{N}}x[n] \\\\           &amp;amp;= \\sum\\limits_{m=0}^{N/2-1}e^{\\dfrac{-i2{\\pi}(2m)k}{N}}x[2m] + \\sum\\limits_{m=0}^{N/2-1}e^{\\dfrac{-i2{\\pi}(2m+1)k}{N}}x[2m+1] \\\\           &amp;amp;= \\sum\\limits_{m=0}^{N/2-1}e^{\\dfrac{-i2{\\pi}mk}{N/2}}x[2m] + e^{\\dfrac{-i2{\\pi}k}{N}}\\sum\\limits_{m=0}^{N/2-1}e^{\\dfrac{-i2{\\pi}mk}{N/2}}x[2m+1]\\end{aligned}\\)因此将长度为$N$的DFT计算分成了两个相似的DFT，其中一个是奇数序列，一个是偶数序列,因此递归下去时间复杂度接近$O(N{\\log}N)$, 由于需要不断的切分两个序列，即要求序列长度满足$N=2^j$,就就是要求长度是2的幂实现def fft(x):	&quot;&quot;&quot;	https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.03-Fast-Fourier-Transform.html	https://jakevdp.github.io/blog/2013/08/28/understanding-the-fft/		A recursive implementation of 	the 1D Cooley-Tukey FFT, the 	input should have a length of 	power of 2. 	&quot;&quot;&quot;	N = len(x)	if N == 1:		return x	else:		X_even = fft(x[::2])		X_odd = fft(x[1::2])		factor = \\			np.exp(-2j*np.pi*np.arange(N) / N)		X = np.concatenate(			[X_even+factor[:int(N/2)]*X_odd,				X_even+factor[int(N/2):]*X_odd])		return X对于一般长度的序列通常采用布鲁斯坦(bluestein)算法，这个没有看懂。而且各大算法库(numpy,scipy)基本找不到实现，这里记录一个开源免费的实现https://www.nayuki.io/page/free-small-fft-in-multiple-languages。# # Computes the discrete Fourier transform (DFT) or inverse transform of the given complex vector, returning the result as a new vector.# The vector can have any length. This is a wrapper function. The inverse transform does not perform scaling, so it is not a true inverse.# def transform(vec, inverse):	n = len(vec)	if n == 0:		return []	elif n &amp;amp; (n - 1) == 0:  # Is power of 2		return transform_radix2(vec, inverse)	else:  # More complicated algorithm for arbitrary sizes		return transform_bluestein(vec, inverse)# # Computes the discrete Fourier transform (DFT) of the given complex vector, returning the result as a new vector.# The vector&#39;s length must be a power of 2. Uses the Cooley-Tukey decimation-in-time radix-2 algorithm.# def transform_radix2(vec, inverse):	# Returns the integer whose value is the reverse of the lowest &#39;width&#39; bits of the integer &#39;val&#39;.	def reverse_bits(val, width):		result = 0		for _ in range(width):			result = (result &amp;lt;&amp;lt; 1) | (val &amp;amp; 1)			val &amp;gt;&amp;gt;= 1		return result		# Initialization	n = len(vec)	levels = n.bit_length() - 1	if 2**levels != n:		raise ValueError(&quot;Length is not a power of 2&quot;)	# Now, levels = log2(n)	coef = (2 if inverse else -2) * cmath.pi / n	exptable = [cmath.rect(1, i * coef) for i in range(n // 2)]	vec = [vec[reverse_bits(i, levels)] for i in range(n)]  # Copy with bit-reversed permutation		# Radix-2 decimation-in-time FFT	size = 2	while size &amp;lt;= n:		halfsize = size // 2		tablestep = n // size		for i in range(0, n, size):			k = 0			for j in range(i, i + halfsize):				temp = vec[j + halfsize] * exptable[k]				vec[j + halfsize] = vec[j] - temp				vec[j] += temp				k += tablestep		size *= 2	return vec# # Computes the discrete Fourier transform (DFT) of the given complex vector, returning the result as a new vector.# The vector can have any length. This requires the convolution function, which in turn requires the radix-2 FFT function.# Uses Bluestein&#39;s chirp z-transform algorithm.# def transform_bluestein(vec, inverse):	# Find a power-of-2 convolution length m such that m &amp;gt;= n * 2 + 1	n = len(vec)	if n == 0:		return []	m = 2**((n * 2).bit_length())		coef = (1 if inverse else -1) * cmath.pi / n	exptable = [cmath.rect(1, (i * i % (n * 2)) * coef) for i in range(n)]  # Trigonometric table	avec = [(x * y) for (x, y) in zip(vec, exptable)] + [0] * (m - n)  # Temporary vectors and preprocessing	bvec = exptable[ : n] + [0] * (m - (n * 2 - 1)) + exptable[ : 0 : -1]	bvec = [x.conjugate() for x in bvec]	cvec = convolve(avec, bvec, False)[ : n]  # Convolution	return [(x * y) for (x, y) in zip(cvec, exptable)]  # Postprocessing# # Computes the circular convolution of the given real or complex vectors, returning the result as a new vector. Each vector&#39;s length must be the same.# realoutput=True: Extract the real part of the convolution, so that the output is a list of floats. This is useful if both inputs are real.# realoutput=False: The output is always a list of complex numbers (even if both inputs are real).# def convolve(xvec, yvec, realoutput=True):	assert len(xvec) == len(yvec)	n = len(xvec)	xvec = transform(xvec, False)	yvec = transform(yvec, False)	for i in range(n):		xvec[i] *= yvec[i]	xvec = transform(xvec, True)		# Scaling (because this FFT implementation omits it) and postprocessing	if realoutput:		return [(val.real / n) for val in xvec]	else:		return [(val / n) for val in xvec]## 以上所有完整代码见fft.py"
  },
  
  {
    "title": "关于WAVE那些事情",
    "url": "/posts/wave/",
    "categories": "音频处理",
    "tags": "wave, 声压级, 频谱",
    "date": "2022-06-24 00:00:00 +0800",
    





    "snippet": "最近了解下wav文件, 记录下wave文件的格式和一些简单的音频处理格式  Wav FormatWave文件格式wave一般由两部分组成，一部分是头部，一部分是数据wave文件头部一般如下所示:            位置      一般内容      解释                  4 bytes      “RIFF”      文件类型格式              4 bytes      filesize      其值为filesize字段后的大小，真正的文件大小为filesize + 8 bytes              4 bytes      WAVE      文件格式              4 bytes      “fmt “      chunk id,fmt即format，这个chunk保存了音频的采样率、声道数、采样位数等关键信息              4 bytes      fmt chunk size      fmt chunk的大小，一般有16/18/20/22/40字节              2 bytes      Audio Format      编码格式代码              2 bytes      Num channels      声道数，一般有1-8              4 bytes      Sample Rate      采样率 48000HZ, 44100HZ              4 bytes      Byte Rate      传输速率，每秒的字节数，计算公式为：采样率channels采样位数/8              2 bytes      Block Align      块对齐，告知播放软件一次性需处理多少字节，公式为： 采样位数*声道数/8              2 bytes      Bits Per Sample      采样位数，一般有8/16/24/32/64，值越大，对声音的还原度越高              4 bytes      “data”      data chunk marker              4 bytes      Data Size N      原始音频数据的大小              N bytes      Data      原始音频数据，音频数字信号      这里说明一下，采样率是一秒钟采样的频率，采样位数除以8等于采样宽度，即需要几个字节凑成一个数字信号（小端序带符号)。代码实现用python实现读取wav文件class MyWave:    def __init__(self, wavpath: str) -&amp;gt; None:        self.wavpath = wavpath        self.wav_fp = open(wavpath, &quot;rb&quot;)        self.readheader()    def readheader(self):        &quot;&quot;&quot;https://docs.fileformat.com/audio/wav/&quot;&quot;&quot;        self.wav_fp.seek(0)        self.file_kind_marker = str(self.wav_fp.read(4), encoding=&quot;utf-8&quot;)        self.file_size = int.from_bytes(self.wav_fp.read(4), byteorder=&quot;little&quot;)        self.file_type_header = str(self.wav_fp.read(4), encoding=&quot;utf-8&quot;)        self.format_chunk_marker = str(self.wav_fp.read(4), encoding=&quot;utf-8&quot;)        self.length_above_format_data = int.from_bytes(            self.wav_fp.read(4), byteorder=&quot;little&quot;)        self.format = int.from_bytes(self.wav_fp.read(2), byteorder=&quot;little&quot;)        self.channels = int.from_bytes(self.wav_fp.read(2), byteorder=&quot;little&quot;)        self.sample_rate = int.from_bytes(            self.wav_fp.read(4), byteorder=&quot;little&quot;)        self.byte_rate = int.from_bytes(self.wav_fp.read(4), byteorder=&quot;little&quot;)        self.block_align = int.from_bytes(            self.wav_fp.read(2), byteorder=&quot;little&quot;)        self.sample_width = int.from_bytes(            self.wav_fp.read(2), byteorder=&quot;little&quot;) // 8        self.data_chunk_marker = str(self.wav_fp.read(4), encoding=&quot;utf-8&quot;)        self.data_size = int.from_bytes(self.wav_fp.read(4), byteorder=&quot;little&quot;)    def getparams(self):        &quot;&quot;&quot;        读取部分参数        &quot;&quot;&quot;        return self.channels, self.sample_width, self.sample_rate, self.data_size // self.sample_width    def readframes(self):        &quot;&quot;&quot;        读取数据转振幅        &quot;&quot;&quot;        self.wav_fp.seek(44)        data = self.wav_fp.read()        fmt = &quot;&amp;lt;i%d&quot; % (self.sample_width)        return np.frombuffer(data, dtype=fmt)音频处理这里对音频进行简单的振幅，声压以及频谱分析振幅:是指振动的物理量可能达到的最大值，通常以A表示。它是表示振动的范围和强度的物理量。声压级: 声学中，声音的强度定义为声压。计算分贝值时采用20微帕斯卡为参考值[5]。这一参考值是人类对声音能够感知的阈值下限。声压是场量，因此使用声压计算分贝时使用下述版本的公式:\\[\\begin{aligned}L_p = 20\\log_{10}(\\dfrac{p_{rms}}{p_{ref}}) db\\end{aligned}\\]其中的$p_{ref}$是标准参考声压值20微帕。在空气中1帕斯卡等于94分贝声压级。在其他介质，如水下，1微帕斯卡更为普遍。这些标准被ANSIS1.1-1994.所收录.频谱: 是指一个时域的信号在频域下的表示方式，可以针对信号进行傅里叶变换而得，所得的结果会是分别以幅度及相位为纵轴，频率为横轴的两张图，不过有时也会省略相位的信息，只有不同频率下对应幅度的资料。有时也以“幅度频谱”表示幅度随频率变化的情形，“相位频谱”表示相位随频率变化的情形。一个声音信号（左图）及其对应的频谱.简单来说，频谱可以表示一个信号是由哪些频率的弦波所组成，也可以看出各频率弦波的大小及相位等信息。详情见下方的代码    def normalize(self, data):        &#39;&#39;&#39;归一化&#39;&#39;&#39;        scale = 1.0 / (1 &amp;lt;&amp;lt; (8 * self.sample_width - 1))        return data * scale    def cal_spl(self, data, seg=1024):        &#39;&#39;&#39;        计算声压 db         https://zh.m.wikipedia.org/zh-hans/%E5%88%86%E8%B2%9D        https://en.wikipedia.org/wiki/Sound_pressure        &#39;&#39;&#39;        data_len = len(data)        frame_num = int(math.ceil(data_len / seg))        volume = np.zeros((frame_num, 1))        for i in range(frame_num):            curFrame = data[i*seg: i*seg+seg]            curFrame = curFrame - np.mean(curFrame)  # zero-justified            # volume[i] = 10*np.log10(np.sum(curFrame*curFrame))            prms = np.sqrt(np.mean(curFrame * curFrame))            pref = 20e-6  # 空气中 20微pa，水中 1微pa            volume[i] = 20 * np.log10(prms / pref)        return volume    def cal_spectrum(self, data, seg=1024):        &quot;&quot;&quot;        https://zh.m.wikipedia.org/wiki/%E9%A2%91%E8%B0%B1        计算频谱，傅立叶变换之后计算强度        &quot;&quot;&quot;        # print(&quot;dft begin &quot;)        # fft_y = self.fft(data)        # fft_y = self.dft(data)        fft_y = scipy.fft.fft(data)        fft_y = self.cal_spl(fft_y, seg=seg)        return fft_ydef test_wave():    sys.argv.append(&quot;0.wav&quot;)    mw = MyWave(sys.argv[1])    print(mw)    # 读取数据    wav_data = mw.readframes()    amplitude = mw.normalize(wav_data)    nchannels, sampwidth, framerate, nframes = mw.getparams()    time1 = np.arange(0, len(amplitude)) * (1.0 / framerate)    seg = int(20e-3 * framerate)  # 20ms 50ms 100ms 常用计算区间    volume = mw.cal_spl(amplitude, seg=seg)    time2 = np.arange(0, len(volume)) * seg * 1.0 / framerate    test_sz = 1024    fft_y = mw.cal_spectrum(amplitude[:test_sz], seg)    fft_x = np.arange(0, len(fft_y)) * seg * framerate / len(amplitude)    plt.subplot(311)    plt.plot(time1, amplitude)    plt.subplot(312)    plt.plot(time2, volume, label=&quot;db&quot;)    plt.legend()    plt.subplot(313)    plt.plot(fft_x, fft_y)    plt.show()## 完整代码见test_wav.py"
  },
  
  {
    "title": "poco动态加载class",
    "url": "/posts/poco/",
    "categories": "C++编程",
    "tags": "rtti, mainboard, poco",
    "date": "2022-06-10 00:00:00 +0800",
    





    "snippet": "了解一下apollo mainboard的启动流程,觉得挺灵活的。在此记录一下,并自己简单实现了一下demo。mainboard 启动流程  启动命令mainboad -d xxx.dag  读取dag文件，尤其是module_library字段和class_name  通过poco动态加载module_library，并在module_library中加载class_name  实例化对象Component  调用其Init,Proc函数mainboard根据dag文件动态加载不同的class，执行不同的操作。具有极大的灵活方便且统一调度。同时所有component都基于一个基类ComponentBase，约束了其行为。  示例dag文件    module_config {  module_library : &quot;XXXX.so&quot;  components {      class_name : &quot;XXXX&quot;      config {          name: &quot;xxxx&quot;          config_file_path : &quot;xxxx.pb.txt&quot;      }  }}      基于poco的demo  安装poco          apt安装sudo apt install libpoco-dev      源码安装见POCO      poco SharedLibrary介绍SaredLibrary        简单demo/****************************************************************************** * Copyright 2022  All Rights Reserved. ********************************************************/#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;Poco/ClassLibrary.h&amp;gt;   // NOLINT#include &amp;lt;Poco/ClassLoader.h&amp;gt;    // NOLINT#include &amp;lt;Poco/SharedLibrary.h&amp;gt;  // NOLINTclass Component { public:  Component() {}  virtual ~Component() {}  virtual bool Init() = 0;  virtual bool Proc() = 0;};class RtkComponent : public Component { public:  bool Init() override { return true; }  bool Proc() override {    std::cout &amp;lt;&amp;lt; &quot;hello rtk component&quot; &amp;lt;&amp;lt; std::endl;    return true;  }};class CameraComponent : public Component { public:  bool Init() override { return true; }  bool Proc() override {    std::cout &amp;lt;&amp;lt; &quot;hello camera component&quot; &amp;lt;&amp;lt; std::endl;    return true;  }};POCO_BEGIN_MANIFEST(Component)POCO_EXPORT_CLASS(RtkComponent)POCO_EXPORT_CLASS(CameraComponent)POCO_END_MANIFESTint main(int argc, char* argv[]) {  if (argc &amp;lt; 3) {    std::cout &amp;lt;&amp;lt; &quot;args not enough&quot; &amp;lt;&amp;lt; std::endl;    std::cout &amp;lt;&amp;lt; &quot;example: test_poco library_path classname&quot; &amp;lt;&amp;lt; std::endl;    return -1;  }  std::string library_path(argv[1]);  std::string classname(argv[2]);  std::cout &amp;lt;&amp;lt; &quot;load library:&quot; &amp;lt;&amp;lt; library_path            &amp;lt;&amp;lt; &quot; , load classname: &quot; &amp;lt;&amp;lt; classname &amp;lt;&amp;lt; std::endl;  Poco::ClassLoader&amp;lt;Component&amp;gt; clc;  try {    clc.loadLibrary(library_path);  } catch (const Poco::Exception e) {    std::cerr &amp;lt;&amp;lt; e.displayText() &amp;lt;&amp;lt; std::endl;    return -1;  }  auto* base = clc.create(classname);  if (base-&amp;gt;Init()) {    base-&amp;gt;Proc();  }  return 0;}// ./test_poco ./libcomponent.so CameraComponent// ./test_poco ./libcomponent.so RtkComponent  cmake文件project(test)add_executable(test_poco test_poco.cpp)add_library(component SHARED test_poco.cpp)target_link_libraries(test_poco    PocoFoundation)target_link_libraries(component    PocoFoundation)"
  },
  
  {
    "title": "匈牙利算法",
    "url": "/posts/hungarian/",
    "categories": "算法和数据结构",
    "tags": "算法, 目标关联",
    "date": "2022-06-09 00:00:00 +0800",
    





    "snippet": "匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。本质是为了解决二分图匹配问题。大致理解如下:有n个男的，m个女的。男的只能跟女的配对，且只能一对一配对。同时，如果男女配对需要消耗彩礼cost，不同男女之间的彩礼是不一样的。问如何尽可能的配对，同时配对所消耗的彩礼最小。匈牙利本质就是解决这种问题。具体可以看匈牙利算法详解,此算法常用于目标关联，目标融合，目标匹配等场景。本文主要记录如何实现。cost相同，尽可能匹配多#include &amp;lt;bits/stdc++.h&amp;gt;#define INF 0x3f3f3f3f;using namespace std;int L[505][505];int boy[505];int used[505];int k,m,n;  //可能的组合数k，女生数m，男生数n // 二分图匹配 bool find(int i){    for(int j=1;j&amp;lt;=n;j++){        if(L[i][j] &amp;amp;&amp;amp; !used[j]){  //跟他有关系而且没有搜索过             used[j]=1;            if(!boy[j] || find(boy[j])){                boy[j]=i;                return true;            }        }    }    return false;}int main(){    while(cin&amp;gt;&amp;gt;k&amp;gt;&amp;gt;m&amp;gt;&amp;gt;n){        memset(L,0,sizeof(L));        memset(boy,0,sizeof(boy));        for(int i=1;i&amp;lt;=k;i++){            int n1,n2;            cin&amp;gt;&amp;gt;n1&amp;gt;&amp;gt;n2;            L[n1][n2]=1;        }        int sum=0;        for(int i=1;i&amp;lt;=m;i++){            memset(used,0,sizeof(used));            if(find(i)) sum++;        }        cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;endl;    }    return 0;} cost不同，尽可能cost最小，递归方法#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int INF = 0x3f3f3f3f;int love[305][305];    // 每个妹子对每个男生的好感度 int ex_girl[305];      // 每个妹子的期望值int ex_boy[305];       // 每个男生的期望值bool vis_girl[305];    // 每一轮匹配匹配过的女生bool vis_boy[305];     // 每一轮匹配匹配过的男生int match[305];        // 每个男生匹配到的妹子 如果没有则为-1int slack[305];        // 每个汉子如果能被妹子倾心最少还需要多少期望值int n;bool dfs(int girl){    vis_girl[girl] = true;    for (int boy = 0; boy &amp;lt; n; boy++) {        if (vis_boy[boy]) continue; // 每一轮匹配 每个男生只尝试一次        int gap = ex_girl[girl] + ex_boy[boy] - love[girl][boy];        if (gap == 0) {  // 如果符合要求            vis_boy[boy] = true;            if (match[boy] == -1 || dfs( match[boy] )) {    // 找到一个没有匹配的男生 或者该男生的妹子可以找到其他人                match[boy] = girl;                return true;            }        }else{            slack[boy] = min(slack[boy], gap);  // slack 可以理解为该男生要得到女生的倾心 还需多少期望值 取最小值 备胎的样子        }    }    return false;}int KM(){    memset(match, -1, sizeof match);    // 初始每个男生都没有匹配的女生    memset(ex_boy, 0, sizeof ex_boy);   // 初始每个男生的期望值为0    // 每个女生的初始期望值是与她相连的男生最大的好感度    for (int i = 0; i &amp;lt; n; i++) {        ex_girl[i] = love[i][0];        for (int j = 1; j &amp;lt; n; j++) {            ex_girl[i] = max(ex_girl[i], love[i][j]);        }    }    // 尝试为每一个女生解决归宿问题    for (int i = 0; i &amp;lt; n; i++) {        fill(slack, slack + n, INF);    // 因为要取最小值 初始化为无穷大        while(1){            // 为每个女生解决归宿问题的方法是 ：如果找不到就降低期望值，直到找到为止            // 记录每轮匹配中男生女生是否被尝试匹配过            memset(vis_girl, false, sizeof vis_girl);            memset(vis_boy, false, sizeof vis_boy);            if(dfs(i)) break;  // 找到归宿 退出            // 如果不能找到 就降低期望值            // 最小可降低的期望值            int d = INF;            for (int j = 0; j &amp;lt; n; j++)                if (!vis_boy[j])    d = min(d, slack[j]);            for (int j = 0; j &amp;lt; n; j++) {                // 所有访问过的女生降低期望值                if (vis_girl[j]) ex_girl[j] -= d;                // 所有访问过的男生增加期望值                if (vis_boy[j]) ex_boy[j] += d;                // 没有访问过的boy 因为girl们的期望值降低，距离得到女生倾心又进了一步！                else slack[j] -= d;            }        }    }    // 匹配完成 求出所有配对的好感度的和    int res = 0;    for (int i = 0; i &amp;lt; n; i++)        res += love[match[i]][i];    return res;}int main(){    while (cin&amp;gt;&amp;gt;n) {        for (int i = 0; i &amp;lt; n; i++)            for (int j = 0; j &amp;lt; n; j++)                cin&amp;gt;&amp;gt;love[i][j];        cout&amp;lt;&amp;lt;KM()&amp;lt;&amp;lt;endl;    }    return 0;}        cost不同，尽可能cost最小，矩阵方法import numpy as npclass Munkres:    def __init__(self, cost: list, inv_eps=1000) -&amp;gt; None:        &quot;&quot;&quot;[summary]        https://brc2.com/the-algorithm-workshop/        Args:            cost (list): [二维权值方阵]        &quot;&quot;&quot;        self.cost = np.array(cost) * inv_eps        self.cost.astype(np.int32)        self.run_cost = self.cost        self.rows = len(cost)        self.cols = len(cost[0])        self.step = 1        self.running = True        assert(self.rows == self.cols)        self.mp = {            1: self.step_one,            2: self.step_two,            3: self.step_three,            4: self.step_four,            5: self.step_five,            6: self.step_six,            7: self.step_seven        }        self.mask = np.zeros((self.rows, self.cols))        self.row_cover = np.zeros(self.rows)        self.col_cover = np.zeros(self.cols)        self.paths = []    def step_one(self):        &quot;&quot;&quot;[summary]            For each row of the matrix, find the smallest element and subtract it from every element in its row.  Go to Step 2        &quot;&quot;&quot;        for i in range(self.rows):            self.run_cost[i] -= min(self.run_cost[i])        self.step = 2    def step_two(self):        &quot;&quot;&quot;[summary]        Find a zero (Z) in the resulting matrix. If there is no starred zero in its row or column, star Z. Repeat for each element in the matrix. Go to Step 3        &quot;&quot;&quot;        for i in range(self.rows):            for j in range(self.cols):                if self.run_cost[i][j] == 0 and self.row_cover[i] == 0 and self.col_cover[j] == 0:                    self.mask[i][j] = 1                    self.row_cover[i] = 1                    self.col_cover[j] = 1        for i in range(self.rows):            self.row_cover[i] = 0        for j in range(self.cols):            self.col_cover[j] = 0        self.step = 3    def step_three(self):        &quot;&quot;&quot;[summary]            Cover each column containing a starred zero.              If K columns are covered, the starred zeros describe a complete set of unique assignments.              In this case, Go to DONE, otherwise, Go to Step 4.        &quot;&quot;&quot;        for i in range(self.rows):            for j in range(self.cols):                if self.mask[i][j] == 1:                    self.col_cover[j] = 1        colcount = np.sum(self.col_cover)        if colcount &amp;gt;= self.rows or colcount &amp;gt;= self.cols:            self.step = 7        else:            self.step = 4    def __find_a_zero(self):        &quot;&quot;&quot;[summary]         Find a noncovered zero        Returns:            [type]: [row, col , default -1]        &quot;&quot;&quot;        r, c = -1, -1        for i in range(self.rows):            for j in range(self.cols):                if self.run_cost[i][j] == 0 and self.row_cover[i] == 0 and self.col_cover[j] == 0:                    return i, j        return r, c    def __find_star_in_row(self, row):        &quot;&quot;&quot;[summary]        Args:            row ([type]): [row]        Returns:            [int]: [find stared col in row, default -1]        &quot;&quot;&quot;        for j in range(self.cols):            if self.mask[row][j] == 1:                return j        return -1    def step_four(self):        &quot;&quot;&quot;[summary]            Find a noncovered zero and prime it.  If there is no starred zero in the row containing this primed zero, Go to Step 5.              Otherwise, cover this row and uncover the column containing the starred zero.             Continue in this manner until there are no uncovered zeros left. Save the smallest uncovered value and Go to Step 6.        &quot;&quot;&quot;        done = False        while not done:            noncover_r, noncover_c = self.__find_a_zero()            if noncover_r == -1:                done = True                self.step = 6            else:                self.mask[noncover_r][noncover_c] = 2                star_col = self.__find_star_in_row(noncover_r)                if star_col != -1:                    self.row_cover[noncover_r] = 1                    self.col_cover[star_col] = 0                else:                    done = True                    self.step = 5                    self.paths.append((noncover_r, noncover_c))    def __find_star_in_col(self, col):        for i in range(self.rows):            if self.mask[i][col] == 1:                return i        return -1    def __find_prime_in_row(self, row):        &quot;&quot;&quot;[summary]        Args:            col ([type]): [col]        Returns:            [int]: [find prime row in col, default -1]        &quot;&quot;&quot;        for j in range(self.cols):            if self.mask[row][j] == 2:                return j        return -1    def step_five(self):        &quot;&quot;&quot;[summary]            Construct a series of alternating primed and starred zeros as follows.  Let Z0 represent the uncovered primed zero found in Step 4.             Let Z1 denote the starred zero in the column of Z0 (if any). Let Z2 denote the primed zero in the row of Z1 (there will always be one).              Continue until the series terminates at a primed zero that has no starred zero in its column.             Unstar each starred zero of the series, star each primed zero of the series, erase all primes and uncover every line in the matrix.  Return to Step 3        &quot;&quot;&quot;                done = False        while not done:            star_r = self.__find_star_in_col(self.paths[-1][1])            if star_r &amp;gt; -1:                self.paths.append( (star_r, self.paths[-1][1]) )            else:                done = True            if not done:                prime_c = self.__find_prime_in_row( self.paths[-1][0] )                self.paths.append( (self.paths[-1][0], prime_c))        # argument path        for i, j in self.paths:            if self.mask[i][j] == 1:                self.mask[i][j] = 0            else:                self.mask[i][j] = 1        # clear covers        for i in range(self.rows):            self.row_cover[i] = 0        for j in range(self.cols):            self.col_cover[j] = 0        # erase prime        for i in range(self.rows):            for j in range(self.cols):                if self.mask[i][j] == 2:                    self.mask[i][j] = 0        self.paths.clear()        self.step = 3    def step_six(self):        &quot;&quot;&quot;[summary]            Add the value found in Step 4 to every element of each covered row, and subtract it from every element of each uncovered column.              Return to Step 4 without altering any stars, primes, or covered lines        &quot;&quot;&quot;        minval = 1 &amp;lt;&amp;lt; 31        for i in range(self.rows):            for j in range(self.cols):                if self.row_cover[i] == 0 and self.col_cover[j] == 0:                    minval = min(self.run_cost[i][j], minval)        for i in range(self.rows):            for j in range(self.cols):                if self.row_cover[i] == 1:                    self.run_cost[i][j] += minval                if self.col_cover[j] == 0:                    self.run_cost[i][j] -= minval        self.step = 4    def step_seven(self):        # print(&quot;done !&quot;)        # print(self.run_cost)        # print(self.mask)        self.running = False    def run(self):        while self.running:            # print(self.step)            self.mp[self.step]()            # print(self.run_cost)            # print(&quot;&quot;)    def get_result(self):        res = []        vis = [0] * self.cols        for i in range(self.rows):            for j in range(self.cols):                if self.mask[i][j] == 1 and vis[j] == 0:                    res.append(j)                    vis[j] = 1                    break        if len(res) != self.rows:            print(&quot;algorithm error ...&quot;)            return None        return resif  __name__ == &quot;__main__&quot;:    cost = [ [1.2, 1., 1.], [1., 1.2, 1.], [1., 1., 1.2]]    mkr = Munkres(cost)    mkr.run()    print(mkr.get_result())以上三种方式中，第三种广泛使用目标关联中。其具体原理见Munkres’ Assignment Algorithm"
  },
  
  {
    "title": "类型转换",
    "url": "/posts/class-cast/",
    "categories": "C++编程",
    "tags": "类型转换",
    "date": "2022-02-25 00:00:00 +0800",
    





    "snippet": "C++ 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：            关键字      说明                  static_cast      用于良性转换，一般不会导致意外发生，风险很低。              const_cast      用于 const 与非 const、volatile 与非 volatile 之间的转换。              reinterpret_cast      高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。              dynamic_cast      借助 RTTI，用于类型安全的向下转型（Downcasting）。        具体实践"
  },
  
  {
    "title": "智能指针",
    "url": "/posts/smart-pointer/",
    "categories": "C++编程",
    "tags": "智能指针",
    "date": "2022-02-24 00:00:00 +0800",
    





    "snippet": "RAII与引用计数  现代c++教程在传统 C++ 中，需要手动释放资源，有可能就忘记了去释放资源而导致泄露。所以通常的做法是对于一个对象而言，在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 new 和 delete 去 『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针就包括 std::shared_ptr、std::unique_ptr、std::weak_ptr，使用它们需要包含头文件 。std::shared_ptrstd::shared_ptr是一种智能指针，它能够记录多少个shared_ptr共同指向一个对象，从而消除显式的调用delete，当引用计数变为零的时候就会将对象自动删除。但还不够，因为使用std::shared_ptr仍然需要使用new来调用，这使得代码出现了某种程度上的不对称,std::make_shared就能够用来消除显式的使用 new，所以std::make_shared会分配创建传入参数中的对象，并返回这个对象类型的std::shared_ptr指针.#include &amp;lt;iostream&amp;gt;#include &amp;lt;memory&amp;gt;int main() {    // auto pointer = new int(10); // illegal, no direct assignment    // Constructed a std::shared_ptr    std::shared_ptr&amp;lt;int&amp;gt; pointer = std::make_shared&amp;lt;int&amp;gt;(10);    std::cout &amp;lt;&amp;lt; *pointer &amp;lt;&amp;lt; std::endl; // 11    return 0;}std::shared_ptr可以通过get() 方法来获取原始指针，通过reset() 来减少一个引用计数，并通过use_count() 来查看一个对象的引用计数。例如：auto pointer = std::make_shared&amp;lt;int&amp;gt;(10);auto pointer2 = pointer; // 引用计数+1auto pointer3 = pointer; // 引用计数+1int *p = pointer.get(); // 这样不会增加引用计数std::cout &amp;lt;&amp;lt; &quot;pointer.use_count() = &quot; &amp;lt;&amp;lt; pointer.use_count() &amp;lt;&amp;lt; std::endl; // 3std::cout &amp;lt;&amp;lt; &quot;pointer2.use_count() = &quot; &amp;lt;&amp;lt; pointer2.use_count() &amp;lt;&amp;lt; std::endl; // 3std::cout &amp;lt;&amp;lt; &quot;pointer3.use_count() = &quot; &amp;lt;&amp;lt; pointer3.use_count() &amp;lt;&amp;lt; std::endl; // 3pointer2.reset();std::cout &amp;lt;&amp;lt; &quot;reset pointer2:&quot; &amp;lt;&amp;lt; std::endl;std::cout &amp;lt;&amp;lt; &quot;pointer.use_count() = &quot; &amp;lt;&amp;lt; pointer.use_count() &amp;lt;&amp;lt; std::endl; // 2std::cout &amp;lt;&amp;lt; &quot;pointer2.use_count() = &quot; &amp;lt;&amp;lt; pointer2.use_count() &amp;lt;&amp;lt; std::endl; // 0, pointer2 已 resetstd::cout &amp;lt;&amp;lt; &quot;pointer3.use_count() = &quot; &amp;lt;&amp;lt; pointer3.use_count() &amp;lt;&amp;lt; std::endl; // 2pointer3.reset();std::cout &amp;lt;&amp;lt; &quot;reset pointer3:&quot; &amp;lt;&amp;lt; std::endl;std::cout &amp;lt;&amp;lt; &quot;pointer.use_count() = &quot; &amp;lt;&amp;lt; pointer.use_count() &amp;lt;&amp;lt; std::endl; // 1std::cout &amp;lt;&amp;lt; &quot;pointer2.use_count() = &quot; &amp;lt;&amp;lt; pointer2.use_count() &amp;lt;&amp;lt; std::endl; // 0std::cout &amp;lt;&amp;lt; &quot;pointer3.use_count() = &quot; &amp;lt;&amp;lt; pointer3.use_count() &amp;lt;&amp;lt; std::endl; // 0, pointer3 已 resetstd::unique_ptrstd::unique_ptr是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全：std::unique_ptr&amp;lt;int&amp;gt; pointer = std::make_unique&amp;lt;int&amp;gt;(10); // make_unique 从 C++14 引入std::unique_ptr&amp;lt;int&amp;gt; pointer2 = pointer; // 非法std::weak_ptrstd::weak_ptr是一种弱引用（相比较而言std::shared_ptr就是一种强引用）。弱引用不会引起引用计数增加.std::weak_ptr没有 * 运算符和 -&amp;gt; 运算符，所以不能够对资源进行操作，它可以用于检查std::shared_ptr是否存在，其expired()方法能在资源未被释放时，会返回 false，否则返回 true；除此之外，它也可以用于获取指向原始对象的 std::shared_ptr 指针，其 lock() 方法在原始对象未被释放时，返回一个指向原始对象的 std::shared_ptr 指针，进而访问原始对象的资源，否则返回nullptr。代码实现一种简单的shared_ptr实现#include &amp;lt;string.h&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;memory&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;std::map&amp;lt;uint64_t, uint64_t&amp;gt; ref_count;template &amp;lt;typename T&amp;gt;class MySharedPointer{private:    T *value_;    uint64_t idx_;public:    MySharedPointer(T &amp;amp;value)    {        value_ = new T;        memcpy(value_, &amp;amp;value, sizeof(T));        idx_ = reinterpret_cast&amp;lt;uint64_t&amp;gt;(value_);        ref_count[idx_] += 1;    }    ~MySharedPointer()    {        std::cout &amp;lt;&amp;lt; *value_ &amp;lt;&amp;lt; std::endl;        uint64_t count = ref_count[idx_];        if (count &amp;gt; 0)        {            count -= 1;            ref_count[idx_] -= 1;        }        if (count &amp;lt;= 0)        {            printf(&quot;destory memory ..\\n&quot;);            delete value_;            ref_count.erase(idx_);        }    }    MySharedPointer(MySharedPointer &amp;amp;others)    {        idx_ = others.idx_;        value_ = others.value_;        ref_count[idx_] += 1;    }};struct TestNode{    int a, b;    double c;    friend std::ostream &amp;amp; operator&amp;lt;&amp;lt; (std::ostream &amp;amp;os, TestNode &amp;amp;c)    {        os &amp;lt;&amp;lt; c.a &amp;lt;&amp;lt; &quot;#&quot; &amp;lt;&amp;lt; c.b &amp;lt;&amp;lt; &quot;#&quot; &amp;lt;&amp;lt; c.c ;        return os;    }};int main(int argc, char *argv[]){    TestNode node;    node.a = node.b = node.c = 10;    MySharedPointer&amp;lt;TestNode&amp;gt; a(node);    MySharedPointer&amp;lt;TestNode&amp;gt; b(a);    return 0;}"
  },
  
  {
    "title": "动力学模型",
    "url": "/posts/dynamics_module/",
    "categories": "运动控制",
    "tags": "模型, 动力学",
    "date": "2022-02-09 00:00:00 +0800",
    





    "snippet": "车辆动力学模型  动力学模型动力学主要研究作用于物体的力与物体运动的关系，车辆动力学模型一般用于分析车辆的平顺性和车辆操纵的稳定性。对于车来说，研究车辆动力学，主要是研究车辆轮胎及其相关部件的受力情况。比如纵向速度控制，通过控制轮胎转速实现；横向航向控制，通过控制轮胎转角实现。正常情况下，车辆上的作用力沿着三个不同的轴分布：  纵轴上的力包括驱动力和制动力，以及滚动阻力和拖拽阻力作滚摆运动；  横轴上的力包括转向力、离心力和侧风力，汽车绕横轴作俯仰运动；  立轴上的力包括车辆上下振荡施加的力，汽车绕立轴作偏摆或转向运动而在单车模型假设的前提下，再作如下假设即可简单搭建车辆的动力学模型：  只考虑纯侧偏轮胎特性，忽略轮胎力的纵横向耦合关系；  用单车模型来描述车辆的运动，不考虑载荷的左右转移；  忽略横纵向空气动力学。其中需要考虑的受力点有：  横向运动：曲线行驶时的离心力，侧偏力等  纵向运动：受总驱动阻力、加速、减速等的影响。总驱动阻力由滚动阻力、拖拽阻力和坡度阻力等构成。横向车辆动力学各变量说明如下：  $m, m_f, m_r$整车质量，前挂质量，后挂质量  $\\delta_f, \\delta_r$ 前后轮转角  $\\alpha_f, \\alpha_r$ 前后轮滑移角  $C_{\\alpha f}, C_{\\alpha r}$ 前后轮侧偏刚度  $\\psi，\\dot{\\psi}$ 航向角，角速度  $V_x, V_y$ 纵横向速度  $F_{yf},F_{yr}$ 前后轮y方向受力  $F_{cf},F_{cr}$ 前后轮侧向力  $l_f, l_r$ 前后轴长度  $I_z=m_f * l_{f}^2 + m_r * l_{r}^2$转动惯量在y轴上：\\(\\begin{aligned}    ma_y = F_{yf} + F_{y_r} \\qquad(1)\\end{aligned}\\)在z轴上：\\(\\begin{aligned}    I_z\\ddot{\\psi} = l_f * F_{yf} - l_r * F_{yr} \\qquad(2)\\end{aligned}\\)y轴方向加速由y轴方向位移相关的加速度$\\ddot{y}$和向心加速度$V_x\\dot{\\psi}$构成：\\(\\begin{aligned}    a_y = \\ddot{y} + V_x\\dot{\\psi} \\qquad(3)\\end{aligned}\\)即:\\(\\begin{aligned}    m(\\ddot{y} + V_x\\dot{\\psi}) =  F_{yf} + F_{y_r} \\qquad(4)\\end{aligned}\\)轮胎收到横向压力，会产生很小的滑移角则前后轮滑移角(默认前轮驱动，后轮不动即后轮偏移角为0):\\(\\begin{aligned}    \\alpha_f &amp;amp;= \\delta_f - \\theta_{vf} \\\\    \\alpha_r &amp;amp;= - \\theta_{vr}\\end{aligned}\\)即前后轮所受横向力为：\\(\\begin{aligned}    F_{yf} &amp;amp;= 2C_{\\alpha f}(\\delta_f - \\theta_{vf}) \\qquad(5)\\\\    F_{yr} &amp;amp;= 2C_{\\alpha r}(-\\theta_{vr}) \\qquad(6) \\\\\\end{aligned}\\)其中$\\theta_{vf},\\theta_{vr}可以通过y方向速度和切线速度计算$：\\(\\begin{aligned}    \\tan(\\theta_{vf}) = \\dfrac{V_y + l_f\\dot{\\psi}}{V_x} \\\\    \\tan(\\theta_{vr}) = \\dfrac{V_y - l_r\\dot{\\psi}}{V_x}\\end{aligned}\\)在小角度下，正切函数和正比例函数相似，因此可以近似为：\\(\\begin{aligned}    \\theta_{vf} = \\dfrac{V_y + l_f\\dot{\\psi}}{V_x} \\qquad(7) \\\\    \\theta_{vr} = \\dfrac{V_y - l_r\\dot{\\psi}}{V_x} \\qquad(8)\\end{aligned}\\)将(5),(6),(7),(8)带入(1)(2)中得到:整理得到动力学模型:代码实现&#39;&#39;&#39;动力学模型模拟&#39;&#39;&#39;import mathimport scipy.linalg as lafrom numpy import fromiterL = 4  # [m]Lr = L / 2.0  # [m]Lf = L - LrCf = 1600.0 * 2.0  # N/radCr = 1700.0 * 2.0  # N/radIz = 1500 * 8  # kg * m^2 =  m_front * l_f^2 + m_rear * l_r^2M = 1500.0 # kgclass DynamicsModel(object):    def __init__(self, x=0.0, y=0.0, yaw=0.0, vx=0.01, vy=0.0, omega=0.0):        self.x = x        self.y = y        self.yaw = yaw        self.vx = vx        self.vy = vy        self.omega = omega    def update_state(self, a, delta, dt=0.1):        self.x = self.x + self.vx * math.cos(self.yaw) * dt - self.vy * math.sin(self.yaw) * dt        self.y = self.y + self.vx * math.sin(self.yaw) * dt + self.vy * math.cos(self.yaw) * dt        self.yaw = self.yaw + self.omega * dt        Ffy = -Cf * math.atan2(((self.vy + Lf * self.omega) / self.vx - delta), 1.0)        Fry = -Cr * math.atan2((self.vy - Lr * self.omega) / self.vx, 1.0)                self.vx = self.vx + (a - Ffy * math.sin(delta) / M + self.vy * self.omega) * dt        self.vy = self.vy + (Fry / M + Ffy * math.cos(delta) / M - self.vx * self.omega) * dt        self.omega = self.omega + (Ffy * Lf * math.cos(delta) - Fry * Lr) / Iz * dt        return self    def get_state(self):        return self.x, self.y, self.yaw, self.v"
  },
  
  {
    "title": "曲率和航向的计算",
    "url": "/posts/curvature_heading/",
    "categories": "运动控制",
    "tags": "曲率, 航向",
    "date": "2022-01-07 00:00:00 +0800",
    





    "snippet": "曲率和航向  曲率航向曲线的曲率（curvature）就是针对曲线上某个点的切线方向角对弧长的转动率，通过微分来定义，表明曲线偏离直线的程度。数学上表明曲线在某一点的弯曲程度的数值。曲率越大，表示曲线的弯曲程度越大。曲率的倒数就是曲率半径。设曲线直角坐标方程$y = f(x)$且具有二阶导数，那么曲率公式为：\\(\\begin{aligned}    K = \\dfrac{|y^{&#39;&#39;}|}{(1+y^{&#39;2})^{\\dfrac{3}{2}} }\\end{aligned}\\)航向为：\\(\\begin{aligned}    Yaw = \\arctan(y&#39;)\\end{aligned}\\)如果曲线是由参数方程\\(\\begin{aligned}    x &amp;amp;= \\psi(t) \\\\    y &amp;amp;= \\omega(t)\\end{aligned}\\)那么曲率为:\\(\\begin{aligned}  K = \\dfrac{|\\psi&#39;(t)\\omega&#39;&#39;(t) - \\omega&#39;(t)\\psi&#39;&#39;(t)|}{[\\psi^{&#39;2}(t) + \\omega^{&#39;2}(t)]^{\\dfrac{3}{2}}}  \\end{aligned}\\)那么航向为:\\(\\begin{aligned}    Yaw = \\arctan(\\dfrac{\\omega&#39;(t)}{\\psi&#39;(t)})\\end{aligned}\\)附录求导公式：\\(\\begin{aligned}    \\dfrac{dy}{dx} &amp;amp;= \\dfrac{\\dfrac{dy}{dt}}{\\dfrac{dx}{dt}} = \\dfrac{\\omega&#39;(t)}{\\psi&#39;(t)} \\\\    \\dfrac{d^2y}{dx^2} &amp;amp;= \\dfrac{d}{dt}(\\dfrac{dy}{dx})(\\dfrac{1}{\\dfrac{dx}{dt}}) = (\\dfrac{dy}{dx})&#39;(\\dfrac{1}{\\dfrac{dx}{dt}}) \\\\    &amp;amp;=  (\\dfrac{\\omega&#39;(t)}{\\psi&#39;(t)})&#39;(\\dfrac{1}{\\psi&#39;(t)}) \\\\    &amp;amp;= \\dfrac{\\omega^{&#39;2}(t)\\psi^{&#39;}(t) - \\psi^{&#39;2}(t)\\omega^{&#39;}(t)}{\\psi^{&#39;3}(t)}\\end{aligned}\\)"
  },
  
  {
    "title": "三次样条插值",
    "url": "/posts/cubic_spline/",
    "categories": "运动控制",
    "tags": "样条插值",
    "date": "2022-01-04 00:00:00 +0800",
    





    "snippet": "三次样条(cubic spline)插值  样条插值 PythonRobotics已知某些点而不知道具体方程时候，通常有拟合和插值两种做法。拟合不要求方程通过所有的已知点，整体趋势一致。插值则是每个已知点都必会穿过，但是高阶会出现龙格现象，所以一般采用分段插值。而三次样条插值则是分段采用一元三次方程进行插值问题定义已知n+1个点$[(x_0, y_0), (x_1, y_1),…,(x_{n-1}, y_{n-1}), (x_n, y_n)]$，n个区间段为$[(x0, x1), (x1, x2),…,(x_{n-1}, x_n)]$三次样条就是说每个小区间的曲线是一个三次方程，三次样条方程满足以下条件:  在每个分段小区间$[x_i, x_{i+1}], S(x)=S_i(x) = a_i + b_ix + c_ix^2 + d_ix^3$  满足插值条件，即$S(x_i) = y_i\\qquad(i=0,1,…,n)$  曲线光滑，即$S(x), S’(x), S^{‘’}(x)$连续每个区间$S_i(x)$都有个四个未知数$(a_i, b_i, c_i, d_i)$,有n个小区间，则有4n个未知数，要解出这些未知数，则我们需要4n个方程来求解。求解  所有n-1个内部端点都满足$S_i(x_{i+1}) = y_{i+1}, S_{i+1}(x_{i+1})=y_{i+1}$,则有2(n-1)个方程，再加上首尾两个端点分别满足第一个方程和最后一个方程，则有2n个方程。  其次n-1个内部点的一阶导数应该是连续的，即在第i区间的末点和第i+1区间的起点是同一个点，它们的一阶导数应该也相等,即$S_{i}^{‘}(x_{i+1}) = S_{i+1}^{‘}(x_{i+1})$, 则有n-1个方程。      其次n-1个内部点的二阶导数应该是连续的，即在第i区间的末点和第i+1区间的起点是同一个点，它们的二阶导数应该也相等,即$S_{i}^{‘’}(x_{i+1})=S_{i+1}^{‘’}(x_{i+1})$则有n-1个方程。    边界条件指定最后两个方程          自然边界(Natural Spline)：指定端点二阶导数为0, $S_{0}^{‘’}(x_0) = 0 = S_{n}^{‘’}(x_{n})$      固定边界 ( Clamped Spline ): 指定端点一阶导数，这里分别定为A和B,$S_{0}^{‘}(x_0) = A,S_{n}^{‘}(x_{n}) = B$      非扭结边界( Not-A-Knot Spline ): 强制第一个插值点的三阶导数值等于第二个点的三阶导数值，最后第一个点的三阶导数值等于倒数第二个点的三阶导数值.即 $S_{0}^{‘’’}(x_0) = S_{1}^{‘’’}(x_1), S_{n-1}^{‘’’}(x_{n-1}) = S_{n}^{‘’’}(x_n)$      由以上3点和边界边界条件便可以得到4n个方程。具体推导构造$S_i(x), S’_i(x), S’‘_i(x)$\\(\\begin{aligned}    S_i(x) &amp;amp;= a_i + b_i(x-x_i) + c_i(x-x_i)^2 + d_i(x-x_i)^3 \\qquad(1)\\\\    S&#39;_i(x) &amp;amp;= b_i + 2c_i(x-x_i) + 3d_i(x-x_i)^2 \\\\    S&#39;&#39;_i(x) &amp;amp;= 2c_i + 6d_i(x-x_i) \\\\\\end{aligned}\\)  由$(1)$得\\(\\begin{aligned} S_i(x_i) &amp;amp;= a_i + b_i(x_i-x_i) + c_i(x_i-x_i)^2 + d_i(x_i-x_i)^3 = y_i \\\\ \\therefore a_i &amp;amp;= y_i \\\\\\end{aligned}\\)  用$h_i=x_{i+1} - x_i$表示步长\\(\\begin{aligned} S_i(x_{i+1}) &amp;amp;= a_i + b_i(x_{i+1}-x_i) + c_i(x_{i+1}-x_i)^2 + d_i(x_{i+1}-x_i)^3 = y_{i+1} \\\\ S_i(x_{i+1}) &amp;amp;= a_i + h_ib_i + h_i^2c_i + h_i^3d_i = y_{i+1} \\\\ \\therefore a_i + h_ib_i + h_i^2c_i + h_i^3d_i &amp;amp;= y_{i+1} \\\\\\end{aligned}\\)  由$S_{i}^{‘}(x_{i+1})=S_{i+1}^{‘}(x_{i+1})$得到：\\(\\begin{aligned} S&#39;_i(x_{i+1}) &amp;amp;= b_i + 2c_i(x_{i+1}-x_i) + 3d_i(x_{i+1}-x_i)^2  = b_i + 2h_ic_i +3h_i^2d_i\\\\ S&#39;_{i+1}(x_{i+1}) &amp;amp;= b_{i+1} + 2c_{i+1}(x_{i+1}-x_{i+1}) + 3d_{i+1}(x_{i+1}-x_{i+1})^2 \\\\ \\therefore b_i + 2h_ic_i +3h_i^2d_i &amp;amp;= b_{i+1} \\\\\\end{aligned}\\)  由$S_{i}^{‘’}(x_{i+1})=S_{i+1}^{‘’}(x_{i+1})$得到：\\(\\begin{aligned} S&#39;&#39;_i(x_{i+1}) &amp;amp;= 2c_i + 6d_i(x_{i+1}-x_i) \\\\ S&#39;&#39;_{i+1}(x_{i+1}) &amp;amp;= 2c_{i+1} + 6d_{i+1}(x_{i+1}-x_{i+1}) \\\\ \\therefore 2c_i + 6h_id_i &amp;amp;= 2c_{i+1} \\\\\\end{aligned}\\)  设$m_i = S’‘_i(x_i) = 2*c_i$得到：\\(\\begin{aligned} 2c_i + 6h_id_i &amp;amp;= 2c_{i+1} \\\\ 2m_i + 6h_id_i &amp;amp;= m_{i+1} \\\\ \\therefore d_i &amp;amp;= \\dfrac{m_{i+1} - m_i}{6h_i}\\\\ c_i &amp;amp;= \\dfrac{1}{2}m_i \\\\\\end{aligned}\\)  将$a_i,c_i,d_i$代入$a_i + h_ib_i + h_i^2c_i + h_i^3d_i = y_{i+1}$可得：\\(\\begin{aligned} y_i + h_ib_i + h^2_i*(\\dfrac{1}{2}m_i) + h^3_i*(\\dfrac{m_{i+1} - m_i}{6h_i}) &amp;amp;= y_{i+1} \\\\ \\therefore b_i &amp;amp;= \\dfrac{y_{i+1} - y_i}{h_i} - \\dfrac{h_i}{2}m_i - \\dfrac{h_i}{6}(m_{i+1} - m_i)  \\\\\\end{aligned}\\)  将$a_i,b_i,c_i,d_i$代入$b_i + 2h_ic_i +3h_i^2d_i = b_{i+1}$可得:\\(\\begin{aligned} \\dfrac{y_{i+1} - y_i}{h_i} - \\dfrac{h_i}{2}m_i - \\dfrac{h_i}{6}(m_{i+1} - m_i) + 2h_i(\\dfrac{1}{2}m_i) + 3h_i^2(\\dfrac{m_{i+1} - m_i}{6h_i}) &amp;amp;= \\dfrac{y_{i+2} - y_{i+1}}{h_{i+1}} - \\dfrac{h_{i+1}}{2}m_{i+1} - \\dfrac{h_{i+1}}{6}(m_{i+2} - m_{i+1}) \\\\ h_im_i + 2(h_i + h_{i+1})m_{i+1} + h_{i+1}m_{i+2} &amp;amp;= 6(\\dfrac{y_{i+2} - y_{i+1}}{h_{i+1}} - \\dfrac{y_{i+1} - y_i}{h_i}) \\\\ \\end{aligned} \\\\\\)          其中左边跟$m_i$相关，而右边都是已知的，因此可以构造一个以m为未知数的线性方程组            在自然边界条件时, $m_0 = 0, m_n = 0$:    因此可以高斯消元,Givens Rotation等方式求得$m$从而得到$a_i,b_i,c_i,d_i$        在夹持边界条件下：        在非扭结边界条件下：  在自然条件下，除了构造矩阵显性的求解$Ax=b$，还可以通过数值分析[numerical_analysis_9th.pdf page149]的方法求解:代码实现import mathimport numpy as npimport bisectclass Spline:    &quot;&quot;&quot;    Cubic Spline class    &quot;&quot;&quot;    def __init__(self, x, y):        self.b, self.c, self.d, self.w = [], [], [], []        self.x = x        self.y = y        self.nx = len(x)  # dimension of x        h = np.diff(x) # x(i+1) - x(i)        # calc coefficient c        self.a = [iy for iy in y]        # Ax = B        A = self.__calc_A(h)         B = self.__calc_B(h)        # 解Ax = B，得到的m = 2×c，再构建B的时候除了2,所以此处m = c        self.c = np.linalg.solve(A, B)        #  print(self.c1)        # calc spline coefficient b and d        for i in range(self.nx - 1):            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0            self.b.append(tb)    def calc(self, t):        &quot;&quot;&quot;        Calc position        if t is outside of the input x, return None        &quot;&quot;&quot;        if t &amp;lt; self.x[0]:            return None        elif t &amp;gt; self.x[-1]:            return None        i = self.__search_index(t)        dx = t - self.x[i]        result = self.a[i] + self.b[i] * dx + \\            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0        return result    def calcd(self, t):        &quot;&quot;&quot;        Calc first derivative        if t is outside of the input x, return None        &quot;&quot;&quot;        if t &amp;lt; self.x[0]:            return None        elif t &amp;gt; self.x[-1]:            return None        i = self.__search_index(t)        dx = t - self.x[i]        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0        return result    def calcdd(self, t):        &quot;&quot;&quot;        Calc second derivative        &quot;&quot;&quot;        if t &amp;lt; self.x[0]:            return None        elif t &amp;gt; self.x[-1]:            return None        i = self.__search_index(t)        dx = t - self.x[i]        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx        return result    def __search_index(self, x):        &quot;&quot;&quot;        search data segment index        &quot;&quot;&quot;        return bisect.bisect(self.x, x) - 1    def __calc_A(self, h):        &quot;&quot;&quot;        calc matrix A for spline coefficient c        &quot;&quot;&quot;        A = np.zeros((self.nx, self.nx))        A[0, 0] = 1.0        for i in range(self.nx - 1):            if i != (self.nx - 2):                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])            A[i + 1, i] = h[i]            A[i, i + 1] = h[i]        A[0, 1] = 0.0        A[self.nx - 1, self.nx - 2] = 0.0        A[self.nx - 1, self.nx - 1] = 1.0        #  print(A)        return A    def __calc_B(self, h):        &quot;&quot;&quot;        calc matrix B for spline coefficient c        &quot;&quot;&quot;        B = np.zeros(self.nx)        for i in range(self.nx - 2):            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]        return Bclass NumericalAnalysisSpline(Spline):    def __init__(self, x, y):        self.nx = len(x)        self.a, self.b = np.zeros(self.nx), np.zeros(self.nx)        self.c, self.d = np.zeros(self.nx), np.zeros(self.nx)                self.x = np.copy(x)        self.a = np.copy(y)                self.__cal()    def __cal(self):        l = np.zeros(self.nx)        u = np.zeros(self.nx)        z = np.zeros(self.nx)        A = np.zeros(self.nx)        h = np.diff(self.x)        n = self.nx - 1        for i in range(1, n):            A[i] = 3 * (self.a[i + 1] - self.a[i]) / h[i] - 3 * (self.a[i] - self.a[i - 1]) / h[i - 1];        l[0] = 1            for i in range(1, n):            l[i] = 2 * (self.x[i + 1] - self.x[i - 1]) - h[i - 1] * u[i - 1]            u[i] = h[i] / l[i];            z[i] = (A[i] - h[i - 1] * z[i - 1]) / l[i]        l[n] = 1        for j in range(n-1, -1, -1):            self.c[j] = z[j] - u[j] * self.c[j + 1]            self.b[j] = (self.a[j + 1] - self.a[j]) / h[j] - h[j] * (self.c[j + 1] + 2 * self.c[j]) / 3            self.d[j] = (self.c[j + 1] - self.c[j]) / (3 * h[j])其中2d样条插值(参数方程)的实现如下，有关航向和曲率的解释见对应的文章class Spline2D:    &quot;&quot;&quot;    2D Cubic Spline class    &quot;&quot;&quot;    def __init__(self, x, y):        self.s = self.__calc_s(x, y)        self.sx = Spline(self.s, x)        self.sy = Spline(self.s, y)    def __calc_s(self, x, y):        dx = np.diff(x)        dy = np.diff(y)        # print(&quot;dx:&quot;, dx)        # print(&quot;dy:&quot;, dy)        self.ds = np.hypot(dx, dy)        # print(&quot;ds:&quot;, self.ds)        s = [0]        s.extend(np.cumsum(self.ds))        return s    def calc_position(self, s):        &quot;&quot;&quot;        calc position        &quot;&quot;&quot;        x = self.sx.calc(s)        y = self.sy.calc(s)        return x, y    def calc_curvature(self, s):        &quot;&quot;&quot;        calc curvature        &quot;&quot;&quot;        dx = self.sx.calcd(s)        ddx = self.sx.calcdd(s)        dy = self.sy.calcd(s)        ddy = self.sy.calcdd(s)        k = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))        return k    def calc_yaw(self, s):        &quot;&quot;&quot;        calc yaw        &quot;&quot;&quot;        dx = self.sx.calcd(s)        dy = self.sy.calcd(s)        yaw = math.atan2(dy, dx)        return yawdef calc_spline_course(x, y, ds=0.1):    sp = Spline2D(x, y)    s = list(np.arange(0, sp.s[-1], ds))    rx, ry, ryaw, rk = [], [], [], []    for i_s in s:        ix, iy = sp.calc_position(i_s)        rx.append(ix)        ry.append(iy)        ryaw.append(sp.calc_yaw(i_s))        rk.append(sp.calc_curvature(i_s))    return rx, ry, ryaw, rk, s"
  },
  
  {
    "title": "LQR调节器",
    "url": "/posts/LQR/",
    "categories": "运动控制",
    "tags": "LQR, 反馈控制",
    "date": "2022-01-03 00:00:00 +0800",
    





    "snippet": "LQR调节器  LQR百度百科 LQR  LQR (linear quadratic regulator)即线性二次型调节器，其对象是现代控制理论中以状态空间形式给出的线性系统，而目标函数为对象状态和控制输入的二次型函数。LQR最优设计是指设计出的状态反馈控制器 K要使二次型目标函数J 取最小值，而 K由权矩阵Q 与 R 唯一决定，故此 Q、 R 的选择尤为重要。LQR理论是现代控制理论中发展最早也最为成熟的一种状态空间设计法。特别可贵的是，LQR可得到状态线性反馈的最优控制规律，易于构成闭环最优控制。推导假设有一个线性系统能用状态向量的形式表示:\\(\\begin{aligned}    \\dot{x} = Ax + Bu \\qquad(1)\\end{aligned}\\)其中$x(t)\\in R^n, u(t)\\in R^m$,其中x为状态变量可观测，u为控制矩阵。全状态反馈控制全状态反馈控制系统如下所示：状态反馈控制器为：\\(\\begin{aligned}    u = -Kx\\end{aligned}\\)使得闭环系统能够满足我们期望的性能。我们把这种控制代入$(1)$得到:\\(\\begin{aligned}    \\dot{x} = (A - BK)x = A_cx\\qquad(2)\\end{aligned}\\)对于$(1)$式的开环系统，由现代控制理论我们知道开环传递函数的极点就是系统矩阵A的特征值。现在变成了$(2)$的闭环形式，状态变换矩阵$A$变成了$(A-BK)$。因此通过配置反馈矩阵$K$，可以使得闭环系统的极点达到我们期望的状态.LQR的目标(损失，能量)函数一般设计如下：\\(\\begin{aligned}    J = \\dfrac{1}{2}\\int^{\\infty}_0(x^TQx + u^TRu)dt \\qquad(3)\\end{aligned}\\)其中$Q,R$通常取为对角阵，$Q$为半正定的状态加权矩阵, $R$为正定的控制加权矩阵.为什么能量函数(或称系统的目标函数)得设计成这个样子呢？    首先假设状态向量x(t)是1维的，那么其实就是一个平方项 Qx^2 &amp;gt;= 0，同理. 能量函数J要最小，那么状态向量x(t)，u(t)都得小。    J最小，那肯定是个有界的函数，我们能推断当t趋于无穷时，状态向量x(t)将趋于0，这也保证了闭环系统的稳定性。    那输入u(t)要小是什么意思呢？它意味着我们用最小的控制代价得到最优的控制。譬如控制电机，输入PWM小，将节省能量。矩阵Q,R的选取?    𝑄矩阵元素变大意味着希望跟踪偏差能够快速趋近于零      𝑅矩阵元素变大意味着希望控制输入能够尽可能小    一般来说，Q值选得大意味着，要使得J小，那x(t)需要更小，也就是意味着闭环系统的矩阵(A-BK)的特征值处于S平面左边更远的地方，这样状态x(t)就以更快的速度衰减到0。    另一方面，大的R表示更加关注输入变量u(t),u(t)的减小，意味着状态衰减将变慢。    同时，Q为半正定矩阵意味着他的特征值非负，R为正定矩阵意味着它的特征值为正数。如果你选择Q,R都是对角矩阵的话，那么Q的对角元素为正数，允许出现几个0.R的对角元素只能是正数。将$u = -Kx$代入$(3)$得到：\\(\\begin{aligned}    J = \\dfrac{1}{2}\\int^{\\infty}_0 x^T(Q + K^TRK)x\\quad dt \\qquad(4)\\end{aligned}\\)为了找到K,我们先不防假设存在一个常量矩阵P使得：\\(\\begin{aligned}    \\dfrac{d}{dt}(x^TPx) = -x^T(Q + K^TRK) \\qquad(5)\\end{aligned}\\)带入$(4)$得: \\(\\begin{aligned}    J = \\dfrac{1}{2}\\int^{\\infty}_0 \\dfrac{d}{dt}(x^TPx)dt = \\dfrac{1}{2}x^T(0)Px(0) \\qquad(6)\\end{aligned}\\)注意，我们已经假设闭环系统是稳定的，也就是t趋于无穷时，x(t)趋于0.现在把(5)式左边的微分展开，并把状态变量x的微分用(2)式替代得到：\\(\\begin{aligned}    \\dot{x}^TPx + x^TP\\dot{x} + x^TQx + x^TK^TRKx = 0 \\\\    x^TA^T_cPx + x^TPA_cx + x^TQx + x^TK^TRKx = 0 \\\\    x^T(A^T_cP + PA_c + Q + K^TRK)x = 0\\end{aligned}\\)这个式子要始终成立的话，括号里的项必须恒等于0.\\(\\begin{aligned}    (A-BK)^TP + P(A-BK) + Q + K^TRK = 0 \\\\    A^TP - K^TB^TP + PA - PBK + Q + K^TRK = 0\\end{aligned}\\)取$K=R^{-1}B^TP$带入得：\\(\\begin{aligned}    A^TP + PA + Q + (R^{-1}B^TP)^TR(R^{-1}B^TP) - (R^{-1}B^TP)^TB^TP - PB(R^{-1}B^TP) &amp;amp;= 0 \\\\    A^TP + PA + Q - PBR^{-1}B^TP &amp;amp;= 0 \\qquad(7)\\end{aligned}\\)K的二次项没有了，可K的取值和P有关，而P是我们假设的一个量，P只要使得的(7)式成立就行了。而(6)式在现代控制理论中极其重要，它就是有名的Riccati方程。一般采用迭代方式解此方程，如下图所示：总结      选择参数矩阵Q,R        求解Riccati 方程得到矩阵P        计算$K=R^{-1}B^TP$        计算$u = -Kx$的到控制量  代码实现输入A B Q R矩阵计算Kimport scipy.linalg as laimport numpy as npdef solve_DARE(A, B, Q, R):    &quot;&quot;&quot;    solve a discrete time_Algebraic Riccati equation (DARE)    &quot;&quot;&quot;    X = Q    maxiter = 150    eps = 0.01    for i in range(maxiter):        Xn = A.T @ X @ A - A.T @ X @ B @ \\            la.inv(R + B.T @ X @ B) @ B.T @ X @ A + Q        if (abs(Xn - X)).max() &amp;lt; eps:            break        X = Xn    return Xndef dlqr(A, B, Q, R):    &quot;&quot;&quot;Solve the discrete time lqr controller.    x[k+1] = A x[k] + B u[k]    cost = sum x[k].T*Q*x[k] + u[k].T*R*u[k]    # ref Bertsekas, p.151    &quot;&quot;&quot;    # first, try to solve the ricatti equation    X = solve_DARE(A, B, Q, R)    # compute the LQR gain    K = la.inv(B.T @ X @ B + R) @ (B.T @ X @ A)    eigVals, eigVecs = la.eig(A - B @ K)    return K, X, eigVals"
  },
  
  {
    "title": "自行车运动学模型",
    "url": "/posts/kinematics_module/",
    "categories": "运动控制",
    "tags": "模型, 运动学",
    "date": "2021-12-20 00:00:00 +0800",
    





    "snippet": "运动学模型自行车模型  自行车模型 车辆运动学模型  自行车模型基于如下几个假设：  车辆在垂直方向的运动被忽略掉了，也就是说我们描述的车辆是一个二维平面上的运动物体（可以等价与我们是站在天空中的俯视视角）  假设车辆的结构就像自行车一样，也就是说车辆的前面两个轮胎拥有一直的角度和转速等，同样后面的两个轮胎也是如此，那么前后的轮胎就可以各用一个轮胎来描述  我们假设车辆运动也和自行车一样，这意味着是前面的轮胎控制这车辆的转角自行车运动学模型作为一种自行车模型，运动学自行车模型也假定车辆形如一辆自行车，整个的控制量可以简化为$\\alpha, \\delta_f, \\delta_r$.其中$\\alpha$是车辆的加速度，踩油门踏板意味着正的加速度，踩刹车踏板意味着负的加速度。$\\delta_f$是前轮转角，$\\delta_r$是后轮转角。这样我们使用三个量描述了车辆的控制输入(control input)，其中状态量我们用$\\psi, V, x, y$来表示。各变量说明如下：  $\\delta_f$ 前轮转角  $\\delta_r$ 后轮转角  $\\psi$ 航向角  $V$速度方向  $\\beta$ 速度方向与车辆方向夹角(滑移角)  $l_r, l_f$ 质点到前后轴的距离  $\\omega$ 角速度  $R$ 转弯半径  $x, y$模型的位置由三角函数可得：\\(\\begin{aligned}    \\dfrac{\\sin(\\delta_f - \\beta)}{l_f} &amp;amp;=  \\dfrac{\\sin( \\dfrac{\\pi}{2} - \\delta_f)}{R} \\\\    \\dfrac{\\sin(\\beta - \\delta_r)}{l_r} &amp;amp;= \\dfrac{\\sin(\\dfrac{\\pi}{2} + \\delta_r)}{R} \\\\\\end{aligned}\\)展开：\\(\\begin{aligned}    \\dfrac{\\sin\\delta_f\\cos\\beta - \\cos\\delta_f\\sin\\beta}{l_f} &amp;amp;=  \\dfrac{\\cos\\delta_f}{R} \\qquad(1)\\\\    \\dfrac{\\sin\\beta\\cos\\delta_r - \\cos\\beta\\sin\\delta_r}{l_r} &amp;amp;= \\dfrac{\\cos\\delta_r}{R} \\qquad(2)\\\\\\end{aligned}\\)可以求得$R, \\beta$：  $(1)$式同除$\\delta_f$同乘$l_f$加上$(2)$式同除$\\delta_r$同乘$l_r$得:\\(\\begin{aligned} \\dfrac{l_f + l_r}{R} &amp;amp;= \\cos\\beta(\\tan\\delta_f - \\tan\\delta_r) \\\\ R &amp;amp;= \\dfrac{l_f + l_r}{\\cos\\beta(\\tan\\delta_f - \\tan\\delta_r)} \\qquad(3) \\\\\\end{aligned}\\)  $(1)$式除以$(2)$式：\\(\\begin{aligned} \\dfrac{\\sin\\delta_f\\cos\\beta - \\cos\\delta_f\\sin\\beta}{\\sin\\beta\\cos\\delta_r - \\cos\\beta\\sin\\delta_r} &amp;amp;=  \\dfrac{\\cos\\delta_f * l_f}{\\cos\\delta_r * l_r} \\\\\\end{aligned}\\)  等式同时除以$\\cos\\delta_f$，乘以$\\cos\\delta_r$得:\\(\\begin{aligned} \\dfrac{\\tan\\delta_f\\cos\\beta - \\sin\\beta}{\\sin\\beta - \\cos\\beta\\tan\\delta_r} &amp;amp;=  \\dfrac{l_f}{l_r} \\\\\\end{aligned}\\)  等式左边同时除以$\\cos\\beta$得:\\(\\begin{aligned} \\dfrac{\\tan\\delta_f - \\tan\\beta}{\\tan\\beta - \\tan\\delta_r} &amp;amp;=  \\dfrac{l_f}{l_r} \\\\\\end{aligned}\\)  合并整理得:\\(\\begin{aligned} \\tan\\beta &amp;amp;=  \\dfrac{l_r * \\tan\\delta_f + l_f * \\tan\\delta_r}{l_f + l_r} \\\\ \\beta &amp;amp;= \\arctan(\\dfrac{l_r * \\tan\\delta_f + l_f * \\tan\\delta_r}{l_f + l_r}) \\qquad(4) \\\\\\end{aligned}\\)低速环境下，车辆行驶路径的转弯半径变化缓慢，此时我们可以假设车辆的方向变化率等于车辆的角速度。则车辆的角速度$\\omega$为\\(\\begin{aligned}    \\omega &amp;amp;= \\dfrac{V}{R} \\\\\\end{aligned}\\)代入$(3)$得:\\(\\begin{aligned}    \\omega &amp;amp;= \\dfrac{V * \\cos\\beta * (\\tan\\delta_f - \\tan\\delta_r)}{l_f + l_r} \\qquad(5)\\\\\\end{aligned}\\)所以模型的状态量$x, y, \\psi, V$的更新如下:\\(\\begin{aligned}    x_{t+1} &amp;amp;= x_t + V_t*\\cos(\\psi_t + \\beta) * \\Delta{t} \\\\    y_{t+1} &amp;amp;= y_t + V_t*\\sin(\\psi_t + \\beta) * \\Delta{t} \\\\    V_{t+1} &amp;amp;= V_t + \\alpha * \\Delta{t} \\\\    \\psi_{t+1} &amp;amp;= \\psi_t + \\omega * \\Delta{t} \\\\\\end{aligned}\\)当仅前轮驱动时，$\\delta_r$可认为是0则$\\psi, V, x, y$，更新公式如下：\\(\\begin{aligned}    x_{t+1} &amp;amp;= x_t + V*\\cos(\\psi_t + \\beta) * \\Delta{t} \\\\    y_{t+1} &amp;amp;= y_t + V*\\sin(\\psi_t + \\beta) * \\Delta{t} \\\\    V_{t+1} &amp;amp;= V_t + \\alpha * \\Delta{t} \\\\    \\psi_{t+1} &amp;amp;= \\psi_t + \\frac{V_t}{l_f + l_r} * \\cos(\\beta) * \\tan(\\delta_f) * \\Delta{t} \\\\    \\beta &amp;amp;= \\arctan(\\frac{l_r}{l_r+l_f} * \\tan(\\delta_f))\\end{aligned}\\)代码实现class KinematicModel(object):    def __init__(self, x, y, psi, v, f_len, r_len):        self.x = x        self.y = y        self.psi = psi        self.v = v`           self.f_len = f_len        self.r_len = r_len    def get_state(self):        return self.x, self.y, self.psi, self.v    def update_state(self, a, delta, dt):        beta = math.atan((self.r_len / (self.r_len + self.f_len)) * math.tan(delta))        self.x = self.x + self.v * math.cos(self.psi + beta) * dt        self.y = self.y + self.v * math.sin(self.psi + beta) * dt        self.psi = self.psi + (self.v / (self.f_len + self.r_len)) * math.cos(beta) * math.tan(delta) * dt        self.v = self.v + a * dt        return self.x, self.y, self.psi, self.v"
  },
  
  {
    "title": "纯预瞄跟踪算法",
    "url": "/posts/pure_pursuit/",
    "categories": "运动控制",
    "tags": "预瞄",
    "date": "2021-12-18 00:00:00 +0800",
    





    "snippet": "PurePursuit 纯预瞄算法阿克曼转向  阿克曼转向  阿克曼转向是一种现代汽车的转向方式，在汽车转弯的时候，内外轮转过的角度不一样，内侧轮胎转弯半径小于外侧轮胎。根据阿克曼转向几何设计的车辆，沿着弯道转弯时，利用四连杆的相等曲柄使内侧轮的转向角比外侧轮大大约2~4度，使四个轮子路径的圆心大致上交会于后轴的延长线上瞬时转向中心，让车辆可以顺畅的转弯.下图就是理想的阿克曼转向。$\\alpha$汽车内轮转角$\\beta$汽车外轮转角K两主销中心距离L轴距R转弯半径转动形式:  仅前轮转向，后轮角度不变。  前后轮均可转向。  (1) 前后轮角度相反，(2) 前后轮角度相同，这种模式可以实现全向运动。转向特性的特点：  汽车直线行驶时，4个车轮的轴线都互相平行，而且垂直于汽车纵向中心面。  汽车在转向行驶过程中，全部车轮都必须绕一个瞬时中心点做圆周滚动。核心公式      $\\cot\\beta - \\cot\\alpha = \\cfrac{K}{L}$        $\\tan\\beta = \\cfrac{L}{R}$  PurePursuit  纯预瞄算法  上图所⽰为简化的车辆运动学⾃⾏车模型，其后轮中心在蓝⾊虚线表⽰的⽬标轨迹上。本算法通过控制前轮转⻆来追踪下⼀个路点，使车辆可以沿着经过⽬标预瞄点的圆弧⾏驶。物理量描述如下:$R(m)$ 转弯半径$L(m)$ 轴距$\\delta$ 前轮转角$l_d$ 预瞄距离$x_r$预瞄点横坐标$y_r$预瞄点纵坐标$e$横向偏差$\\alpha$车身与预瞄点夹角本质就是已知轴距，预瞄距离，横向偏差求前轮转角:由正弦定理可以知道  $\\cfrac{l_d}{\\sin2\\alpha} = \\cfrac{R}{\\sin{\\cfrac{\\pi - 2\\alpha}{2}}}$  $\\cfrac{l_d}{2 * \\sin\\alpha * \\cos\\alpha} = \\cfrac{R}{\\cos\\alpha}$  $R = \\cfrac{l_d}{2 * \\sin\\alpha}$其中  $\\sin\\alpha = \\cfrac{e}{l_d}$那么就有  $R = \\cfrac{l_d^2}{2e}$所以  $\\delta = \\arctan\\cfrac{L}{R} = \\arctan\\cfrac{2Le}{l_d^2}$由上式可知控制器的本质就是对转角进行控制，以减少横向误差为目标的横向控制器。其中$\\cfrac{2L}{l_d^2}$可视为控制器的P参数.L为车辆轴距,$l_d$为设定的预瞄距离.本控制器的控制效果主要取决于预瞄距离的选取,⼀般来说预瞄距离越⻓,控制效果会越平滑,预瞄距离越短，控制效果会越精确（同时也会带来⼀定的震荡）.预瞄距离的选取也和当前车速有关,如以下两种:  $l_d = gv + l_f$其中v为当前车速，g为⼀可调节的参数,$l_f$为预设前视距离  $l_d = Av^2 + Bv + C$其中$A=1/(2a_{max})$, $a_{max}$为最⼤制动加速度.$Av^2$表⽰最短车辆制动距离.B表⽰车辆遇到异常时需要的反应时间, $Bv$则为对应的反应距离, $C$表⽰车辆的最⼩转弯半径.在实际使用的时候，通常不需要规划点切实等于预瞄点，而是在预瞄点附近找一个最接近的规划点，同时还可以用PID调整e值。代码实现预瞄输入自车经纬高以及目标点经纬高，计算车轮转角// 计算预瞄距离double PurePursuit::cal_ld(double vel){    return 1.0 / ( 2 * _max_braking_acc) * vel * vel + _reactime * vel + _min_turning_radius;}// http://www.movable-type.co.uk/scripts/latlong.html// 计算gps两点距离double PurePursuit::cal_gps_distance(double lng1, double lat1, double lng2, double lat2){    double radius_of_earth = 6378137.0;    lng1 = lng1 / 180 * M_PI;    lat1 = lat1 / 180 * M_PI;    lng2 = lng2 / 180 * M_PI;    lat2 = lat2 / 180 * M_PI;    double delt_lat = lat2 - lat1;    double delt_lng = lng2 - lng1;    double a = pow(sin(0.5 * delt_lat), 2) + pow(sin(0.5 * delt_lng), 2) * cos(lat1) * cos(lat2);    double c = 2.0 * atan2(sqrt(a), sqrt(1.0 - a));    return radius_of_earth * c;}// 计算gps两点方位角double PurePursuit::cal_gps_bearing(double lng1, double lat1, double lng2, double lat2){    lng1 = lng1 / 180 * M_PI;    lat1 = lat1 / 180 * M_PI;    lng2 = lng2 / 180 * M_PI;    lat2 = lat2 / 180 * M_PI;    double delt_lat = lat2 - lat1;    double delt_lng = lng2 - lng1;    double y = sin(delt_lng) * cos(lat2);    double x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(delt_lng);    return atan2(y, x); }// 计算横向偏差，yaw为车辆的航向角，正北方向的偏航double PurePursuit::cal_lateral(double lng1, double lat1, double lng2, double lat2, double yaw){    double distance = cal_gps_distance(lng1, lat1, lng2, lat2);    double heading = cal_gps_bearing(lng1, lat1, lng2, lat2);    if (heading &amp;lt; 0) heading += 2 * M_PI;    heading -= yaw;    double x = sin(heading) * distance;    double y = cos(heading) * distance;    return y; }// 计算车辆转角，vel自身车速double PurePursuit::cal_wheel_angle(double lng1, double lat1, double lng2, double lat2, double vel, double yaw){    double ld = cal_ld(vel);    double lateral = cal_lateral(lng1, lat1, lng2, lat2, 0);    return atan(2 * _wheel_base * lateral / ld / ld);}实现2：转换utm坐标系且使用目标点航向计算详细可操作代码见脚本pure_pursuit_lateral_controller.py    from pyproj import Proj    proj_text = &quot;+proj=utm +zone=50 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs&quot;    trsfm = Proj(proj_text)    path_point = read_global_path(log_path)    # 全局路径转utm    x, y = [], []    for point in path_point:        utm_x, utm_y = trsfm(point[0], point[1])        x.append(utm_x)        y.append(utm_y)    x = np.array(x)    y = np.array(y)    # 计算预瞄距离    ld = max(km.v * g_rate, 2)    dx = km.x - x[target_pts_idx]    dy = km.y - y[target_pts_idx]    euler_dist = math.sqrt(dx**2 + dy**2)    if euler_dist &amp;lt; ld:        target_pts_idx += 1        continue    print(target_pts_idx, ld, euler_dist, dx, dy, km.x, km.y)    cos_target_heading = cos(path_point[target_pts_idx][-1] * DEG_TO_RAD)    sin_target_heading = sin(path_point[target_pts_idx][-1] * DEG_TO_RAD)    # 计算横纵向偏差    # lateral_error = cos_target_heading * dy - sin_target_heading * dx    # print(&quot;lateral_error&quot;, lateral_error)    lateral_error = cos_target_heading * dx - sin_target_heading * dy     longtidual_error = sin_target_heading * dx + cos_target_heading * dy        print(&quot;lateral_error&quot;, lateral_error)    # print(&quot;longtidual_error&quot;, longtidual_error)    # print(&quot;euler_dist:&quot;, math.sqrt(dx**2 + dy**2))    # 计算前轮转角    alpha = atan(2 * 2.9 * lateral_error / euler_dist**2) + kp * lateral_error + ki * (lateral_error - last_error) + kd * (lateral_error - 2*(last_error) + last_last_error)    alpha = min(alpha, 30 * DEG_TO_RAD)    alpha = max(alpha, -30 * DEG_TO_RAD)"
  },
  
  {
    "title": "Can解析",
    "url": "/posts/can/",
    "categories": "CAN",
    "tags": "CAN",
    "date": "2021-12-18 00:00:00 +0800",
    





    "snippet": "can解析描述can解析流程数据我们一般拿到的can数据一般都是这种样子的            CAN ID      CAN DATA                  0x60b      0x11 0x22 0x33 0x44 0x55 0x66 0x77 0x88      这便是一条完整的can帧, 由id和data组成.其在linux中结构定义如下:#include &amp;lt;linux/can.h&amp;gt;/* CAN payload length and DLC definitions according to ISO 11898-1 */#define CAN_MAX_DLC 8#define CAN_MAX_DLEN 8/* special address description flags for the CAN_ID */#define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */#define CAN_RTR_FLAG 0x40000000U /* remote transmission request */#define CAN_ERR_FLAG 0x20000000U /* error message frame */struct can_frame {    canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */    __u8    can_dlc; /* frame payload length in byte (0 .. CAN_MAX_DLEN) */    __u8    __pad;   /* padding */    __u8    __res0;  /* reserved / padding */    __u8    __res1;  /* reserved / padding */    __u8    data[CAN_MAX_DLEN] __attribute__((aligned(8)));};can帧的主要几类:      数据帧-标准帧: 长度11位,最大值为0x7ff.        数据帧-扩展帧: 长度29位, 可通过canid &amp;amp; CAN_EFF_FLAG == 1 判断.    错误帧: 通过 CAN_ERR_FLAG 判断  远程帧: 通过 CAN_RTR_FLAG 判断其中我们看到最多的是数据帧, 其他帧基本没有看到过.dbc有了数据之后,如何解码出我们所需要的信息呢? 通常情况都是通过dbc来编码或者解码的.DBC是Database Can的缩写，其代表的是CAN的数据库文件，在这个文件中把CAN通讯的信息定义完整.BO_ 1547 Obj_1_General: 8 ARS_ISF SG_ Obj_DynProp : 50|3@0+ (1,0) [0|7] &quot;&quot;  ExternalUnit SG_ Obj_RCS : 63|8@0+ (0.5,-64) [-64|63.5] &quot;dBm²&quot;  ExternalUnit SG_ Obj_VrelLat : 45|9@0+ (0.25,-64) [-64|63.75] &quot;m/s&quot;  ExternalUnit SG_ Obj_ID : 7|8@0+ (1,0) [0|255] &quot;&quot;  ExternalUnit SG_ Obj_DistLong : 15|13@0+ (0.2,-500) [-500|1138.2] &quot;m&quot;  ExternalUnit SG_ Obj_VrelLong : 39|10@0+ (0.25,-128) [-128|127.75] &quot;m/s&quot;  ExternalUnit SG_ Obj_DistLat : 18|11@0+ (-0.2,204.6) [-204.8|204.6] &quot;m&quot;  ExternalUnit上面展示了一段ars的dbc中对canid为1547的can帧描述.其中主要有BO_ 报文, SG_ 信号.一个报文下会有多个信号. 一个报文就是一个can帧,其数据域长度为8字节64位(见前面定义).对于信号,每一行都相信的描述了该信号在数据域中的位置,解码方式等.BO_ (报文)基本格式如下:BO_ MessageId MessageName: MessageSize Transmitter  BO_为关键字，表示报文；  MessageId为定义的报文ID，是以10进制数表示；  MessageName表示该报文的名字  MessageSize表示该报文数据域字节数，为无符号整型数据；  Transmitter表示发送该报文的网络节点；如果该报文没有指定发送节点，则该值需设置为” Vector__XXX”或者不写以1547报文举例说明:BO_ 1547 Obj_1_General: 8 ARS_ISF            定义      描述                  BO_      报文关键字              1547      can id 16进制为0x60b              Obj_1_General      报文名字              8      报文数据域字节数              ARS_ISF      发送该报文的节点      SG_ (信号)基本格式如下:SG_ SignalName : StartBit|SignalSize@ByteOrder ValueType (Factor,Offset) [Min|Max] Unit Receiver  SG_为关键字，表示信号；  SignalName、 StartBit、 SignalSize分别表示该信号的名字、起始位、信号长度；  ByteOrder表示信号的字节顺序：0代表Motorola格式(大端序)，1代表Intel格式(小端序)；  ValueType 表示该信号的数值类型：+表示无符号数，-表示有符号数；  Factor表示因子，Offset表示偏移量；这两个值于该信号的原始值与物理值之间的转换。转换如下：物理值=原始值*因子+偏移量；                              Min          Max表示该信号的最小值和最大值，即指定了该信号值的范围；这两个值为double类型；                      Unit表示该信号的单位，为字符串类型；  Receiver表示该信号的接收节点；若该信号没有指定的接收节点，则必须设置为” Vector__XXX”举例如下:SG_ Obj_DistLat : 18|11@0+ (-0.2,204.6) [-204.8|204.6] “m”  ExternalUnit            定义      描述                  SG_      信号关键字              Obj_DistLat      信号名              18      起始位              11      长度              0      motorola格式(大端序)              +      无符号数              -0.2      缩放因子              204.6      偏移量              -204.8      最小值              204.6      最大值              m      单位              ExternalUnit      接收节点      解析通过dbc或者协议文档获取了报文和信号的编解码信息,然后就可以解析出明文.这里还是以conti的ars 408雷达举例.大端序列cve采集到的一条ars报文:0x60b 00 4e a4 01 80 20 01 7f      首先构建位图    将8字节64位数据转成二进制,依次展开  大端序列从左往右编号, 小端序从右往左编号, 从上到下依次增加                            位序编号          0          1          2          3          4          5          6          7                                      0x00          0          0          0          0          0          0          0          0                          0x4e          0          1          0          0          1          1          1          0                          0xa4          1          0          1          0          0          1          0          0                          0x01          0          0          0          0          0          0          0          1                          0x80          1          0          0          0          0          0          0          0                          0x20          0          0          1          0          0          0          0          0                          0x01          0          0          0          0          0          0          0          1                          0x7f          0          1          1          1          1          1          1          1                          根据信号描述获取对应字节这里以Obj_DistLat信号作为示例.如上所示,在dbc中定义的起始位start_bit = 18, 长度length = 11.大端序的实际起始位需要转换, 小端序无需转换,转换如下:    start_bit = 8 * (start_bit / 8) + (7 - (start_bit % 8));        转换之后为 stat_bit = 21, length = 11,          然后从位图中找到这11位是 0xa4的后3位 加上 0x01的8位即:100 00000001      然后按照大端序排列为 10000000001, 即10进制为val = 1025;      由于当前信号是无符号数据,所以补码等于源码,如果是有符号数且是负数的话需要取反加1计算(后面会介绍)      缩放 scale = -0.2, offset = 204.6, val = val * -0.2 + 204.6 = -0.4      即算得 Obj_DistLat在当前帧的值为-0.4, 其他信号按此步骤计算可得        {    &quot;Obj_DistLong&quot;: 3.2000000000000455,     &quot;Obj_VrelLong&quot;: 0.0,     &quot;Obj_DynProp&quot;: 1,     &quot;Obj_ID&quot;: 0,     &quot;Obj_RCS&quot;: -0.5,     &quot;Obj_VrelLat&quot;: 0.0,     &quot;Obj_DistLat&quot;: -0.4000000000000057}        至此当前帧解析完毕.  小端序列cve采集到的一条x1j报文:0x76d 00 00 00 00 ae 1f 00 00其0x76d报文定义如下:BO_ 1901 KeyCarFrameA1: 8 MINIEYE_TRANSMITTER SG_ on_route : 1|1@1+ (1,0) [0|1] &quot;&quot; Vector__XXX SG_ TargetVehicle_Status : 20|4@1+ (1,0) [0|15] &quot;&quot; Vector__XXX SG_ TargetVehicle_Width : 24|8@1+ (0.05,0) [0|12.5] &quot;M&quot; Vector__XXX SG_ FCW : 0|1@1+ (1,0) [0|1] &quot;&quot;  ADAS SG_ Vehicle_ID : 2|6@1+ (1,0) [0|63] &quot;&quot;  ADAS SG_ TargetVehicle_PosX : 8|12@1+ (0.0625,0) [0|250] &quot;m&quot;  ADAS SG_ TargetVehicle_PosY : 32|10@1- (0.0625,0) [-31.9375|31.9375] &quot;m&quot;  ADAS SG_ TargetVehicle_Type : 48|3@1+ (1,0) [0|7] &quot;&quot;  ADAS这里考虑TargetVehicle_PosY, 由上面分析可得 start_bit = 32, length = 10, scale = 0.0625, offset = 0,小端序, 有符号.      构建位图  此时位序与大端序号刚刚相反                            位序编号          7          6          5          4          3          2          1          0                                      0x00          0          0          0          0          0          0          0          0                          0x00          0          0          0          0          0          0          0          0                          0x00          0          0          0          0          0          0          0          0                          0x00          0          0          0          0          0          0          0          0                          0xae          1          0          1          0          1          1          1          0                          0x1f          0          0          0          1          1          1          1          1                          0x00          0          0          0          0          0          0          0          0                          0x00          0          0          0          0          0          0          0          0                      然后从位图中找到这10位是 0xae 加上 0xff的后两位 即:10101110 11  然后按照小端序排列为 1110101110, 即10进制为val = 942;  由于当前信号是有符号数据,且最高位为1,则说明该值为负数,需要取补码,补码为原码取反加1,则:val = ((~val) + 1) *-1 = -82  缩放加偏差为val = val * 0.0625 + 0 = -5.125      即算得 TargetVehicle_PosY在当前帧的值为-5.125, 其他信号按此步骤计算可得      {      &quot;TargetVehicle_PosX&quot;: 0.0,       &quot;TargetVehicle_Status&quot;: 0,       &quot;TargetVehicle_Type&quot;: 0,       &quot;FCW&quot;: 0,       &quot;on_route&quot;: 0,       &quot;TargetVehicle_PosY&quot;: -5.125,       &quot;Vehicle_ID&quot;: 0,       &quot;TargetVehicle_Width&quot;: 0.0  }      实现// 定义数据结构typedef struct can_frame{    int can_id;    uint8_t can_data[8];}can_frame;typedef struct singal{    int start;    int length;    float scale;    float offest;    float min_val;    float max_val;    bool little_order;    bool is_unsigned;    char* name;}singal;typedef struct dbc_message{    string name;    int can_id;    vector&amp;lt;singal&amp;gt; singals;}dbc_message;map&amp;lt;int, dbc_message&amp;gt; dbc; map&amp;lt;string, map&amp;lt;int, string&amp;gt; &amp;gt; val_table;// 加载dbcvoid add_dbc(char* dbc_path){        FILE* fp = fopen(dbc_path, &quot;r&quot;);        char buf[10086];        int last_bo_id = -1;        while (fgets(buf, 10085, fp) != NULL){            string target(buf);            target.erase(0, target.find_first_not_of(&quot; &quot;));            target.erase(target.find_last_not_of(&quot; &quot;) + 1);            if( target.substr(0, 3) == &quot;BO_&quot;){                regex reg(&quot;BO_\\\\s+(\\\\d+)\\\\s+(\\\\w+):&quot;);                smatch sm;                regex_search(target, sm, reg);                if(sm.empty()) continue;                               string desc = sm[2];                long long can_id = atoll(sm[1].str().c_str());                if(can_id &amp;gt; 0x7ff) can_id -= 0x80000000;                    if (dbc.find(can_id) != dbc.end())                {                    cout &amp;lt;&amp;lt; &quot;can_id conflict &quot; &amp;lt;&amp;lt; endl;                }                dbc_message dm;                dm.can_id = can_id;                dm.name = desc;                dbc[can_id] = dm;                last_bo_id = can_id;            }else if (target.substr(0, 3) == &quot;SG_&quot;){                regex reg(&quot;SG_\\\\s+(\\\\w+)\\\\s+:\\\\s+(\\\\d+)\\\\|(\\\\d+)@(\\\\d+)(.)\\\\s+\\\\((.+?),(.+?)\\\\)\\\\s+\\\\[(.*?)\\\\|(.*?)\\\\]\\\\s+\\&quot;(.*?)\\&quot;&quot;);                smatch sm;                regex_search(target, sm, reg);                if(sm.empty()) continue;                if( last_bo_id == -1) continue;                singal s;                s.name = (char*)malloc(strlen(sm[1].str().c_str()) + 1);                strcpy(s.name, sm[1].str().c_str());                s.start = atoi(sm[2].str().c_str());                s.length = atoi(sm[3].str().c_str());                s.little_order = atoi(sm[4].str().c_str());                s.is_unsigned = sm[5].str() == &quot;+&quot; ? true : false;                s.scale = atof(sm[6].str().c_str());                s.offest = atof(sm[7].str().c_str());                s.min_val = atof(sm[8].str().c_str());                s.max_val = atof(sm[9].str().c_str());                // sm[9] type                dbc[last_bo_id].singals.push_back(s);            }else if( target.substr(0, 4) == &quot;VAL_&quot;){                regex reg(&quot;VAL_\\\\s+(\\\\d+)\\\\s+(\\\\w+)\\\\s+(\\\\d+\\\\s+\\&quot;.+\\&quot;\\\\s*)+&quot;);                smatch sm;                regex_search(target, sm, reg);                if(sm.empty()) continue;                int can_id = atoi(sm[1].str().c_str());                string signal_name = sm[2].str();                string desc = sm[3].str();                string buf;                int desc_sz = desc.size();                int cnt = 0, val = 0;                string real_val = &quot;&quot;;                map&amp;lt;int, string&amp;gt; v = val_table[to_string(can_id) + &quot;_&quot; + signal_name];                for( int i = 0; i &amp;lt; desc_sz; i++) {                    if( desc[i] == &#39;&quot;&#39;) continue;                    if( desc[i] == &#39; &#39;) {                        if(!buf.empty()) {                            if(cnt &amp;amp; 1) {                                // cout &amp;lt;&amp;lt; val &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; buf &amp;lt;&amp;lt; endl;                                v[val] = buf;                            }else{                                val = atoi(buf.c_str());                            }                            buf.clear();                        }                        cnt += 1;                        continue;                    }                    buf += desc[i];                }                val_table[to_string(can_id) + &quot;_&quot; + signal_name] = v;                // for( int i = 0; i &amp;lt; sm.size(); i++ ) cout &amp;lt;&amp;lt; sm[i] &amp;lt;&amp;lt; endl;;            }        }        fclose(fp);        cout &amp;lt;&amp;lt; &quot;add dbc file finish...&quot; &amp;lt;&amp;lt; endl;    }// 解码信号double decode(singal s, can_frame t) {        assert(s.length &amp;gt; 0);                // for motorola deal start_bit        if(!s.little_order) s.start = 8 * (s.start / 8) + (7 - (s.start % 8));        uint64_t res = 0;        int now_len = s.length, len = s.length;        int now_start = s.start, start = s.start;        uint8_t buf[8], bit_lengths[8];        int start_bits = start / 8;        int end_bits = ( start + len - 1 ) / 8;        // printf(&quot;%d %d %d\\n&quot;, s.start, s.length, s.little_order);        // printf(&quot;%d %d\\n&quot;, start_bits, end_bits);        for (size_t i = start_bits ; i &amp;lt;= end_bits; i++){             // printf(&quot;%d *\\n&quot;, t.can_data[i]);              int dt = (i+1)*8-now_start;            if( dt &amp;lt;= now_len){                if(! s.little_order) {                    buf[i] = t.can_data[i] &amp;lt;&amp;lt; (8 - dt);                    buf[i] = buf[i] &amp;gt;&amp;gt; (8 - dt);                } else{                    buf[i] = t.can_data[i] &amp;gt;&amp;gt; (8 - dt);                }                now_len -= dt;                now_start += dt;                bit_lengths[i] = dt;            }else{                int now_dt = now_len;                // printf(&quot;\\n%d %d &quot;, dt, now_dt);                if ( ! s.little_order) {                    buf[i] = (t.can_data[i] &amp;lt;&amp;lt; (8 - dt));                    buf[i] = buf[i] &amp;gt;&amp;gt; (8 - now_dt);                }else {                    buf[i] = t.can_data[i] &amp;gt;&amp;gt; ( 8 - dt);                    buf[i] = buf[i] &amp;lt;&amp;lt; (8 - now_dt);                    buf[i] = buf[i] &amp;gt;&amp;gt; (8 - now_dt);                }                               now_len = 0;                now_start += now_dt;                bit_lengths[i] = now_dt;            }            // printf(&quot;%d &amp;amp;\\n&quot;, buf[i]);        }        // printf(&quot;\\n&quot;);        for (size_t i = 0 ; i &amp;lt;= end_bits-start_bits; i++){               uint8_t b = 0;            if( !s.little_order){                // if(i + start_bits + 1 &amp;lt;= end_bits) b = bit_lengths[i + start_bits + 1];                res = res &amp;lt;&amp;lt; bit_lengths[i+start_bits] | buf[i+start_bits];            }else{                // if(end_bits-i-1 &amp;gt;= 0) b = bit_lengths[end_bits-i-1];                res = res &amp;lt;&amp;lt; bit_lengths[end_bits-i] | buf[end_bits-i];            }            // printf(&quot;%d * &quot;, res);        }        // printf(&quot;res :%d\\n&quot;, res);        double real_res = res*1.0;        if (!s.is_unsigned &amp;amp;&amp;amp; (res &amp;gt;&amp;gt; (s.length-1) &amp;amp; 0x1))        {            res = ~res;            res = res &amp;lt;&amp;lt; 64 - s.length &amp;gt;&amp;gt; 64-s.length;            debug(res);            real_res = res*1.0;            debug(real_res);            real_res = (real_res + 1) * -1;            debug(real_res);        }        debug(s.scale);        debug(s.offest);        debug(s.max_val);        debug(s.min_val);        real_res = real_res * s.scale + s.offest;        real_res = real_res &amp;gt; s.max_val ? s.max_val : real_res;        real_res = real_res &amp;lt; s.min_val ? s.min_val : real_res;        // printf(&quot;\\n%f\\n&quot;, real_res);        return real_res;}完整代码见can_parser.cpp, 验证脚本见test_can.py.本人测试cve采集的一组x1j和ars数据时在1e-5的精度下能保证100%准确率. 由于未做大量验证,无法保证完全没有问题.使用第三方库python - cantoolsimport cantoolsdbc = cantools.database.load_file(&quot;/home/cao/work-git/cve/cve/dbc/ARS408.dbc&quot;, strict=False)rf = open(&quot;./test_can_parser_data/ars.txt&quot;, &quot;r&quot;)ids = [m.frame_id for m in dbc.messages]for line in rf:    cols = line.split()    can_id = int(cols[3], 16)    data = b&#39;&#39;.join([int(x, 16).to_bytes(1, &#39;little&#39;) for x in cols[4:]])    if can_id in ids:        j = dbc.decode_message(can_id, data, decode_choices=False)        print(json.dumps(j))        breakcpp - dbcc  github链接 : https://github.com/howerj/dbcc  安装完之后 dbcc ARS408.dbc 便会生成dbc对应的.h 和.c.      使用      #include &quot;ARS408.h&quot;  #include &amp;lt;linux/can.h&amp;gt;  int main(int argc, char const *argv[])  {      can_obj_ars408_h_t t;      double l = -1, lat = -1;      // 1611196534 520939 CAN6 0x60b 00 4e a4 01 80 20 01 7f      uint8_t data[8] = { 0x00, 0x4e, 0xa4, 0x01, 0x80, 0x20, 0x01, 0x7f};      printf(&quot;%lld\\n&quot;, *(uint64_t*)data);      int ret = unpack_message(&amp;amp;t, 0x60b, *(uint64_t*)data, 8, 0);      ret = decode_can_0x60b_Obj_DistLong(&amp;amp;t, &amp;amp;l);      ret = decode_can_0x60b_Obj_DistLat(&amp;amp;t, &amp;amp;lat);      printf(&quot;ret: %d\\n&quot;, ret);      // printf(&quot;dist_long: %lf, dis_lat: %lf, tmp: %lf\\n&quot;, t.can_0x60b_Obj_1_General.Obj_DistLong, t.can_0x60b_Obj_1_General.Obj_DistLat, val);      printf(&quot;dist_long: %lf, dis_lat: %lf\\n&quot;, l, lat);      return 0;  }      "
  },
  
  {
    "title": "PID控制器",
    "url": "/posts/pure_pid/",
    "categories": "运动控制",
    "tags": "PID, 反馈控制",
    "date": "2021-12-17 00:00:00 +0800",
    





    "snippet": "PID控制器  PID控制参数详解 PID  PID控制，即 比例（proportion） - 积分（integration） - 微分(differentiation) 控制是自动控制原理中定义的一种控制方法也可以称为是校正方法.积分形式:$U(t) = K_pe(t) + K_i\\int_0^te(t)dt + K_d\\cfrac{de(t)}{dt}$离散化:$U(t) = K_pe(t) + K_i\\sum{e(t)} + K_d(e(t) - e(t-1))$增量式:$U(t-1) = K_pe(t-1) + K_i\\sum{e(t-1)} + K_d(e(t-1) - e(t-2))$\\[\\begin{aligned}    \\Delta{U(t)} &amp;amp;= U(t) - U(t-1) \\\\ &amp;amp;=K_p(e(t)-e(t-1)) + K_ie(t) + K_d(e(t)-2e(t-1)+e(t-2))\\end{aligned}\\]如上图所示：Kp Ki Kd为pid三个参数.      比例环节成比例地反映控制系统的偏差信号e(t)，偏差一旦产生，控制器立即产生控制作用，以减小偏差。当仅有比例控制时系统输出存在稳态误差（Steady-state error）优点: 调整系统的开环比例系数，提高系统的稳态精度，减低系统的惰性，加快响应速度。缺点: 仅用P控制器,过大的开环比例系数不仅会使系统的超调量增大，而且会使系统稳定裕度变小，甚至不稳定。        积分环节控制器的输出与输入误差信号的积分成正比关系。主要用于消除静差，提高系统的无差度。积分作用的强弱取决于积分时间常数T,T越大，积分作用越弱，反之则越强。优点： 消除稳态误差。缺点： 积分控制器的加入会影响系统的稳定性，使系统的稳定裕度减小。        微分环节反映偏差信号的变化趋势，并能在偏差信号变得太大之前，在系统中引入一个有效的早期修正信号，从而加快系统的动作速度，减少调节时间。在微分控制中，控制器的输出与输入误差信号的微分（即误差的变化率）成正比关系.  无法单独起作用。优点：使系统的响应速度变快，超调减小，振荡减轻，对动态过程有“预测”作用。  代码实现输入误差与输入值，通过增量式pid调整double PurePid::step_control(double val, double err) {    double res = val;    errs[err_cnt%3] = err;        if(err_cnt &amp;gt;= 3)     {        res += _kp * (errs[err_cnt % 3] - errs[(err_cnt-1) % 3]) + _ki * errs[err_cnt % 3] + _kd * (errs[err_cnt % 3] - 2 * errs[(err_cnt - 1) % 3] + errs[(err_cnt - 2) % 3]);    }    err_cnt++;    return res;}"
  },
  
  {
    "title": "ndk调用c++动态库",
    "url": "/posts/ndk-chain/",
    "categories": "Android",
    "tags": "ndk",
    "date": "2021-11-15 00:00:00 +0800",
    





    "snippet": "cmake ndk 交叉编译      从官网下载ndk        生成独立的ndk工具链     ## 生成arm64版本的 ./build/tools/make_standalone_toolchain.sh \\ --arch arm64 \\ --install-dir=alone-sdk            cmake 配置     set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -fPIE&quot;) set(CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} -fPIE -pie&quot;) # 配置使用 NDK Standalone Toolchain 编译 set(NDK_STANDALONE_TOOLCHAIN /home/cao/Android/Sdk/ndk/21.3.6528147/alone-sdk) # set(CMAKE_SYSTEM_NAME AndroidARM) # set(CMAKE_SYSTEM_VERSION 3) set(CMAKE_C_COMPILER ${NDK_STANDALONE_TOOLCHAIN}/bin/aarch64-linux-android-gcc) set(CMAKE_CXX_COMPILER ${NDK_STANDALONE_TOOLCHAIN}/bin/aarch64-linux-android-g++) # set(CMAKE_FIND_ROOT_PATH ${NDK_STANDALONE_TOOLCHAIN}) set (CMAKE_ANDROID_ARCH_ABI arm64-v8a) # set (CMAKE_ANDROID_STANDALONE_TOOLCHAIN ~/ndk_toolchain) # 使用 NDK 提供的头文件 add_definitions(&quot;--sysroot=${NDK_STANDALONE_TOOLCHAIN}/sysroot&quot;)        android引入so                  将生成的.so放到src/main/jniLibs/arm64-v8a/,并将.h复制到默认的src/main/cpp                    配置CMakeLists               add_library(dds SHARED IMPORTED) #设置so路劲  ${CMAKE_SOURCE_DIR}是CMakeLists.txt的路径   ${ANDROID_ABI} 标识cpu类型 set_target_properties(dds PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/libdds.so) set_property(TARGET dds PROPERTY IMPORTED_NO_SONAME 1) # 链接dds库 target_link_libraries( # Specifies the target library.     native-lib     dds     flow_stream     # Links the target library to the log library     # included in the NDK.     ${log-lib})              配置app/build.gradle         ## defaultConfig下配置 externalNativeBuild {     cmake {         cppFlags &quot;&quot;         arguments &quot;-DANDROID_STL=c++_shared&quot;     } } ndk {     # 这里只配置 arm64-v8a,因为只生成了这个版本的库     abiFilters &#39;arm64-v8a&#39; } ## android 标签下配置 splits {     abi {         enable true         reset()         include &#39;x86&#39;, &#39;x86_64&#39;, &#39;armeabi-v7a&#39;, &#39;arm64-v8a&#39; //select ABIs to build APKs for         universalApk true //generate an additional APK that contains all the ABIs     } } # map for the version code project.ext.versionCodes = [&#39;armeabi&#39;: 1, &#39;armeabi-v7a&#39;: 2, &#39;arm64-v8a&#39;: 3, &#39;mips&#39;: 5, &#39;mips64&#39;: 6, &#39;x86&#39;: 8, &#39;x86_64&#39;: 9] android.applicationVariants.all { variant -&amp;gt;     // assign different version code for each output     variant.outputs.each { output -&amp;gt;         output.versionCodeOverride =                 project.ext.versionCodes.get(output.getFilter(com.android.build.OutputFile.ABI), 0) * 1000000 + android.defaultConfig.versionCode     } }        android使用          使用默认生成native-lib.cpp include头文件,创建好暴露接口即可      附数据对应 https://blog.csdn.net/smilestone322/article/details/88607717      "
  },
  
  {
    "title": "cython调用c++库",
    "url": "/posts/ctypes-cpp-demo/",
    "categories": "python编程",
    "tags": "cython, ctypes",
    "date": "2021-11-10 00:00:00 +0800",
    





    "snippet": "cython调用c++动态库示例  cpp代码暴露的函数如下typedef struct can_frame{    int can_id;    uint8_t can_data[8];}can_frame;typedef struct singal{    int start;    int length;    float scale;    float offest;    float min_val;    float max_val;    bool little_order;    bool is_unsigned;    char* name;}singal;extern &quot;C&quot; {    float decode(singal s, can_frame t);    void add_dbc(char* dbc_path);    char* decode_message(can_frame t, bool use_val_table=true);}  在cmake中通过 add_library(test_can SHARED can_parser.cpp) 导出libtest_can.so,至此动态库导出完成。接下来python调用## 导入ctypesfrom ctypes import *## 加载动态库decode_dll = cdll.LoadLibrary(&quot;/home/cao/CLionProjects/pcv/build/lib/libtest_can.so&quot;)## 定义结构体，同cpp定义一致,左侧为变量名，右侧为类型。其中c语言与ctypes的类型转换见末尾class singal(Structure):    _fields_ = [        (&quot;start&quot;, c_int),        (&quot;length&quot;, c_int),        (&quot;scale&quot;, c_float),        (&quot;offest&quot;, c_float),        (&quot;min_val&quot;, c_float),        (&quot;max_val&quot;, c_float),        (&quot;little_order&quot;, c_bool),        (&quot;is_unsigned&quot;, c_bool),        (&quot;name&quot;, c_char_p)    ]class can_frame(Structure):    _fields_ = [        (&quot;can_id&quot;, c_int),        (&quot;can_data&quot;, c_ubyte*8)    ]## 调用add_dbc函数name = c_char_p(bytes(&quot;./dbc/QZ_x1q_20200224.dbc&quot;, &quot;utf-8&quot;)) # str -&amp;gt; bytes -&amp;gt; c_char_pdecode_dll.add_dbc(name)## 调用decodecan_id = 10086can_data = [0, 1, 2, 3, 4, 5, 6, 7]data = (c_ubyte*8)(*can_data)c = can_frame(can_id, data)s = singal(8, 12, 0.0625, 0, 0, 250, True, True, c_char_p(bytes(&quot;test&quot;, &quot;utf-8&quot;)))decode_dll.decode.restype = c_floatpx = decode_dll.decode(s, c)## 调用decode_messagedecode_dll.decode_message.restype = c_char_p  # 设置返回类型res = decode_dll.decode_message(c)res = res.decode()  # bytes -&amp;gt; str  附图官方链接基础数据类型¶ctypes 定义了一些和C兼容的基本数据类型：ctypes 类型C 类型Python 类型c_bool_Boolbool (1)c_charchar单字符字节对象c_wcharwchar_t单字符字符串c_bytechar整型c_ubyteunsigned char整型c_shortshort整型c_ushortunsigned short整型c_intint整型c_uintunsigned int整型c_longlong整型c_ulongunsigned long整型c_longlong__int64 或 long long整型c_ulonglongunsigned __int64 或 unsigned long long整型c_size_tsize_t整型c_ssize_tssize_t 或 Py_ssize_t整型c_floatfloat浮点数c_doubledouble浮点数c_longdoublelong double浮点数c_char_pchar * (以 NUL 结尾)字节串对象或 Nonec_wchar_pwchar_t * (以 NUL 结尾)字符串或 Nonec_void_pvoid *int 或 None"
  },
  
  {
    "title": "共享内存",
    "url": "/posts/shm/",
    "categories": "C++编程",
    "tags": "共享内存",
    "date": "2021-10-18 00:00:00 +0800",
    





    "snippet": "采用share memory 做ipc通信介绍      共享内存就是允许两个不相关的进程访问同一个逻辑内存；共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式；不同进程之间共享的内存通常安排为同一段物理内存，进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址；而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。        共享内存是最快的可用IPC形式。        共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取；通常需要用其他的机制来同步对共享内存的访问，例如信号量、互斥锁。        主要有两类实现 System V， Posix两种实现， 两者间的区别及简单实现。  本文通过Posix和信号量实现ipc通信队列并支持多生产者和多消费者。实现过程原理      解释l为第一个数据的起始位置， r为最后一个数据的起始位置，id为当前写入的数据id（默认从0递增），data为原始数据，d_id为当前写入数据的id值，size为当前data+d_id+size之后的大小。buf为整个共享内存，l，r,id为header; size,d_id为数据的header。除了buf header剩余的空间为数据区，本质是个循环队列，这里大小为queue_size = buf_size - 12。        过程        写操作，读取l,r,id,封装当前数据（增加d_id=id+1和size）,判断(r-l+queue_size)%queue_size计算当前剩余空间是否能够放下当前数据，如果不够，(l + l_size)%queue_size,剩余空间增加l_size。循环之，直到剩余空间能够放下当先数据，然后复制到buf，得到新的r。更新l，r，id=id+1到buf header。写操作完成。        读操作, 读取l，r，id。read_index,read_fid（为已经读取的数据位置，数据的id，由read方维护），计算r处的r_id,l处的l_id.如果r_id&amp;lt;=read_fid,则当前无新数据可读;如果l_id&amp;lt;=read_id，则read_index移动read_size到下一个数据的起点，读取数据即可read_index=(read_size + read_index)%queue_size,read_id = read_index_id;如果l_id&amp;gt;read_id则数据已经被覆盖，read_index=l_index，read_id=l_id。至次读取数据完毕。        由于共享内存没有同步操作，所以每次读写操作之前都需要通过信号量来同步，确保每次读写分离。  主要函数解释  prepare()创建或挂载共享内存，创建或绑定信号量void parare(){    int fd = shm_open(topic, O_CREAT | O_EXCL | O_RDWR, 0644);    if (fd == -1){        fd = shm_open(topic, O_EXCL | O_RDWR, 0644);        if( fd == -1) {            perror(&quot;shm_open&quot;);            exit(EXIT_FAILURE);        }      }    if( ftruncate(fd, shm_size) == -1){        perror(&quot;ftruncate&quot;);        exit(EXIT_FAILURE);    }    buf = (uint8_t*)mmap(NULL, shm_size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED, fd, 0);    if (buf == MAP_FAILED){        perror(&quot;mmap&quot;);        exit(EXIT_FAILURE);    }    close(fd);    sem = sem_open(topic, O_CREAT | O_RDWR  | O_EXCL, 0644, 1);    if( sem == SEM_FAILED){        sem = sem_open(topic, O_RDWR  | O_EXCL, 0644, 1);        if(sem == SEM_FAILED) {            perror(&quot;sem_open&quot;);            exit(EXIT_FAILURE);        }    }}  write(uint8_t* data, uint32_t size)读取数据void write(uint8_t* data, uint32_t size){      if( sem_wait(sem) == -1) {        perror(&quot;sem_wait&quot;);        exit(EXIT_FAILURE);    }    uint32_t l = _uint8_2_uint32(0); //    uint32_t r = _uint8_2_uint32(4); //     uint32_t fid = _uint8_2_uint32(8);    // 构造数据    uint8_t* tmp = (uint8_t*)malloc(size + 8);    memcpy(tmp+8, data, size);    size += 8;    fid += 1;    for( int i = 0; i &amp;lt; 4; i++ ) tmp[3-i] = size &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    for( int i = 0; i &amp;lt; 4; i++ ) tmp[7-i] = fid &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    int real_size = (( r - l ) + queue_size) % queue_size;    int remain = queue_size - real_size - 1;    while( remain &amp;lt; size) {        uint32_t s = _uint8_2_uint32(l + 1 + head_size);        l = (l + s)%queue_size;        remain += s;    }    if( queue_size - r - 1 &amp;lt; size) {        int dt = size - queue_size + r + 1;        memcpy(buf + r + head_size + 1, tmp, queue_size - r - 1);        memcpy(buf + head_size, tmp + queue_size - r -1, dt);        r = dt - 1;    }else{        memcpy(buf + r + head_size + 1, tmp, size);        r = r + size;    }    for( int i = 0; i &amp;lt; 4; i++ ) buf[3-i] = l &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    for( int i = 0; i &amp;lt; 4; i++ ) buf[7-i] = r &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;        for( int i = 0; i &amp;lt; 4; i++ ) buf[11-i] = fid &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    printf(&quot;write fid is %d\\n&quot;, fid);    if( sem_post(sem) == -1) {        perror(&quot;sem_post&quot;);        exit(EXIT_FAILURE);    }}  uint_8* read()读取数据uint8_t* read(){    if( sem_wait(sem) == -1) {        perror(&quot;sem_wait&quot;);        exit(EXIT_FAILURE);    }    uint32_t l = _uint8_2_uint32(0); //    uint32_t r = _uint8_2_uint32(4); //    uint32_t last_fid = _uint8_2_uint32(8);    if( read_index == -1) {        read_index = (l + 1)%queue_size;    }else{        if(last_fid &amp;lt;= read_fid) {            if( sem_post(sem) == -1) {                perror(&quot;sem_wait&quot;);                exit(EXIT_FAILURE);            }            return NULL;        }        uint32_t mi_fid = _uint8_2_uint32(l + 1 + head_size + 4);          if( mi_fid &amp;lt;= read_fid) {            uint32_t s = _uint8_2_uint32(read_index + head_size);            read_index = (s + read_index) % queue_size;        }else read_index = (l + 1)%queue_size;    }    uint32_t s = _uint8_2_uint32(read_index + head_size);    uint8_t* data = (uint8_t*)malloc(s);    if( s + read_index &amp;gt; queue_size){        uint32_t dt = s + read_index - queue_size;        memcpy(data, buf + head_size + read_index, s - dt);        memcpy(data + s - dt, buf + head_size, dt);    }else{        memcpy(data, buf + head_size + read_index, s);    }    read_fid = _uint8_2_uint32(read_index + head_size + 4);    printf(&quot;read fid os %d\\n&quot;, read_fid);    if( sem_post(sem) == -1) {        perror(&quot;sem_post&quot;);        exit(EXIT_FAILURE);    }    return data;    }  python接口extern &quot;C&quot;{    ShmFlow* shmflow = NULL;    void init_flow(char* topic, int size){        if(shmflow == NULL)  shmflow = new ShmFlow(topic, size);        printf(&quot;shmflow init ok\\n&quot;);    }    void write_data(char* data, int size) {        uint8_t* t = (uint8_t*)data;        shmflow-&amp;gt;write(t, size);    }    int read_data(char* data){        uint8_t* res = shmflow-&amp;gt;read();        if( res == NULL) return 0;        uint32_t tmp = 0;        for( uint32_t i = 0; i &amp;lt; 4; i++) tmp = (tmp &amp;lt;&amp;lt; 8) + res[i];        memcpy(data, res, tmp);        return 1;    }}  python调用示例读取数据def test_shmflow_read():    import cv2    import numpy as np    shmflow_dll = cdll.LoadLibrary(&quot;/home/cao/CLionProjects/pcv/build/lib/libshmflow.so&quot;)    topic = c_char_p(bytes(&quot;video&quot;, &#39;utf-8&#39;))    shmflow_dll.init_flow(topic, 1280*3*720*10)    while True:        d = create_string_buffer(1280 * 3 * 720 * 10)        res = shmflow_dll.read_data(d)        if res == 0:            continue        size = int.from_bytes(d.raw[:4], byteorder=&quot;big&quot;, signed=False)        fid = int.from_bytes(d.raw[4:8], byteorder=&quot;big&quot;, signed=False)        print(fid, size)        d = d.raw[8:size]        png = np.fromstring(d, dtype=np.uint8).reshape((720, 1280, 3))        cv2.imshow(&quot;----&quot;, png)        cv2.waitKey(110)写数据def test_shmflow_write():    import cv2    img = cv2.imread(&quot;/home/cao/pcview-v2/x1d3_view/pcview_data/20200527112701/cap-fig/20200527-113043-314863-cap.png&quot;)    shmflow_dll = cdll.LoadLibrary(&quot;/home/cao/CLionProjects/pcv/build/lib/libshmflow.so&quot;)    topic = c_char_p(bytes(&quot;video&quot;, &#39;utf-8&#39;))    shmflow_dll.init_flow(topic, 1280 * 3 * 720 * 10)    img = cv2.resize(img, (1280, 720))    img = img.tostring()    # t = np.fromstring(img, dtype=np.uint8).reshape((720, 1280, 3))    # cv2.imshow(&quot;---&quot;, t)    # cv2.waitKey(1000)    cp = c_char_p(img)    shmflow_dll.write_data(cp, 1280*720*3)亟待完善写和写互斥，写和读互斥，读和读不互斥感谢您阅读此文档"
  }
  
]

