<blockquote>
  <p><a href="https://zh.m.wikipedia.org/zh/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">布隆过滤器</a></p>
</blockquote>

<p><strong>基本定义</strong>: 布隆过滤器(Bloom Filter)是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。</p>

<p><strong>基本原理</strong>:布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p>

<p><strong>优点</strong>:</p>
<ul>
  <li>插入和查询都是时间都是常数(O(k))</li>
  <li>节省很大的空间</li>
  <li>散列函数相互之间无依赖，可以并行实现</li>
  <li>不存储元素本身，某些对保密要求非常严格的场合有优势</li>
  <li>多个相同的布隆过滤器可以直接合并</li>
  <li>可以表示全集</li>
</ul>

<p><strong>缺点</strong>:</p>
<ul>
  <li>会有很多假正例，即不在过滤器中的会被误判</li>
  <li>无法删除元素</li>
</ul>

<p><strong>用途</strong>:</p>
<ul>
  <li>网页爬虫对海量URL的去重，避免爬取相同的URL地址</li>
  <li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱</li>
  <li>缓存击穿，将已存在的缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉</li>
  <li>过滤海量无效访问，宁可错杀一千也不放过一个</li>
</ul>

<p><strong>实现</strong>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;string&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</span>
<span class="k">class</span> <span class="nc">BlooomFilters</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">BlooomFilters</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

        <span class="c1">// num_of_hash ~= table_length / n * ln2</span>
        <span class="n">BlooomFilters</span><span class="p">(</span><span class="kt">int</span> <span class="n">table_length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_of_hash</span><span class="p">){</span>
            <span class="n">mod</span> <span class="o">=</span> <span class="n">table_length</span><span class="p">;</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">num_of_hash</span><span class="p">;</span>
            <span class="n">bloom_table</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="n">table_length</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">bloom_table</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">table_length</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="o">~</span><span class="n">BlooomFilters</span><span class="p">(){</span>
            <span class="k">delete</span> <span class="n">bloom_table</span><span class="p">;</span>
            <span class="n">bloom_table</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// seed 优先使用 2^n -1 (java 使用31),通过不同的seed达到多个hash函数的目的</span>
        <span class="kt">uint32_t</span> <span class="n">bkdr_hash</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">seed</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
            <span class="kt">uint32_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">*</span> <span class="n">seed</span> <span class="o">+</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">hash</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="n">hash</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
                <span class="kt">uint32_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                <span class="kt">uint32_t</span> <span class="n">hash_val</span> <span class="o">=</span> <span class="n">bkdr_hash</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
                <span class="c1">// 将hash值对应的位置1</span>
                <span class="n">bloom_table</span><span class="p">[</span><span class="n">hash_val</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hash_val</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 会有假正例 </span>
        <span class="kt">bool</span> <span class="n">has_hashed</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">){</span>
            <span class="kt">uint32_t</span> <span class="n">equal</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">uint32_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                <span class="kt">uint32_t</span> <span class="n">hash_val</span> <span class="o">=</span> <span class="n">bkdr_hash</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
                <span class="n">equal</span> <span class="o">=</span> <span class="n">equal</span> <span class="o">&amp;&amp;</span> <span class="n">bloom_table</span><span class="p">[</span><span class="n">hash_val</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hash_val</span> <span class="o">%</span> <span class="mi">8</span><span class="p">);</span>
                <span class="c1">// printf("%d %d\n",bloom_table[hash_val / 8], 1 &lt;&lt; hash_val %8);</span>
            <span class="p">}</span>
            <span class="c1">// printf("################\n");</span>
            <span class="k">return</span> <span class="n">equal</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="nl">private:</span>
        <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">bloom_table</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">mod</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"123456789"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"abcedefkljg"</span><span class="p">;</span>

    <span class="n">BlooomFilters</span> <span class="n">bf</span><span class="p">(</span><span class="mi">1008611</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

    <span class="n">bf</span><span class="p">.</span><span class="n">hash</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="n">bf</span><span class="p">.</span><span class="n">hash</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">bf</span><span class="p">.</span><span class="n">hash</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%d %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">bf</span><span class="p">.</span><span class="n">has_hashed</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">bf</span><span class="p">.</span><span class="n">has_hashed</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">bf</span><span class="p">.</span><span class="n">has_hashed</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">bf</span><span class="p">.</span><span class="n">has_hashed</span><span class="p">(</span><span class="s">"fjlajflajf"</span><span class="p">),</span> <span class="n">bf</span><span class="p">.</span><span class="n">has_hashed</span><span class="p">(</span><span class="s">"roquroqfa"</span><span class="p">),</span> <span class="n">bf</span><span class="p">.</span><span class="n">has_hashed</span><span class="p">(</span><span class="s">"ghnnv,anv"</span><span class="p">));</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

