[
  
  {
    "title": "åŒˆç‰™åˆ©ç®—æ³•",
    "url": "/posts/hungarian/",
    "categories": "ç®—æ³•, å…³è”ç®—æ³•",
    "tags": "ç®—æ³•, ç›®æ ‡å…³è”",
    "date": "2022-06-09 00:00:00 +0800",
    





    "snippet": "åŒˆç‰™åˆ©ç®—æ³•æ˜¯ç”±åŒˆç‰™åˆ©æ•°å­¦å®¶Edmondsäº1965å¹´æå‡ºï¼Œå› è€Œå¾—åã€‚æœ¬è´¨æ˜¯ä¸ºäº†è§£å†³äºŒåˆ†å›¾åŒ¹é…é—®é¢˜ã€‚å¤§è‡´ç†è§£å¦‚ä¸‹:æœ‰nä¸ªç”·çš„ï¼Œmä¸ªå¥³çš„ã€‚ç”·çš„åªèƒ½è·Ÿå¥³çš„é…å¯¹ï¼Œä¸”åªèƒ½ä¸€å¯¹ä¸€é…å¯¹ã€‚åŒæ—¶ï¼Œå¦‚æœç”·å¥³é…å¯¹éœ€è¦æ¶ˆè€—å½©ç¤¼costï¼Œä¸åŒç”·å¥³ä¹‹é—´çš„å½©ç¤¼æ˜¯ä¸ä¸€æ ·çš„ã€‚é—®å¦‚ä½•å°½å¯èƒ½çš„é…å¯¹ï¼ŒåŒæ—¶é…å¯¹æ‰€æ¶ˆè€—çš„å½©ç¤¼æœ€å°ã€‚åŒˆç‰™åˆ©æœ¬è´¨å°±æ˜¯è§£å†³è¿™ç§é—®é¢˜ã€‚å…·ä½“å¯ä»¥çœ‹åŒˆç‰™åˆ©ç®—æ³•è¯¦è§£,æ­¤ç®—æ³•å¸¸ç”¨äºç›®æ ‡å…³è”ï¼Œç›®æ ‡èåˆï¼Œç›®æ ‡åŒ¹é…ç­‰åœºæ™¯ã€‚æœ¬æ–‡ä¸»è¦è®°å½•å¦‚ä½•å®ç°ã€‚costç›¸åŒï¼Œå°½å¯èƒ½åŒ¹é…å¤š#include &amp;lt;bits/stdc++.h&amp;gt;#define INF 0x3f3f3f3f;using namespace std;int L[505][505];int boy[505];int used[505];int k,m,n;  //å¯èƒ½çš„ç»„åˆæ•°kï¼Œå¥³ç”Ÿæ•°mï¼Œç”·ç”Ÿæ•°n // äºŒåˆ†å›¾åŒ¹é… bool find(int i){    for(int j=1;j&amp;lt;=n;j++){        if(L[i][j] &amp;amp;&amp;amp; !used[j]){  //è·Ÿä»–æœ‰å…³ç³»è€Œä¸”æ²¡æœ‰æœç´¢è¿‡             used[j]=1;            if(!boy[j] || find(boy[j])){                boy[j]=i;                return true;            }        }    }    return false;}int main(){    while(cin&amp;gt;&amp;gt;k&amp;gt;&amp;gt;m&amp;gt;&amp;gt;n){        memset(L,0,sizeof(L));        memset(boy,0,sizeof(boy));        for(int i=1;i&amp;lt;=k;i++){            int n1,n2;            cin&amp;gt;&amp;gt;n1&amp;gt;&amp;gt;n2;            L[n1][n2]=1;        }        int sum=0;        for(int i=1;i&amp;lt;=m;i++){            memset(used,0,sizeof(used));            if(find(i)) sum++;        }        cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;endl;    }    return 0;} costä¸åŒï¼Œå°½å¯èƒ½costæœ€å°ï¼Œé€’å½’æ–¹æ³•#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int INF = 0x3f3f3f3f;int love[305][305];    // æ¯ä¸ªå¦¹å­å¯¹æ¯ä¸ªç”·ç”Ÿçš„å¥½æ„Ÿåº¦ int ex_girl[305];      // æ¯ä¸ªå¦¹å­çš„æœŸæœ›å€¼int ex_boy[305];       // æ¯ä¸ªç”·ç”Ÿçš„æœŸæœ›å€¼bool vis_girl[305];    // æ¯ä¸€è½®åŒ¹é…åŒ¹é…è¿‡çš„å¥³ç”Ÿbool vis_boy[305];     // æ¯ä¸€è½®åŒ¹é…åŒ¹é…è¿‡çš„ç”·ç”Ÿint match[305];        // æ¯ä¸ªç”·ç”ŸåŒ¹é…åˆ°çš„å¦¹å­ å¦‚æœæ²¡æœ‰åˆ™ä¸º-1int slack[305];        // æ¯ä¸ªæ±‰å­å¦‚æœèƒ½è¢«å¦¹å­å€¾å¿ƒæœ€å°‘è¿˜éœ€è¦å¤šå°‘æœŸæœ›å€¼int n;bool dfs(int girl){    vis_girl[girl] = true;    for (int boy = 0; boy &amp;lt; n; boy++) {        if (vis_boy[boy]) continue; // æ¯ä¸€è½®åŒ¹é… æ¯ä¸ªç”·ç”Ÿåªå°è¯•ä¸€æ¬¡        int gap = ex_girl[girl] + ex_boy[boy] - love[girl][boy];        if (gap == 0) {  // å¦‚æœç¬¦åˆè¦æ±‚            vis_boy[boy] = true;            if (match[boy] == -1 || dfs( match[boy] )) {    // æ‰¾åˆ°ä¸€ä¸ªæ²¡æœ‰åŒ¹é…çš„ç”·ç”Ÿ æˆ–è€…è¯¥ç”·ç”Ÿçš„å¦¹å­å¯ä»¥æ‰¾åˆ°å…¶ä»–äºº                match[boy] = girl;                return true;            }        }else{            slack[boy] = min(slack[boy], gap);  // slack å¯ä»¥ç†è§£ä¸ºè¯¥ç”·ç”Ÿè¦å¾—åˆ°å¥³ç”Ÿçš„å€¾å¿ƒ è¿˜éœ€å¤šå°‘æœŸæœ›å€¼ å–æœ€å°å€¼ å¤‡èƒçš„æ ·å­        }    }    return false;}int KM(){    memset(match, -1, sizeof match);    // åˆå§‹æ¯ä¸ªç”·ç”Ÿéƒ½æ²¡æœ‰åŒ¹é…çš„å¥³ç”Ÿ    memset(ex_boy, 0, sizeof ex_boy);   // åˆå§‹æ¯ä¸ªç”·ç”Ÿçš„æœŸæœ›å€¼ä¸º0    // æ¯ä¸ªå¥³ç”Ÿçš„åˆå§‹æœŸæœ›å€¼æ˜¯ä¸å¥¹ç›¸è¿çš„ç”·ç”Ÿæœ€å¤§çš„å¥½æ„Ÿåº¦    for (int i = 0; i &amp;lt; n; i++) {        ex_girl[i] = love[i][0];        for (int j = 1; j &amp;lt; n; j++) {            ex_girl[i] = max(ex_girl[i], love[i][j]);        }    }    // å°è¯•ä¸ºæ¯ä¸€ä¸ªå¥³ç”Ÿè§£å†³å½’å®¿é—®é¢˜    for (int i = 0; i &amp;lt; n; i++) {        fill(slack, slack + n, INF);    // å› ä¸ºè¦å–æœ€å°å€¼ åˆå§‹åŒ–ä¸ºæ— ç©·å¤§        while(1){            // ä¸ºæ¯ä¸ªå¥³ç”Ÿè§£å†³å½’å®¿é—®é¢˜çš„æ–¹æ³•æ˜¯ ï¼šå¦‚æœæ‰¾ä¸åˆ°å°±é™ä½æœŸæœ›å€¼ï¼Œç›´åˆ°æ‰¾åˆ°ä¸ºæ­¢            // è®°å½•æ¯è½®åŒ¹é…ä¸­ç”·ç”Ÿå¥³ç”Ÿæ˜¯å¦è¢«å°è¯•åŒ¹é…è¿‡            memset(vis_girl, false, sizeof vis_girl);            memset(vis_boy, false, sizeof vis_boy);            if(dfs(i)) break;  // æ‰¾åˆ°å½’å®¿ é€€å‡º            // å¦‚æœä¸èƒ½æ‰¾åˆ° å°±é™ä½æœŸæœ›å€¼            // æœ€å°å¯é™ä½çš„æœŸæœ›å€¼            int d = INF;            for (int j = 0; j &amp;lt; n; j++)                if (!vis_boy[j])    d = min(d, slack[j]);            for (int j = 0; j &amp;lt; n; j++) {                // æ‰€æœ‰è®¿é—®è¿‡çš„å¥³ç”Ÿé™ä½æœŸæœ›å€¼                if (vis_girl[j]) ex_girl[j] -= d;                // æ‰€æœ‰è®¿é—®è¿‡çš„ç”·ç”Ÿå¢åŠ æœŸæœ›å€¼                if (vis_boy[j]) ex_boy[j] += d;                // æ²¡æœ‰è®¿é—®è¿‡çš„boy å› ä¸ºgirlä»¬çš„æœŸæœ›å€¼é™ä½ï¼Œè·ç¦»å¾—åˆ°å¥³ç”Ÿå€¾å¿ƒåˆè¿›äº†ä¸€æ­¥ï¼                else slack[j] -= d;            }        }    }    // åŒ¹é…å®Œæˆ æ±‚å‡ºæ‰€æœ‰é…å¯¹çš„å¥½æ„Ÿåº¦çš„å’Œ    int res = 0;    for (int i = 0; i &amp;lt; n; i++)        res += love[match[i]][i];    return res;}int main(){    while (cin&amp;gt;&amp;gt;n) {        for (int i = 0; i &amp;lt; n; i++)            for (int j = 0; j &amp;lt; n; j++)                cin&amp;gt;&amp;gt;love[i][j];        cout&amp;lt;&amp;lt;KM()&amp;lt;&amp;lt;endl;    }    return 0;}        costä¸åŒï¼Œå°½å¯èƒ½costæœ€å°ï¼ŒçŸ©é˜µæ–¹æ³•import numpy as npclass Munkres:    def __init__(self, cost: list, inv_eps=1000) -&amp;gt; None:        &quot;&quot;&quot;[summary]        https://brc2.com/the-algorithm-workshop/        Args:            cost (list): [äºŒç»´æƒå€¼æ–¹é˜µ]        &quot;&quot;&quot;        self.cost = np.array(cost) * inv_eps        self.cost.astype(np.int32)        self.run_cost = self.cost        self.rows = len(cost)        self.cols = len(cost[0])        self.step = 1        self.running = True        assert(self.rows == self.cols)        self.mp = {            1: self.step_one,            2: self.step_two,            3: self.step_three,            4: self.step_four,            5: self.step_five,            6: self.step_six,            7: self.step_seven        }        self.mask = np.zeros((self.rows, self.cols))        self.row_cover = np.zeros(self.rows)        self.col_cover = np.zeros(self.cols)        self.paths = []    def step_one(self):        &quot;&quot;&quot;[summary]            For each row of the matrix, find the smallest element and subtract it from every element in its row.  Go to Step 2        &quot;&quot;&quot;        for i in range(self.rows):            self.run_cost[i] -= min(self.run_cost[i])        self.step = 2    def step_two(self):        &quot;&quot;&quot;[summary]        Find a zero (Z) in the resulting matrix. If there is no starred zero in its row or column, star Z. Repeat for each element in the matrix. Go to Step 3        &quot;&quot;&quot;        for i in range(self.rows):            for j in range(self.cols):                if self.run_cost[i][j] == 0 and self.row_cover[i] == 0 and self.col_cover[j] == 0:                    self.mask[i][j] = 1                    self.row_cover[i] = 1                    self.col_cover[j] = 1        for i in range(self.rows):            self.row_cover[i] = 0        for j in range(self.cols):            self.col_cover[j] = 0        self.step = 3    def step_three(self):        &quot;&quot;&quot;[summary]            Cover each column containing a starred zero.              If K columns are covered, the starred zeros describe a complete set of unique assignments.              In this case, Go to DONE, otherwise, Go to Step 4.        &quot;&quot;&quot;        for i in range(self.rows):            for j in range(self.cols):                if self.mask[i][j] == 1:                    self.col_cover[j] = 1        colcount = np.sum(self.col_cover)        if colcount &amp;gt;= self.rows or colcount &amp;gt;= self.cols:            self.step = 7        else:            self.step = 4    def __find_a_zero(self):        &quot;&quot;&quot;[summary]         Find a noncovered zero        Returns:            [type]: [row, col , default -1]        &quot;&quot;&quot;        r, c = -1, -1        for i in range(self.rows):            for j in range(self.cols):                if self.run_cost[i][j] == 0 and self.row_cover[i] == 0 and self.col_cover[j] == 0:                    return i, j        return r, c    def __find_star_in_row(self, row):        &quot;&quot;&quot;[summary]        Args:            row ([type]): [row]        Returns:            [int]: [find stared col in row, default -1]        &quot;&quot;&quot;        for j in range(self.cols):            if self.mask[row][j] == 1:                return j        return -1    def step_four(self):        &quot;&quot;&quot;[summary]            Find a noncovered zero and prime it.  If there is no starred zero in the row containing this primed zero, Go to Step 5.              Otherwise, cover this row and uncover the column containing the starred zero.             Continue in this manner until there are no uncovered zeros left. Save the smallest uncovered value and Go to Step 6.        &quot;&quot;&quot;        done = False        while not done:            noncover_r, noncover_c = self.__find_a_zero()            if noncover_r == -1:                done = True                self.step = 6            else:                self.mask[noncover_r][noncover_c] = 2                star_col = self.__find_star_in_row(noncover_r)                if star_col != -1:                    self.row_cover[noncover_r] = 1                    self.col_cover[star_col] = 0                else:                    done = True                    self.step = 5                    self.paths.append((noncover_r, noncover_c))    def __find_star_in_col(self, col):        for i in range(self.rows):            if self.mask[i][col] == 1:                return i        return -1    def __find_prime_in_row(self, row):        &quot;&quot;&quot;[summary]        Args:            col ([type]): [col]        Returns:            [int]: [find prime row in col, default -1]        &quot;&quot;&quot;        for j in range(self.cols):            if self.mask[row][j] == 2:                return j        return -1    def step_five(self):        &quot;&quot;&quot;[summary]            Construct a series of alternating primed and starred zeros as follows.  Let Z0 represent the uncovered primed zero found in Step 4.             Let Z1 denote the starred zero in the column of Z0 (if any). Let Z2 denote the primed zero in the row of Z1 (there will always be one).              Continue until the series terminates at a primed zero that has no starred zero in its column.             Unstar each starred zero of the series, star each primed zero of the series, erase all primes and uncover every line in the matrix.  Return to Step 3        &quot;&quot;&quot;                done = False        while not done:            star_r = self.__find_star_in_col(self.paths[-1][1])            if star_r &amp;gt; -1:                self.paths.append( (star_r, self.paths[-1][1]) )            else:                done = True            if not done:                prime_c = self.__find_prime_in_row( self.paths[-1][0] )                self.paths.append( (self.paths[-1][0], prime_c))        # argument path        for i, j in self.paths:            if self.mask[i][j] == 1:                self.mask[i][j] = 0            else:                self.mask[i][j] = 1        # clear covers        for i in range(self.rows):            self.row_cover[i] = 0        for j in range(self.cols):            self.col_cover[j] = 0        # erase prime        for i in range(self.rows):            for j in range(self.cols):                if self.mask[i][j] == 2:                    self.mask[i][j] = 0        self.paths.clear()        self.step = 3    def step_six(self):        &quot;&quot;&quot;[summary]            Add the value found in Step 4 to every element of each covered row, and subtract it from every element of each uncovered column.              Return to Step 4 without altering any stars, primes, or covered lines        &quot;&quot;&quot;        minval = 1 &amp;lt;&amp;lt; 31        for i in range(self.rows):            for j in range(self.cols):                if self.row_cover[i] == 0 and self.col_cover[j] == 0:                    minval = min(self.run_cost[i][j], minval)        for i in range(self.rows):            for j in range(self.cols):                if self.row_cover[i] == 1:                    self.run_cost[i][j] += minval                if self.col_cover[j] == 0:                    self.run_cost[i][j] -= minval        self.step = 4    def step_seven(self):        # print(&quot;done !&quot;)        # print(self.run_cost)        # print(self.mask)        self.running = False    def run(self):        while self.running:            # print(self.step)            self.mp[self.step]()            # print(self.run_cost)            # print(&quot;&quot;)    def get_result(self):        res = []        vis = [0] * self.cols        for i in range(self.rows):            for j in range(self.cols):                if self.mask[i][j] == 1 and vis[j] == 0:                    res.append(j)                    vis[j] = 1                    break        if len(res) != self.rows:            print(&quot;algorithm error ...&quot;)            return None        return resif  __name__ == &quot;__main__&quot;:    cost = [ [1.2, 1., 1.], [1., 1.2, 1.], [1., 1., 1.2]]    mkr = Munkres(cost)    mkr.run()    print(mkr.get_result())ä»¥ä¸Šä¸‰ç§æ–¹å¼ä¸­ï¼Œç¬¬ä¸‰ç§å¹¿æ³›ä½¿ç”¨ç›®æ ‡å…³è”ä¸­ã€‚å…¶å…·ä½“åŸç†è§Munkresâ€™ Assignment Algorithm"
  },
  
  {
    "title": "ç±»å‹è½¬æ¢",
    "url": "/posts/class-cast/",
    "categories": "C++ç¼–ç¨‹",
    "tags": "ç±»å‹è½¬æ¢",
    "date": "2022-02-25 00:00:00 +0800",
    





    "snippet": "C++ å¯¹ç±»å‹è½¬æ¢è¿›è¡Œäº†åˆ†ç±»ï¼Œå¹¶æ–°å¢äº†å››ä¸ªå…³é”®å­—æ¥äºˆä»¥æ”¯æŒï¼Œå®ƒä»¬åˆ†åˆ«æ˜¯ï¼š            å…³é”®å­—      è¯´æ˜                  static_cast      ç”¨äºè‰¯æ€§è½¬æ¢ï¼Œä¸€èˆ¬ä¸ä¼šå¯¼è‡´æ„å¤–å‘ç”Ÿï¼Œé£é™©å¾ˆä½ã€‚              const_cast      ç”¨äº const ä¸é constã€volatile ä¸é volatile ä¹‹é—´çš„è½¬æ¢ã€‚              reinterpret_cast      é«˜åº¦å±é™©çš„è½¬æ¢ï¼Œè¿™ç§è½¬æ¢ä»…ä»…æ˜¯å¯¹äºŒè¿›åˆ¶ä½çš„é‡æ–°è§£é‡Šï¼Œä¸ä¼šå€ŸåŠ©å·²æœ‰çš„è½¬æ¢è§„åˆ™å¯¹æ•°æ®è¿›è¡Œè°ƒæ•´ï¼Œä½†æ˜¯å¯ä»¥å®ç°æœ€çµæ´»çš„ C++ ç±»å‹è½¬æ¢ã€‚              dynamic_cast      å€ŸåŠ© RTTIï¼Œç”¨äºç±»å‹å®‰å…¨çš„å‘ä¸‹è½¬å‹ï¼ˆDowncastingï¼‰ã€‚        å…·ä½“å®è·µ"
  },
  
  {
    "title": "æ™ºèƒ½æŒ‡é’ˆ",
    "url": "/posts/smart-pointer/",
    "categories": "C++ç¼–ç¨‹",
    "tags": "æ™ºèƒ½æŒ‡é’ˆ",
    "date": "2022-02-24 00:00:00 +0800",
    





    "snippet": "RAIIä¸å¼•ç”¨è®¡æ•°  ç°ä»£c++æ•™ç¨‹åœ¨ä¼ ç»Ÿ C++ ä¸­ï¼Œéœ€è¦æ‰‹åŠ¨é‡Šæ”¾èµ„æºï¼Œæœ‰å¯èƒ½å°±å¿˜è®°äº†å»é‡Šæ”¾èµ„æºè€Œå¯¼è‡´æ³„éœ²ã€‚æ‰€ä»¥é€šå¸¸çš„åšæ³•æ˜¯å¯¹äºä¸€ä¸ªå¯¹è±¡è€Œè¨€ï¼Œåœ¨æ„é€ å‡½æ•°çš„æ—¶å€™ç”³è¯·ç©ºé—´ï¼Œè€Œåœ¨ææ„å‡½æ•°ï¼ˆåœ¨ç¦»å¼€ä½œç”¨åŸŸæ—¶è°ƒç”¨ï¼‰çš„æ—¶å€™é‡Šæ”¾ç©ºé—´ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬å¸¸è¯´çš„ RAII èµ„æºè·å–å³åˆå§‹åŒ–æŠ€æœ¯ã€‚å‡¡äº‹éƒ½æœ‰ä¾‹å¤–ï¼Œæˆ‘ä»¬æ€»ä¼šæœ‰éœ€è¦å°†å¯¹è±¡åœ¨è‡ªç”±å­˜å‚¨ä¸Šåˆ†é…çš„éœ€æ±‚ï¼Œåœ¨ä¼ ç»Ÿ C++ é‡Œæˆ‘ä»¬åªå¥½ä½¿ç”¨ new å’Œ delete å» ã€è®°å¾—ã€å¯¹èµ„æºè¿›è¡Œé‡Šæ”¾ã€‚è€Œ C++11 å¼•å…¥äº†æ™ºèƒ½æŒ‡é’ˆçš„æ¦‚å¿µï¼Œä½¿ç”¨äº†å¼•ç”¨è®¡æ•°çš„æƒ³æ³•ï¼Œè®©ç¨‹åºå‘˜ä¸å†éœ€è¦å…³å¿ƒæ‰‹åŠ¨é‡Šæ”¾å†…å­˜ã€‚ è¿™äº›æ™ºèƒ½æŒ‡é’ˆå°±åŒ…æ‹¬ std::shared_ptrã€std::unique_ptrã€std::weak_ptrï¼Œä½¿ç”¨å®ƒä»¬éœ€è¦åŒ…å«å¤´æ–‡ä»¶ ã€‚std::shared_ptrstd::shared_ptræ˜¯ä¸€ç§æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒèƒ½å¤Ÿè®°å½•å¤šå°‘ä¸ªshared_ptrå…±åŒæŒ‡å‘ä¸€ä¸ªå¯¹è±¡ï¼Œä»è€Œæ¶ˆé™¤æ˜¾å¼çš„è°ƒç”¨deleteï¼Œå½“å¼•ç”¨è®¡æ•°å˜ä¸ºé›¶çš„æ—¶å€™å°±ä¼šå°†å¯¹è±¡è‡ªåŠ¨åˆ é™¤ã€‚ä½†è¿˜ä¸å¤Ÿï¼Œå› ä¸ºä½¿ç”¨std::shared_pträ»ç„¶éœ€è¦ä½¿ç”¨newæ¥è°ƒç”¨ï¼Œè¿™ä½¿å¾—ä»£ç å‡ºç°äº†æŸç§ç¨‹åº¦ä¸Šçš„ä¸å¯¹ç§°,std::make_sharedå°±èƒ½å¤Ÿç”¨æ¥æ¶ˆé™¤æ˜¾å¼çš„ä½¿ç”¨ newï¼Œæ‰€ä»¥std::make_sharedä¼šåˆ†é…åˆ›å»ºä¼ å…¥å‚æ•°ä¸­çš„å¯¹è±¡ï¼Œå¹¶è¿”å›è¿™ä¸ªå¯¹è±¡ç±»å‹çš„std::shared_ptræŒ‡é’ˆ.#include &amp;lt;iostream&amp;gt;#include &amp;lt;memory&amp;gt;int main() {    // auto pointer = new int(10); // illegal, no direct assignment    // Constructed a std::shared_ptr    std::shared_ptr&amp;lt;int&amp;gt; pointer = std::make_shared&amp;lt;int&amp;gt;(10);    std::cout &amp;lt;&amp;lt; *pointer &amp;lt;&amp;lt; std::endl; // 11    return 0;}std::shared_ptrå¯ä»¥é€šè¿‡get() æ–¹æ³•æ¥è·å–åŸå§‹æŒ‡é’ˆï¼Œé€šè¿‡reset() æ¥å‡å°‘ä¸€ä¸ªå¼•ç”¨è®¡æ•°ï¼Œå¹¶é€šè¿‡use_count() æ¥æŸ¥çœ‹ä¸€ä¸ªå¯¹è±¡çš„å¼•ç”¨è®¡æ•°ã€‚ä¾‹å¦‚ï¼šauto pointer = std::make_shared&amp;lt;int&amp;gt;(10);auto pointer2 = pointer; // å¼•ç”¨è®¡æ•°+1auto pointer3 = pointer; // å¼•ç”¨è®¡æ•°+1int *p = pointer.get(); // è¿™æ ·ä¸ä¼šå¢åŠ å¼•ç”¨è®¡æ•°std::cout &amp;lt;&amp;lt; &quot;pointer.use_count() = &quot; &amp;lt;&amp;lt; pointer.use_count() &amp;lt;&amp;lt; std::endl; // 3std::cout &amp;lt;&amp;lt; &quot;pointer2.use_count() = &quot; &amp;lt;&amp;lt; pointer2.use_count() &amp;lt;&amp;lt; std::endl; // 3std::cout &amp;lt;&amp;lt; &quot;pointer3.use_count() = &quot; &amp;lt;&amp;lt; pointer3.use_count() &amp;lt;&amp;lt; std::endl; // 3pointer2.reset();std::cout &amp;lt;&amp;lt; &quot;reset pointer2:&quot; &amp;lt;&amp;lt; std::endl;std::cout &amp;lt;&amp;lt; &quot;pointer.use_count() = &quot; &amp;lt;&amp;lt; pointer.use_count() &amp;lt;&amp;lt; std::endl; // 2std::cout &amp;lt;&amp;lt; &quot;pointer2.use_count() = &quot; &amp;lt;&amp;lt; pointer2.use_count() &amp;lt;&amp;lt; std::endl; // 0, pointer2 å·² resetstd::cout &amp;lt;&amp;lt; &quot;pointer3.use_count() = &quot; &amp;lt;&amp;lt; pointer3.use_count() &amp;lt;&amp;lt; std::endl; // 2pointer3.reset();std::cout &amp;lt;&amp;lt; &quot;reset pointer3:&quot; &amp;lt;&amp;lt; std::endl;std::cout &amp;lt;&amp;lt; &quot;pointer.use_count() = &quot; &amp;lt;&amp;lt; pointer.use_count() &amp;lt;&amp;lt; std::endl; // 1std::cout &amp;lt;&amp;lt; &quot;pointer2.use_count() = &quot; &amp;lt;&amp;lt; pointer2.use_count() &amp;lt;&amp;lt; std::endl; // 0std::cout &amp;lt;&amp;lt; &quot;pointer3.use_count() = &quot; &amp;lt;&amp;lt; pointer3.use_count() &amp;lt;&amp;lt; std::endl; // 0, pointer3 å·² resetstd::unique_ptrstd::unique_ptræ˜¯ä¸€ç§ç‹¬å çš„æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒç¦æ­¢å…¶ä»–æ™ºèƒ½æŒ‡é’ˆä¸å…¶å…±äº«åŒä¸€ä¸ªå¯¹è±¡ï¼Œä»è€Œä¿è¯ä»£ç çš„å®‰å…¨ï¼šstd::unique_ptr&amp;lt;int&amp;gt; pointer = std::make_unique&amp;lt;int&amp;gt;(10); // make_unique ä» C++14 å¼•å…¥std::unique_ptr&amp;lt;int&amp;gt; pointer2 = pointer; // éæ³•std::weak_ptrstd::weak_ptræ˜¯ä¸€ç§å¼±å¼•ç”¨ï¼ˆç›¸æ¯”è¾ƒè€Œè¨€std::shared_ptrå°±æ˜¯ä¸€ç§å¼ºå¼•ç”¨ï¼‰ã€‚å¼±å¼•ç”¨ä¸ä¼šå¼•èµ·å¼•ç”¨è®¡æ•°å¢åŠ .std::weak_ptræ²¡æœ‰ * è¿ç®—ç¬¦å’Œ -&amp;gt; è¿ç®—ç¬¦ï¼Œæ‰€ä»¥ä¸èƒ½å¤Ÿå¯¹èµ„æºè¿›è¡Œæ“ä½œï¼Œå®ƒå¯ä»¥ç”¨äºæ£€æŸ¥std::shared_ptræ˜¯å¦å­˜åœ¨ï¼Œå…¶expired()æ–¹æ³•èƒ½åœ¨èµ„æºæœªè¢«é‡Šæ”¾æ—¶ï¼Œä¼šè¿”å› falseï¼Œå¦åˆ™è¿”å› trueï¼›é™¤æ­¤ä¹‹å¤–ï¼Œå®ƒä¹Ÿå¯ä»¥ç”¨äºè·å–æŒ‡å‘åŸå§‹å¯¹è±¡çš„ std::shared_ptr æŒ‡é’ˆï¼Œå…¶ lock() æ–¹æ³•åœ¨åŸå§‹å¯¹è±¡æœªè¢«é‡Šæ”¾æ—¶ï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘åŸå§‹å¯¹è±¡çš„ std::shared_ptr æŒ‡é’ˆï¼Œè¿›è€Œè®¿é—®åŸå§‹å¯¹è±¡çš„èµ„æºï¼Œå¦åˆ™è¿”å›nullptrã€‚ä»£ç å®ç°ä¸€ç§ç®€å•çš„shared_ptrå®ç°#include &amp;lt;string.h&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;memory&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;std::map&amp;lt;uint64_t, uint64_t&amp;gt; ref_count;template &amp;lt;typename T&amp;gt;class MySharedPointer{private:    T *value_;    uint64_t idx_;public:    MySharedPointer(T &amp;amp;value)    {        value_ = new T;        memcpy(value_, &amp;amp;value, sizeof(T));        idx_ = reinterpret_cast&amp;lt;uint64_t&amp;gt;(value_);        ref_count[idx_] += 1;    }    ~MySharedPointer()    {        std::cout &amp;lt;&amp;lt; *value_ &amp;lt;&amp;lt; std::endl;        uint64_t count = ref_count[idx_];        if (count &amp;gt; 0)        {            count -= 1;            ref_count[idx_] -= 1;        }        if (count &amp;lt;= 0)        {            printf(&quot;destory memory ..\\n&quot;);            delete value_;            ref_count.erase(idx_);        }    }    MySharedPointer(MySharedPointer &amp;amp;others)    {        idx_ = others.idx_;        value_ = others.value_;        ref_count[idx_] += 1;    }};struct TestNode{    int a, b;    double c;    friend std::ostream &amp;amp; operator&amp;lt;&amp;lt; (std::ostream &amp;amp;os, TestNode &amp;amp;c)    {        os &amp;lt;&amp;lt; c.a &amp;lt;&amp;lt; &quot;#&quot; &amp;lt;&amp;lt; c.b &amp;lt;&amp;lt; &quot;#&quot; &amp;lt;&amp;lt; c.c ;        return os;    }};int main(int argc, char *argv[]){    TestNode node;    node.a = node.b = node.c = 10;    MySharedPointer&amp;lt;TestNode&amp;gt; a(node);    MySharedPointer&amp;lt;TestNode&amp;gt; b(a);    return 0;}"
  },
  
  {
    "title": "åŠ¨åŠ›å­¦æ¨¡å‹",
    "url": "/posts/dynamics_module/",
    "categories": "æ¨¡å‹, åŠ¨åŠ›å­¦æ¨¡å‹",
    "tags": "æ¨¡å‹, åŠ¨åŠ›å­¦å­¦",
    "date": "2022-02-09 00:00:00 +0800",
    





    "snippet": "è½¦è¾†åŠ¨åŠ›å­¦æ¨¡å‹  åŠ¨åŠ›å­¦æ¨¡å‹åŠ¨åŠ›å­¦ä¸»è¦ç ”ç©¶ä½œç”¨äºç‰©ä½“çš„åŠ›ä¸ç‰©ä½“è¿åŠ¨çš„å…³ç³»ï¼Œè½¦è¾†åŠ¨åŠ›å­¦æ¨¡å‹ä¸€èˆ¬ç”¨äºåˆ†æè½¦è¾†çš„å¹³é¡ºæ€§å’Œè½¦è¾†æ“çºµçš„ç¨³å®šæ€§ã€‚å¯¹äºè½¦æ¥è¯´ï¼Œç ”ç©¶è½¦è¾†åŠ¨åŠ›å­¦ï¼Œä¸»è¦æ˜¯ç ”ç©¶è½¦è¾†è½®èƒåŠå…¶ç›¸å…³éƒ¨ä»¶çš„å—åŠ›æƒ…å†µã€‚æ¯”å¦‚çºµå‘é€Ÿåº¦æ§åˆ¶ï¼Œé€šè¿‡æ§åˆ¶è½®èƒè½¬é€Ÿå®ç°ï¼›æ¨ªå‘èˆªå‘æ§åˆ¶ï¼Œé€šè¿‡æ§åˆ¶è½®èƒè½¬è§’å®ç°ã€‚æ­£å¸¸æƒ…å†µä¸‹ï¼Œè½¦è¾†ä¸Šçš„ä½œç”¨åŠ›æ²¿ç€ä¸‰ä¸ªä¸åŒçš„è½´åˆ†å¸ƒï¼š  çºµè½´ä¸Šçš„åŠ›åŒ…æ‹¬é©±åŠ¨åŠ›å’Œåˆ¶åŠ¨åŠ›ï¼Œä»¥åŠæ»šåŠ¨é˜»åŠ›å’Œæ‹–æ‹½é˜»åŠ›ä½œæ»šæ‘†è¿åŠ¨ï¼›  æ¨ªè½´ä¸Šçš„åŠ›åŒ…æ‹¬è½¬å‘åŠ›ã€ç¦»å¿ƒåŠ›å’Œä¾§é£åŠ›ï¼Œæ±½è½¦ç»•æ¨ªè½´ä½œä¿¯ä»°è¿åŠ¨ï¼›  ç«‹è½´ä¸Šçš„åŠ›åŒ…æ‹¬è½¦è¾†ä¸Šä¸‹æŒ¯è¡æ–½åŠ çš„åŠ›ï¼Œæ±½è½¦ç»•ç«‹è½´ä½œåæ‘†æˆ–è½¬å‘è¿åŠ¨è€Œåœ¨å•è½¦æ¨¡å‹å‡è®¾çš„å‰æä¸‹ï¼Œå†ä½œå¦‚ä¸‹å‡è®¾å³å¯ç®€å•æ­å»ºè½¦è¾†çš„åŠ¨åŠ›å­¦æ¨¡å‹ï¼š  åªè€ƒè™‘çº¯ä¾§åè½®èƒç‰¹æ€§ï¼Œå¿½ç•¥è½®èƒåŠ›çš„çºµæ¨ªå‘è€¦åˆå…³ç³»ï¼›  ç”¨å•è½¦æ¨¡å‹æ¥æè¿°è½¦è¾†çš„è¿åŠ¨ï¼Œä¸è€ƒè™‘è½½è·çš„å·¦å³è½¬ç§»ï¼›  å¿½ç•¥æ¨ªçºµå‘ç©ºæ°”åŠ¨åŠ›å­¦ã€‚å…¶ä¸­éœ€è¦è€ƒè™‘çš„å—åŠ›ç‚¹æœ‰ï¼š  æ¨ªå‘è¿åŠ¨ï¼šæ›²çº¿è¡Œé©¶æ—¶çš„ç¦»å¿ƒåŠ›ï¼Œä¾§ååŠ›ç­‰  çºµå‘è¿åŠ¨ï¼šå—æ€»é©±åŠ¨é˜»åŠ›ã€åŠ é€Ÿã€å‡é€Ÿç­‰çš„å½±å“ã€‚æ€»é©±åŠ¨é˜»åŠ›ç”±æ»šåŠ¨é˜»åŠ›ã€æ‹–æ‹½é˜»åŠ›å’Œå¡åº¦é˜»åŠ›ç­‰æ„æˆã€‚æ¨ªå‘è½¦è¾†åŠ¨åŠ›å­¦å„å˜é‡è¯´æ˜å¦‚ä¸‹ï¼š  $m, m_f, m_r$æ•´è½¦è´¨é‡ï¼Œå‰æŒ‚è´¨é‡ï¼ŒåæŒ‚è´¨é‡  $\\delta_f, \\delta_r$ å‰åè½®è½¬è§’  $\\alpha_f, \\alpha_r$ å‰åè½®æ»‘ç§»è§’  $C_{\\alpha f}, C_{\\alpha r}$ å‰åè½®ä¾§ååˆšåº¦  $\\psiï¼Œ\\dot{\\psi}$ èˆªå‘è§’ï¼Œè§’é€Ÿåº¦  $V_x, V_y$ çºµæ¨ªå‘é€Ÿåº¦  $F_{yf},F_{yr}$ å‰åè½®yæ–¹å‘å—åŠ›  $F_{cf},F_{cr}$ å‰åè½®ä¾§å‘åŠ›  $l_f, l_r$ å‰åè½´é•¿åº¦  $I_z=m_f * l_{f}^2 + m_r * l_{r}^2$è½¬åŠ¨æƒ¯é‡åœ¨yè½´ä¸Šï¼š\\(\\begin{aligned}    ma_y = F_{yf} + F_{y_r} \\qquad(1)\\end{aligned}\\)åœ¨zè½´ä¸Šï¼š\\(\\begin{aligned}    I_z\\ddot{\\psi} = l_f * F_{yf} - l_r * F_{yr} \\qquad(2)\\end{aligned}\\)yè½´æ–¹å‘åŠ é€Ÿç”±yè½´æ–¹å‘ä½ç§»ç›¸å…³çš„åŠ é€Ÿåº¦$\\ddot{y}$å’Œå‘å¿ƒåŠ é€Ÿåº¦$V_x\\dot{\\psi}$æ„æˆï¼š\\(\\begin{aligned}    a_y = \\ddot{y} + V_x\\dot{\\psi} \\qquad(3)\\end{aligned}\\)å³:\\(\\begin{aligned}    m(\\ddot{y} + V_x\\dot{\\psi}) =  F_{yf} + F_{y_r} \\qquad(4)\\end{aligned}\\)è½®èƒæ”¶åˆ°æ¨ªå‘å‹åŠ›ï¼Œä¼šäº§ç”Ÿå¾ˆå°çš„æ»‘ç§»è§’åˆ™å‰åè½®æ»‘ç§»è§’(é»˜è®¤å‰è½®é©±åŠ¨ï¼Œåè½®ä¸åŠ¨å³åè½®åç§»è§’ä¸º0):\\(\\begin{aligned}    \\alpha_f &amp;amp;= \\delta_f - \\theta_{vf} \\\\    \\alpha_r &amp;amp;= - \\theta_{vr}\\end{aligned}\\)å³å‰åè½®æ‰€å—æ¨ªå‘åŠ›ä¸ºï¼š\\(\\begin{aligned}    F_{yf} &amp;amp;= 2C_{\\alpha f}(\\delta_f - \\theta_{vf}) \\qquad(5)\\\\    F_{yr} &amp;amp;= 2C_{\\alpha r}(-\\theta_{vr}) \\qquad(6) \\\\\\end{aligned}\\)å…¶ä¸­$\\theta_{vf},\\theta_{vr}å¯ä»¥é€šè¿‡yæ–¹å‘é€Ÿåº¦å’Œåˆ‡çº¿é€Ÿåº¦è®¡ç®—$ï¼š\\(\\begin{aligned}    \\tan(\\theta_{vf}) = \\dfrac{V_y + l_f\\dot{\\psi}}{V_x} \\\\    \\tan(\\theta_{vr}) = \\dfrac{V_y - l_r\\dot{\\psi}}{V_x}\\end{aligned}\\)åœ¨å°è§’åº¦ä¸‹ï¼Œæ­£åˆ‡å‡½æ•°å’Œæ­£æ¯”ä¾‹å‡½æ•°ç›¸ä¼¼ï¼Œå› æ­¤å¯ä»¥è¿‘ä¼¼ä¸ºï¼š\\(\\begin{aligned}    \\theta_{vf} = \\dfrac{V_y + l_f\\dot{\\psi}}{V_x} \\qquad(7) \\\\    \\theta_{vr} = \\dfrac{V_y - l_r\\dot{\\psi}}{V_x} \\qquad(8)\\end{aligned}\\)å°†(5),(6),(7),(8)å¸¦å…¥(1)(2)ä¸­å¾—åˆ°:æ•´ç†å¾—åˆ°åŠ¨åŠ›å­¦æ¨¡å‹:ä»£ç å®ç°&#39;&#39;&#39;åŠ¨åŠ›å­¦æ¨¡å‹æ¨¡æ‹Ÿ&#39;&#39;&#39;import mathimport scipy.linalg as lafrom numpy import fromiterL = 4  # [m]Lr = L / 2.0  # [m]Lf = L - LrCf = 1600.0 * 2.0  # N/radCr = 1700.0 * 2.0  # N/radIz = 1500 * 8  # kg * m^2 =  m_front * l_f^2 + m_rear * l_r^2M = 1500.0 # kgclass DynamicsModel(object):    def __init__(self, x=0.0, y=0.0, yaw=0.0, vx=0.01, vy=0.0, omega=0.0):        self.x = x        self.y = y        self.yaw = yaw        self.vx = vx        self.vy = vy        self.omega = omega    def update_state(self, a, delta, dt=0.1):        self.x = self.x + self.vx * math.cos(self.yaw) * dt - self.vy * math.sin(self.yaw) * dt        self.y = self.y + self.vx * math.sin(self.yaw) * dt + self.vy * math.cos(self.yaw) * dt        self.yaw = self.yaw + self.omega * dt        Ffy = -Cf * math.atan2(((self.vy + Lf * self.omega) / self.vx - delta), 1.0)        Fry = -Cr * math.atan2((self.vy - Lr * self.omega) / self.vx, 1.0)                self.vx = self.vx + (a - Ffy * math.sin(delta) / M + self.vy * self.omega) * dt        self.vy = self.vy + (Fry / M + Ffy * math.cos(delta) / M - self.vx * self.omega) * dt        self.omega = self.omega + (Ffy * Lf * math.cos(delta) - Fry * Lr) / Iz * dt        return self    def get_state(self):        return self.x, self.y, self.yaw, self.v"
  },
  
  {
    "title": "æ›²ç‡å’Œèˆªå‘çš„è®¡ç®—",
    "url": "/posts/curvature_heading/",
    "categories": "æ•°å­¦",
    "tags": "æ›²ç‡, èˆªå‘",
    "date": "2022-01-07 00:00:00 +0800",
    





    "snippet": "æ›²ç‡å’Œèˆªå‘  æ›²ç‡èˆªå‘æ›²çº¿çš„æ›²ç‡ï¼ˆcurvatureï¼‰å°±æ˜¯é’ˆå¯¹æ›²çº¿ä¸ŠæŸä¸ªç‚¹çš„åˆ‡çº¿æ–¹å‘è§’å¯¹å¼§é•¿çš„è½¬åŠ¨ç‡ï¼Œé€šè¿‡å¾®åˆ†æ¥å®šä¹‰ï¼Œè¡¨æ˜æ›²çº¿åç¦»ç›´çº¿çš„ç¨‹åº¦ã€‚æ•°å­¦ä¸Šè¡¨æ˜æ›²çº¿åœ¨æŸä¸€ç‚¹çš„å¼¯æ›²ç¨‹åº¦çš„æ•°å€¼ã€‚æ›²ç‡è¶Šå¤§ï¼Œè¡¨ç¤ºæ›²çº¿çš„å¼¯æ›²ç¨‹åº¦è¶Šå¤§ã€‚æ›²ç‡çš„å€’æ•°å°±æ˜¯æ›²ç‡åŠå¾„ã€‚è®¾æ›²çº¿ç›´è§’åæ ‡æ–¹ç¨‹$y = f(x)$ä¸”å…·æœ‰äºŒé˜¶å¯¼æ•°ï¼Œé‚£ä¹ˆæ›²ç‡å…¬å¼ä¸ºï¼š\\(\\begin{aligned}    K = \\dfrac{|y^{&#39;&#39;}|}{(1+y^{&#39;2})^{\\dfrac{3}{2}} }\\end{aligned}\\)èˆªå‘ä¸ºï¼š\\(\\begin{aligned}    Yaw = \\arctan(y&#39;)\\end{aligned}\\)å¦‚æœæ›²çº¿æ˜¯ç”±å‚æ•°æ–¹ç¨‹\\(\\begin{aligned}    x &amp;amp;= \\psi(t) \\\\    y &amp;amp;= \\omega(t)\\end{aligned}\\)é‚£ä¹ˆæ›²ç‡ä¸º:\\(\\begin{aligned}  K = \\dfrac{|\\psi&#39;(t)\\omega&#39;&#39;(t) - \\omega&#39;(t)\\psi&#39;&#39;(t)|}{[\\psi^{&#39;2}(t) + \\omega^{&#39;2}(t)]^{\\dfrac{3}{2}}}  \\end{aligned}\\)é‚£ä¹ˆèˆªå‘ä¸º:\\(\\begin{aligned}    Yaw = \\arctan(\\dfrac{\\omega&#39;(t)}{\\psi&#39;(t)})\\end{aligned}\\)é™„å½•æ±‚å¯¼å…¬å¼ï¼š\\(\\begin{aligned}    \\dfrac{dy}{dx} &amp;amp;= \\dfrac{\\dfrac{dy}{dt}}{\\dfrac{dx}{dt}} = \\dfrac{\\omega&#39;(t)}{\\psi&#39;(t)} \\\\    \\dfrac{d^2y}{dx^2} &amp;amp;= \\dfrac{d}{dt}(\\dfrac{dy}{dx})(\\dfrac{1}{\\dfrac{dx}{dt}}) = (\\dfrac{dy}{dx})&#39;(\\dfrac{1}{\\dfrac{dx}{dt}}) \\\\    &amp;amp;=  (\\dfrac{\\omega&#39;(t)}{\\psi&#39;(t)})&#39;(\\dfrac{1}{\\psi&#39;(t)}) \\\\    &amp;amp;= \\dfrac{\\omega^{&#39;2}(t)\\psi^{&#39;}(t) - \\psi^{&#39;2}(t)\\omega^{&#39;}(t)}{\\psi^{&#39;3}(t)}\\end{aligned}\\)"
  },
  
  {
    "title": "ä¸‰æ¬¡æ ·æ¡æ’å€¼",
    "url": "/posts/cubic_spline/",
    "categories": "ç®—æ³•, æ§åˆ¶ç®—æ³•",
    "tags": "æ ·æ¡æ’å€¼",
    "date": "2022-01-04 00:00:00 +0800",
    





    "snippet": "ä¸‰æ¬¡æ ·æ¡(cubic spline)æ’å€¼  æ ·æ¡æ’å€¼ PythonRoboticså·²çŸ¥æŸäº›ç‚¹è€Œä¸çŸ¥é“å…·ä½“æ–¹ç¨‹æ—¶å€™ï¼Œé€šå¸¸æœ‰æ‹Ÿåˆå’Œæ’å€¼ä¸¤ç§åšæ³•ã€‚æ‹Ÿåˆä¸è¦æ±‚æ–¹ç¨‹é€šè¿‡æ‰€æœ‰çš„å·²çŸ¥ç‚¹ï¼Œæ•´ä½“è¶‹åŠ¿ä¸€è‡´ã€‚æ’å€¼åˆ™æ˜¯æ¯ä¸ªå·²çŸ¥ç‚¹éƒ½å¿…ä¼šç©¿è¿‡ï¼Œä½†æ˜¯é«˜é˜¶ä¼šå‡ºç°é¾™æ ¼ç°è±¡ï¼Œæ‰€ä»¥ä¸€èˆ¬é‡‡ç”¨åˆ†æ®µæ’å€¼ã€‚è€Œä¸‰æ¬¡æ ·æ¡æ’å€¼åˆ™æ˜¯åˆ†æ®µé‡‡ç”¨ä¸€å…ƒä¸‰æ¬¡æ–¹ç¨‹è¿›è¡Œæ’å€¼é—®é¢˜å®šä¹‰å·²çŸ¥n+1ä¸ªç‚¹$[(x_0, y_0), (x_1, y_1),â€¦,(x_{n-1}, y_{n-1}), (x_n, y_n)]$ï¼Œnä¸ªåŒºé—´æ®µä¸º$[(x0, x1), (x1, x2),â€¦,(x_{n-1}, x_n)]$ä¸‰æ¬¡æ ·æ¡å°±æ˜¯è¯´æ¯ä¸ªå°åŒºé—´çš„æ›²çº¿æ˜¯ä¸€ä¸ªä¸‰æ¬¡æ–¹ç¨‹ï¼Œä¸‰æ¬¡æ ·æ¡æ–¹ç¨‹æ»¡è¶³ä»¥ä¸‹æ¡ä»¶:  åœ¨æ¯ä¸ªåˆ†æ®µå°åŒºé—´$[x_i, x_{i+1}], S(x)=S_i(x) = a_i + b_ix + c_ix^2 + d_ix^3$  æ»¡è¶³æ’å€¼æ¡ä»¶ï¼Œå³$S(x_i) = y_i\\qquad(i=0,1,â€¦,n)$  æ›²çº¿å…‰æ»‘ï¼Œå³$S(x), Sâ€™(x), S^{â€˜â€™}(x)$è¿ç»­æ¯ä¸ªåŒºé—´$S_i(x)$éƒ½æœ‰ä¸ªå››ä¸ªæœªçŸ¥æ•°$(a_i, b_i, c_i, d_i)$,æœ‰nä¸ªå°åŒºé—´ï¼Œåˆ™æœ‰4nä¸ªæœªçŸ¥æ•°ï¼Œè¦è§£å‡ºè¿™äº›æœªçŸ¥æ•°ï¼Œåˆ™æˆ‘ä»¬éœ€è¦4nä¸ªæ–¹ç¨‹æ¥æ±‚è§£ã€‚æ±‚è§£  æ‰€æœ‰n-1ä¸ªå†…éƒ¨ç«¯ç‚¹éƒ½æ»¡è¶³$S_i(x_{i+1}) = y_{i+1}, S_{i+1}(x_{i+1})=y_{i+1}$,åˆ™æœ‰2(n-1)ä¸ªæ–¹ç¨‹ï¼Œå†åŠ ä¸Šé¦–å°¾ä¸¤ä¸ªç«¯ç‚¹åˆ†åˆ«æ»¡è¶³ç¬¬ä¸€ä¸ªæ–¹ç¨‹å’Œæœ€åä¸€ä¸ªæ–¹ç¨‹ï¼Œåˆ™æœ‰2nä¸ªæ–¹ç¨‹ã€‚  å…¶æ¬¡n-1ä¸ªå†…éƒ¨ç‚¹çš„ä¸€é˜¶å¯¼æ•°åº”è¯¥æ˜¯è¿ç»­çš„ï¼Œå³åœ¨ç¬¬iåŒºé—´çš„æœ«ç‚¹å’Œç¬¬i+1åŒºé—´çš„èµ·ç‚¹æ˜¯åŒä¸€ä¸ªç‚¹ï¼Œå®ƒä»¬çš„ä¸€é˜¶å¯¼æ•°åº”è¯¥ä¹Ÿç›¸ç­‰,å³$S_{i}^{â€˜}(x_{i+1}) = S_{i+1}^{â€˜}(x_{i+1})$, åˆ™æœ‰n-1ä¸ªæ–¹ç¨‹ã€‚      å…¶æ¬¡n-1ä¸ªå†…éƒ¨ç‚¹çš„äºŒé˜¶å¯¼æ•°åº”è¯¥æ˜¯è¿ç»­çš„ï¼Œå³åœ¨ç¬¬iåŒºé—´çš„æœ«ç‚¹å’Œç¬¬i+1åŒºé—´çš„èµ·ç‚¹æ˜¯åŒä¸€ä¸ªç‚¹ï¼Œå®ƒä»¬çš„äºŒé˜¶å¯¼æ•°åº”è¯¥ä¹Ÿç›¸ç­‰,å³$S_{i}^{â€˜â€™}(x_{i+1})=S_{i+1}^{â€˜â€™}(x_{i+1})$åˆ™æœ‰n-1ä¸ªæ–¹ç¨‹ã€‚    è¾¹ç•Œæ¡ä»¶æŒ‡å®šæœ€åä¸¤ä¸ªæ–¹ç¨‹          è‡ªç„¶è¾¹ç•Œ(Natural Spline)ï¼šæŒ‡å®šç«¯ç‚¹äºŒé˜¶å¯¼æ•°ä¸º0, $S_{0}^{â€˜â€™}(x_0) = 0 = S_{n}^{â€˜â€™}(x_{n})$      å›ºå®šè¾¹ç•Œ ( Clamped Spline ): æŒ‡å®šç«¯ç‚¹ä¸€é˜¶å¯¼æ•°ï¼Œè¿™é‡Œåˆ†åˆ«å®šä¸ºAå’ŒB,$S_{0}^{â€˜}(x_0) = A,S_{n}^{â€˜}(x_{n}) = B$      éæ‰­ç»“è¾¹ç•Œ( Not-A-Knot Spline ): å¼ºåˆ¶ç¬¬ä¸€ä¸ªæ’å€¼ç‚¹çš„ä¸‰é˜¶å¯¼æ•°å€¼ç­‰äºç¬¬äºŒä¸ªç‚¹çš„ä¸‰é˜¶å¯¼æ•°å€¼ï¼Œæœ€åç¬¬ä¸€ä¸ªç‚¹çš„ä¸‰é˜¶å¯¼æ•°å€¼ç­‰äºå€’æ•°ç¬¬äºŒä¸ªç‚¹çš„ä¸‰é˜¶å¯¼æ•°å€¼.å³ $S_{0}^{â€˜â€™â€™}(x_0) = S_{1}^{â€˜â€™â€™}(x_1), S_{n-1}^{â€˜â€™â€™}(x_{n-1}) = S_{n}^{â€˜â€™â€™}(x_n)$      ç”±ä»¥ä¸Š3ç‚¹å’Œè¾¹ç•Œè¾¹ç•Œæ¡ä»¶ä¾¿å¯ä»¥å¾—åˆ°4nä¸ªæ–¹ç¨‹ã€‚å…·ä½“æ¨å¯¼æ„é€ $S_i(x), Sâ€™_i(x), Sâ€™â€˜_i(x)$\\(\\begin{aligned}    S_i(x) &amp;amp;= a_i + b_i(x-x_i) + c_i(x-x_i)^2 + d_i(x-x_i)^3 \\qquad(1)\\\\    S&#39;_i(x) &amp;amp;= b_i + 2c_i(x-x_i) + 3d_i(x-x_i)^2 \\\\    S&#39;&#39;_i(x) &amp;amp;= 2c_i + 6d_i(x-x_i) \\\\\\end{aligned}\\)  ç”±$(1)$å¾—\\(\\begin{aligned} S_i(x_i) &amp;amp;= a_i + b_i(x_i-x_i) + c_i(x_i-x_i)^2 + d_i(x_i-x_i)^3 = y_i \\\\ \\therefore a_i &amp;amp;= y_i \\\\\\end{aligned}\\)  ç”¨$h_i=x_{i+1} - x_i$è¡¨ç¤ºæ­¥é•¿\\(\\begin{aligned} S_i(x_{i+1}) &amp;amp;= a_i + b_i(x_{i+1}-x_i) + c_i(x_{i+1}-x_i)^2 + d_i(x_{i+1}-x_i)^3 = y_{i+1} \\\\ S_i(x_{i+1}) &amp;amp;= a_i + h_ib_i + h_i^2c_i + h_i^3d_i = y_{i+1} \\\\ \\therefore a_i + h_ib_i + h_i^2c_i + h_i^3d_i &amp;amp;= y_{i+1} \\\\\\end{aligned}\\)  ç”±$S_{i}^{â€˜}(x_{i+1})=S_{i+1}^{â€˜}(x_{i+1})$å¾—åˆ°ï¼š\\(\\begin{aligned} S&#39;_i(x_{i+1}) &amp;amp;= b_i + 2c_i(x_{i+1}-x_i) + 3d_i(x_{i+1}-x_i)^2  = b_i + 2h_ic_i +3h_i^2d_i\\\\ S&#39;_{i+1}(x_{i+1}) &amp;amp;= b_{i+1} + 2c_{i+1}(x_{i+1}-x_{i+1}) + 3d_{i+1}(x_{i+1}-x_{i+1})^2 \\\\ \\therefore b_i + 2h_ic_i +3h_i^2d_i &amp;amp;= b_{i+1} \\\\\\end{aligned}\\)  ç”±$S_{i}^{â€˜â€™}(x_{i+1})=S_{i+1}^{â€˜â€™}(x_{i+1})$å¾—åˆ°ï¼š\\(\\begin{aligned} S&#39;&#39;_i(x_{i+1}) &amp;amp;= 2c_i + 6d_i(x_{i+1}-x_i) \\\\ S&#39;&#39;_{i+1}(x_{i+1}) &amp;amp;= 2c_{i+1} + 6d_{i+1}(x_{i+1}-x_{i+1}) \\\\ \\therefore 2c_i + 6h_id_i &amp;amp;= 2c_{i+1} \\\\\\end{aligned}\\)  è®¾$m_i = Sâ€™â€˜_i(x_i) = 2*c_i$å¾—åˆ°ï¼š\\(\\begin{aligned} 2c_i + 6h_id_i &amp;amp;= 2c_{i+1} \\\\ 2m_i + 6h_id_i &amp;amp;= m_{i+1} \\\\ \\therefore d_i &amp;amp;= \\dfrac{m_{i+1} - m_i}{6h_i}\\\\ c_i &amp;amp;= \\dfrac{1}{2}m_i \\\\\\end{aligned}\\)  å°†$a_i,c_i,d_i$ä»£å…¥$a_i + h_ib_i + h_i^2c_i + h_i^3d_i = y_{i+1}$å¯å¾—ï¼š\\(\\begin{aligned} y_i + h_ib_i + h^2_i*(\\dfrac{1}{2}m_i) + h^3_i*(\\dfrac{m_{i+1} - m_i}{6h_i}) &amp;amp;= y_{i+1} \\\\ \\therefore b_i &amp;amp;= \\dfrac{y_{i+1} - y_i}{h_i} - \\dfrac{h_i}{2}m_i - \\dfrac{h_i}{6}(m_{i+1} - m_i)  \\\\\\end{aligned}\\)  å°†$a_i,b_i,c_i,d_i$ä»£å…¥$b_i + 2h_ic_i +3h_i^2d_i = b_{i+1}$å¯å¾—:\\(\\begin{aligned} \\dfrac{y_{i+1} - y_i}{h_i} - \\dfrac{h_i}{2}m_i - \\dfrac{h_i}{6}(m_{i+1} - m_i) + 2h_i(\\dfrac{1}{2}m_i) + 3h_i^2(\\dfrac{m_{i+1} - m_i}{6h_i}) &amp;amp;= \\dfrac{y_{i+2} - y_{i+1}}{h_{i+1}} - \\dfrac{h_{i+1}}{2}m_{i+1} - \\dfrac{h_{i+1}}{6}(m_{i+2} - m_{i+1}) \\\\ h_im_i + 2(h_i + h_{i+1})m_{i+1} + h_{i+1}m_{i+2} &amp;amp;= 6(\\dfrac{y_{i+2} - y_{i+1}}{h_{i+1}} - \\dfrac{y_{i+1} - y_i}{h_i}) \\\\ \\end{aligned} \\\\\\)          å…¶ä¸­å·¦è¾¹è·Ÿ$m_i$ç›¸å…³ï¼Œè€Œå³è¾¹éƒ½æ˜¯å·²çŸ¥çš„ï¼Œå› æ­¤å¯ä»¥æ„é€ ä¸€ä¸ªä»¥mä¸ºæœªçŸ¥æ•°çš„çº¿æ€§æ–¹ç¨‹ç»„            åœ¨è‡ªç„¶è¾¹ç•Œæ¡ä»¶æ—¶, $m_0 = 0, m_n = 0$:    å› æ­¤å¯ä»¥é«˜æ–¯æ¶ˆå…ƒ,Givens Rotationç­‰æ–¹å¼æ±‚å¾—$m$ä»è€Œå¾—åˆ°$a_i,b_i,c_i,d_i$        åœ¨å¤¹æŒè¾¹ç•Œæ¡ä»¶ä¸‹ï¼š        åœ¨éæ‰­ç»“è¾¹ç•Œæ¡ä»¶ä¸‹ï¼š  åœ¨è‡ªç„¶æ¡ä»¶ä¸‹ï¼Œé™¤äº†æ„é€ çŸ©é˜µæ˜¾æ€§çš„æ±‚è§£$Ax=b$ï¼Œè¿˜å¯ä»¥é€šè¿‡æ•°å€¼åˆ†æ[numerical_analysis_9th.pdf page149]çš„æ–¹æ³•æ±‚è§£:ä»£ç å®ç°import mathimport numpy as npimport bisectclass Spline:    &quot;&quot;&quot;    Cubic Spline class    &quot;&quot;&quot;    def __init__(self, x, y):        self.b, self.c, self.d, self.w = [], [], [], []        self.x = x        self.y = y        self.nx = len(x)  # dimension of x        h = np.diff(x) # x(i+1) - x(i)        # calc coefficient c        self.a = [iy for iy in y]        # Ax = B        A = self.__calc_A(h)         B = self.__calc_B(h)        # è§£Ax = Bï¼Œå¾—åˆ°çš„m = 2Ã—cï¼Œå†æ„å»ºBçš„æ—¶å€™é™¤äº†2,æ‰€ä»¥æ­¤å¤„m = c        self.c = np.linalg.solve(A, B)        #  print(self.c1)        # calc spline coefficient b and d        for i in range(self.nx - 1):            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0            self.b.append(tb)    def calc(self, t):        &quot;&quot;&quot;        Calc position        if t is outside of the input x, return None        &quot;&quot;&quot;        if t &amp;lt; self.x[0]:            return None        elif t &amp;gt; self.x[-1]:            return None        i = self.__search_index(t)        dx = t - self.x[i]        result = self.a[i] + self.b[i] * dx + \\            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0        return result    def calcd(self, t):        &quot;&quot;&quot;        Calc first derivative        if t is outside of the input x, return None        &quot;&quot;&quot;        if t &amp;lt; self.x[0]:            return None        elif t &amp;gt; self.x[-1]:            return None        i = self.__search_index(t)        dx = t - self.x[i]        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0        return result    def calcdd(self, t):        &quot;&quot;&quot;        Calc second derivative        &quot;&quot;&quot;        if t &amp;lt; self.x[0]:            return None        elif t &amp;gt; self.x[-1]:            return None        i = self.__search_index(t)        dx = t - self.x[i]        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx        return result    def __search_index(self, x):        &quot;&quot;&quot;        search data segment index        &quot;&quot;&quot;        return bisect.bisect(self.x, x) - 1    def __calc_A(self, h):        &quot;&quot;&quot;        calc matrix A for spline coefficient c        &quot;&quot;&quot;        A = np.zeros((self.nx, self.nx))        A[0, 0] = 1.0        for i in range(self.nx - 1):            if i != (self.nx - 2):                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])            A[i + 1, i] = h[i]            A[i, i + 1] = h[i]        A[0, 1] = 0.0        A[self.nx - 1, self.nx - 2] = 0.0        A[self.nx - 1, self.nx - 1] = 1.0        #  print(A)        return A    def __calc_B(self, h):        &quot;&quot;&quot;        calc matrix B for spline coefficient c        &quot;&quot;&quot;        B = np.zeros(self.nx)        for i in range(self.nx - 2):            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]        return Bclass NumericalAnalysisSpline(Spline):    def __init__(self, x, y):        self.nx = len(x)        self.a, self.b = np.zeros(self.nx), np.zeros(self.nx)        self.c, self.d = np.zeros(self.nx), np.zeros(self.nx)                self.x = np.copy(x)        self.a = np.copy(y)                self.__cal()    def __cal(self):        l = np.zeros(self.nx)        u = np.zeros(self.nx)        z = np.zeros(self.nx)        A = np.zeros(self.nx)        h = np.diff(self.x)        n = self.nx - 1        for i in range(1, n):            A[i] = 3 * (self.a[i + 1] - self.a[i]) / h[i] - 3 * (self.a[i] - self.a[i - 1]) / h[i - 1];        l[0] = 1            for i in range(1, n):            l[i] = 2 * (self.x[i + 1] - self.x[i - 1]) - h[i - 1] * u[i - 1]            u[i] = h[i] / l[i];            z[i] = (A[i] - h[i - 1] * z[i - 1]) / l[i]        l[n] = 1        for j in range(n-1, -1, -1):            self.c[j] = z[j] - u[j] * self.c[j + 1]            self.b[j] = (self.a[j + 1] - self.a[j]) / h[j] - h[j] * (self.c[j + 1] + 2 * self.c[j]) / 3            self.d[j] = (self.c[j + 1] - self.c[j]) / (3 * h[j])å…¶ä¸­2dæ ·æ¡æ’å€¼(å‚æ•°æ–¹ç¨‹)çš„å®ç°å¦‚ä¸‹ï¼Œæœ‰å…³èˆªå‘å’Œæ›²ç‡çš„è§£é‡Šè§å¯¹åº”çš„æ–‡ç« class Spline2D:    &quot;&quot;&quot;    2D Cubic Spline class    &quot;&quot;&quot;    def __init__(self, x, y):        self.s = self.__calc_s(x, y)        self.sx = Spline(self.s, x)        self.sy = Spline(self.s, y)    def __calc_s(self, x, y):        dx = np.diff(x)        dy = np.diff(y)        # print(&quot;dx:&quot;, dx)        # print(&quot;dy:&quot;, dy)        self.ds = np.hypot(dx, dy)        # print(&quot;ds:&quot;, self.ds)        s = [0]        s.extend(np.cumsum(self.ds))        return s    def calc_position(self, s):        &quot;&quot;&quot;        calc position        &quot;&quot;&quot;        x = self.sx.calc(s)        y = self.sy.calc(s)        return x, y    def calc_curvature(self, s):        &quot;&quot;&quot;        calc curvature        &quot;&quot;&quot;        dx = self.sx.calcd(s)        ddx = self.sx.calcdd(s)        dy = self.sy.calcd(s)        ddy = self.sy.calcdd(s)        k = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))        return k    def calc_yaw(self, s):        &quot;&quot;&quot;        calc yaw        &quot;&quot;&quot;        dx = self.sx.calcd(s)        dy = self.sy.calcd(s)        yaw = math.atan2(dy, dx)        return yawdef calc_spline_course(x, y, ds=0.1):    sp = Spline2D(x, y)    s = list(np.arange(0, sp.s[-1], ds))    rx, ry, ryaw, rk = [], [], [], []    for i_s in s:        ix, iy = sp.calc_position(i_s)        rx.append(ix)        ry.append(iy)        ryaw.append(sp.calc_yaw(i_s))        rk.append(sp.calc_curvature(i_s))    return rx, ry, ryaw, rk, s"
  },
  
  {
    "title": "LQRè°ƒèŠ‚å™¨",
    "url": "/posts/LQR/",
    "categories": "ç®—æ³•, æ§åˆ¶ç®—æ³•",
    "tags": "LQR, åé¦ˆæ§åˆ¶",
    "date": "2022-01-03 00:00:00 +0800",
    





    "snippet": "LQRè°ƒèŠ‚å™¨  LQRç™¾åº¦ç™¾ç§‘ LQR  LQR (linear quadratic regulator)å³çº¿æ€§äºŒæ¬¡å‹è°ƒèŠ‚å™¨ï¼Œå…¶å¯¹è±¡æ˜¯ç°ä»£æ§åˆ¶ç†è®ºä¸­ä»¥çŠ¶æ€ç©ºé—´å½¢å¼ç»™å‡ºçš„çº¿æ€§ç³»ç»Ÿï¼Œè€Œç›®æ ‡å‡½æ•°ä¸ºå¯¹è±¡çŠ¶æ€å’Œæ§åˆ¶è¾“å…¥çš„äºŒæ¬¡å‹å‡½æ•°ã€‚LQRæœ€ä¼˜è®¾è®¡æ˜¯æŒ‡è®¾è®¡å‡ºçš„çŠ¶æ€åé¦ˆæ§åˆ¶å™¨ Kè¦ä½¿äºŒæ¬¡å‹ç›®æ ‡å‡½æ•°J å–æœ€å°å€¼ï¼Œè€Œ Kç”±æƒçŸ©é˜µQ ä¸ R å”¯ä¸€å†³å®šï¼Œæ•…æ­¤ Qã€ R çš„é€‰æ‹©å°¤ä¸ºé‡è¦ã€‚LQRç†è®ºæ˜¯ç°ä»£æ§åˆ¶ç†è®ºä¸­å‘å±•æœ€æ—©ä¹Ÿæœ€ä¸ºæˆç†Ÿçš„ä¸€ç§çŠ¶æ€ç©ºé—´è®¾è®¡æ³•ã€‚ç‰¹åˆ«å¯è´µçš„æ˜¯ï¼ŒLQRå¯å¾—åˆ°çŠ¶æ€çº¿æ€§åé¦ˆçš„æœ€ä¼˜æ§åˆ¶è§„å¾‹ï¼Œæ˜“äºæ„æˆé—­ç¯æœ€ä¼˜æ§åˆ¶ã€‚æ¨å¯¼å‡è®¾æœ‰ä¸€ä¸ªçº¿æ€§ç³»ç»Ÿèƒ½ç”¨çŠ¶æ€å‘é‡çš„å½¢å¼è¡¨ç¤º:\\(\\begin{aligned}    \\dot{x} = Ax + Bu \\qquad(1)\\end{aligned}\\)å…¶ä¸­$x(t)\\in R^n, u(t)\\in R^m$,å…¶ä¸­xä¸ºçŠ¶æ€å˜é‡å¯è§‚æµ‹ï¼Œuä¸ºæ§åˆ¶çŸ©é˜µã€‚å…¨çŠ¶æ€åé¦ˆæ§åˆ¶å…¨çŠ¶æ€åé¦ˆæ§åˆ¶ç³»ç»Ÿå¦‚ä¸‹æ‰€ç¤ºï¼šçŠ¶æ€åé¦ˆæ§åˆ¶å™¨ä¸ºï¼š\\(\\begin{aligned}    u = -Kx\\end{aligned}\\)ä½¿å¾—é—­ç¯ç³»ç»Ÿèƒ½å¤Ÿæ»¡è¶³æˆ‘ä»¬æœŸæœ›çš„æ€§èƒ½ã€‚æˆ‘ä»¬æŠŠè¿™ç§æ§åˆ¶ä»£å…¥$(1)$å¾—åˆ°:\\(\\begin{aligned}    \\dot{x} = (A - BK)x = A_cx\\qquad(2)\\end{aligned}\\)å¯¹äº$(1)$å¼çš„å¼€ç¯ç³»ç»Ÿï¼Œç”±ç°ä»£æ§åˆ¶ç†è®ºæˆ‘ä»¬çŸ¥é“å¼€ç¯ä¼ é€’å‡½æ•°çš„æç‚¹å°±æ˜¯ç³»ç»ŸçŸ©é˜µAçš„ç‰¹å¾å€¼ã€‚ç°åœ¨å˜æˆäº†$(2)$çš„é—­ç¯å½¢å¼ï¼ŒçŠ¶æ€å˜æ¢çŸ©é˜µ$A$å˜æˆäº†$(A-BK)$ã€‚å› æ­¤é€šè¿‡é…ç½®åé¦ˆçŸ©é˜µ$K$ï¼Œå¯ä»¥ä½¿å¾—é—­ç¯ç³»ç»Ÿçš„æç‚¹è¾¾åˆ°æˆ‘ä»¬æœŸæœ›çš„çŠ¶æ€.LQRçš„ç›®æ ‡(æŸå¤±ï¼Œèƒ½é‡)å‡½æ•°ä¸€èˆ¬è®¾è®¡å¦‚ä¸‹ï¼š\\(\\begin{aligned}    J = \\dfrac{1}{2}\\int^{\\infty}_0(x^TQx + u^TRu)dt \\qquad(3)\\end{aligned}\\)å…¶ä¸­$Q,R$é€šå¸¸å–ä¸ºå¯¹è§’é˜µï¼Œ$Q$ä¸ºåŠæ­£å®šçš„çŠ¶æ€åŠ æƒçŸ©é˜µ, $R$ä¸ºæ­£å®šçš„æ§åˆ¶åŠ æƒçŸ©é˜µ.ä¸ºä»€ä¹ˆèƒ½é‡å‡½æ•°(æˆ–ç§°ç³»ç»Ÿçš„ç›®æ ‡å‡½æ•°)å¾—è®¾è®¡æˆè¿™ä¸ªæ ·å­å‘¢ï¼Ÿ    é¦–å…ˆå‡è®¾çŠ¶æ€å‘é‡x(t)æ˜¯1ç»´çš„ï¼Œé‚£ä¹ˆå…¶å®å°±æ˜¯ä¸€ä¸ªå¹³æ–¹é¡¹ Qx^2 &amp;gt;= 0ï¼ŒåŒç†. èƒ½é‡å‡½æ•°Jè¦æœ€å°ï¼Œé‚£ä¹ˆçŠ¶æ€å‘é‡x(t)ï¼Œu(t)éƒ½å¾—å°ã€‚    Jæœ€å°ï¼Œé‚£è‚¯å®šæ˜¯ä¸ªæœ‰ç•Œçš„å‡½æ•°ï¼Œæˆ‘ä»¬èƒ½æ¨æ–­å½“tè¶‹äºæ— ç©·æ—¶ï¼ŒçŠ¶æ€å‘é‡x(t)å°†è¶‹äº0ï¼Œè¿™ä¹Ÿä¿è¯äº†é—­ç¯ç³»ç»Ÿçš„ç¨³å®šæ€§ã€‚    é‚£è¾“å…¥u(t)è¦å°æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿå®ƒæ„å‘³ç€æˆ‘ä»¬ç”¨æœ€å°çš„æ§åˆ¶ä»£ä»·å¾—åˆ°æœ€ä¼˜çš„æ§åˆ¶ã€‚è­¬å¦‚æ§åˆ¶ç”µæœºï¼Œè¾“å…¥PWMå°ï¼Œå°†èŠ‚çœèƒ½é‡ã€‚çŸ©é˜µQ,Rçš„é€‰å–?    ğ‘„çŸ©é˜µå…ƒç´ å˜å¤§æ„å‘³ç€å¸Œæœ›è·Ÿè¸ªåå·®èƒ½å¤Ÿå¿«é€Ÿè¶‹è¿‘äºé›¶      ğ‘…çŸ©é˜µå…ƒç´ å˜å¤§æ„å‘³ç€å¸Œæœ›æ§åˆ¶è¾“å…¥èƒ½å¤Ÿå°½å¯èƒ½å°    ä¸€èˆ¬æ¥è¯´ï¼ŒQå€¼é€‰å¾—å¤§æ„å‘³ç€ï¼Œè¦ä½¿å¾—Jå°ï¼Œé‚£x(t)éœ€è¦æ›´å°ï¼Œä¹Ÿå°±æ˜¯æ„å‘³ç€é—­ç¯ç³»ç»Ÿçš„çŸ©é˜µ(A-BK)çš„ç‰¹å¾å€¼å¤„äºSå¹³é¢å·¦è¾¹æ›´è¿œçš„åœ°æ–¹ï¼Œè¿™æ ·çŠ¶æ€x(t)å°±ä»¥æ›´å¿«çš„é€Ÿåº¦è¡°å‡åˆ°0ã€‚    å¦ä¸€æ–¹é¢ï¼Œå¤§çš„Rè¡¨ç¤ºæ›´åŠ å…³æ³¨è¾“å…¥å˜é‡u(t),u(t)çš„å‡å°ï¼Œæ„å‘³ç€çŠ¶æ€è¡°å‡å°†å˜æ…¢ã€‚    åŒæ—¶ï¼ŒQä¸ºåŠæ­£å®šçŸ©é˜µæ„å‘³ç€ä»–çš„ç‰¹å¾å€¼éè´Ÿï¼ŒRä¸ºæ­£å®šçŸ©é˜µæ„å‘³ç€å®ƒçš„ç‰¹å¾å€¼ä¸ºæ­£æ•°ã€‚å¦‚æœä½ é€‰æ‹©Q,Réƒ½æ˜¯å¯¹è§’çŸ©é˜µçš„è¯ï¼Œé‚£ä¹ˆQçš„å¯¹è§’å…ƒç´ ä¸ºæ­£æ•°ï¼Œå…è®¸å‡ºç°å‡ ä¸ª0.Rçš„å¯¹è§’å…ƒç´ åªèƒ½æ˜¯æ­£æ•°ã€‚å°†$u = -Kx$ä»£å…¥$(3)$å¾—åˆ°ï¼š\\(\\begin{aligned}    J = \\dfrac{1}{2}\\int^{\\infty}_0 x^T(Q + K^TRK)x\\quad dt \\qquad(4)\\end{aligned}\\)ä¸ºäº†æ‰¾åˆ°K,æˆ‘ä»¬å…ˆä¸é˜²å‡è®¾å­˜åœ¨ä¸€ä¸ªå¸¸é‡çŸ©é˜µPä½¿å¾—ï¼š\\(\\begin{aligned}    \\dfrac{d}{dt}(x^TPx) = -x^T(Q + K^TRK) \\qquad(5)\\end{aligned}\\)å¸¦å…¥$(4)$å¾—: \\(\\begin{aligned}    J = \\dfrac{1}{2}\\int^{\\infty}_0 \\dfrac{d}{dt}(x^TPx)dt = \\dfrac{1}{2}x^T(0)Px(0) \\qquad(6)\\end{aligned}\\)æ³¨æ„ï¼Œæˆ‘ä»¬å·²ç»å‡è®¾é—­ç¯ç³»ç»Ÿæ˜¯ç¨³å®šçš„ï¼Œä¹Ÿå°±æ˜¯tè¶‹äºæ— ç©·æ—¶ï¼Œx(t)è¶‹äº0.ç°åœ¨æŠŠ(5)å¼å·¦è¾¹çš„å¾®åˆ†å±•å¼€ï¼Œå¹¶æŠŠçŠ¶æ€å˜é‡xçš„å¾®åˆ†ç”¨(2)å¼æ›¿ä»£å¾—åˆ°ï¼š\\(\\begin{aligned}    \\dot{x}^TPx + x^TP\\dot{x} + x^TQx + x^TK^TRKx = 0 \\\\    x^TA^T_cPx + x^TPA_cx + x^TQx + x^TK^TRKx = 0 \\\\    x^T(A^T_cP + PA_c + Q + K^TRK)x = 0\\end{aligned}\\)è¿™ä¸ªå¼å­è¦å§‹ç»ˆæˆç«‹çš„è¯ï¼Œæ‹¬å·é‡Œçš„é¡¹å¿…é¡»æ’ç­‰äº0.\\(\\begin{aligned}    (A-BK)^TP + P(A-BK) + Q + K^TRK = 0 \\\\    A^TP - K^TB^TP + PA - PBK + Q + K^TRK = 0\\end{aligned}\\)å–$K=R^{-1}B^TP$å¸¦å…¥å¾—ï¼š\\(\\begin{aligned}    A^TP + PA + Q + (R^{-1}B^TP)^TR(R^{-1}B^TP) - (R^{-1}B^TP)^TB^TP - PB(R^{-1}B^TP) &amp;amp;= 0 \\\\    A^TP + PA + Q - PBR^{-1}B^TP &amp;amp;= 0 \\qquad(7)\\end{aligned}\\)Kçš„äºŒæ¬¡é¡¹æ²¡æœ‰äº†ï¼Œå¯Kçš„å–å€¼å’ŒPæœ‰å…³ï¼Œè€ŒPæ˜¯æˆ‘ä»¬å‡è®¾çš„ä¸€ä¸ªé‡ï¼ŒPåªè¦ä½¿å¾—çš„(7)å¼æˆç«‹å°±è¡Œäº†ã€‚è€Œ(6)å¼åœ¨ç°ä»£æ§åˆ¶ç†è®ºä¸­æå…¶é‡è¦ï¼Œå®ƒå°±æ˜¯æœ‰åçš„Riccatiæ–¹ç¨‹ã€‚ä¸€èˆ¬é‡‡ç”¨è¿­ä»£æ–¹å¼è§£æ­¤æ–¹ç¨‹ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼šæ€»ç»“      é€‰æ‹©å‚æ•°çŸ©é˜µQ,R        æ±‚è§£Riccati æ–¹ç¨‹å¾—åˆ°çŸ©é˜µP        è®¡ç®—$K=R^{-1}B^TP$        è®¡ç®—$u = -Kx$çš„åˆ°æ§åˆ¶é‡  ä»£ç å®ç°è¾“å…¥A B Q RçŸ©é˜µè®¡ç®—Kimport scipy.linalg as laimport numpy as npdef solve_DARE(A, B, Q, R):    &quot;&quot;&quot;    solve a discrete time_Algebraic Riccati equation (DARE)    &quot;&quot;&quot;    X = Q    maxiter = 150    eps = 0.01    for i in range(maxiter):        Xn = A.T @ X @ A - A.T @ X @ B @ \\            la.inv(R + B.T @ X @ B) @ B.T @ X @ A + Q        if (abs(Xn - X)).max() &amp;lt; eps:            break        X = Xn    return Xndef dlqr(A, B, Q, R):    &quot;&quot;&quot;Solve the discrete time lqr controller.    x[k+1] = A x[k] + B u[k]    cost = sum x[k].T*Q*x[k] + u[k].T*R*u[k]    # ref Bertsekas, p.151    &quot;&quot;&quot;    # first, try to solve the ricatti equation    X = solve_DARE(A, B, Q, R)    # compute the LQR gain    K = la.inv(B.T @ X @ B + R) @ (B.T @ X @ A)    eigVals, eigVecs = la.eig(A - B @ K)    return K, X, eigVals"
  },
  
  {
    "title": "è‡ªè¡Œè½¦è¿åŠ¨å­¦æ¨¡å‹",
    "url": "/posts/kinematics_module/",
    "categories": "æ¨¡å‹, è¿åŠ¨å­¦æ¨¡å‹",
    "tags": "æ¨¡å‹, è¿åŠ¨å­¦",
    "date": "2021-12-20 00:00:00 +0800",
    





    "snippet": "è¿åŠ¨å­¦æ¨¡å‹è‡ªè¡Œè½¦æ¨¡å‹  è‡ªè¡Œè½¦æ¨¡å‹ è½¦è¾†è¿åŠ¨å­¦æ¨¡å‹  è‡ªè¡Œè½¦æ¨¡å‹åŸºäºå¦‚ä¸‹å‡ ä¸ªå‡è®¾ï¼š  è½¦è¾†åœ¨å‚ç›´æ–¹å‘çš„è¿åŠ¨è¢«å¿½ç•¥æ‰äº†ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬æè¿°çš„è½¦è¾†æ˜¯ä¸€ä¸ªäºŒç»´å¹³é¢ä¸Šçš„è¿åŠ¨ç‰©ä½“ï¼ˆå¯ä»¥ç­‰ä»·ä¸æˆ‘ä»¬æ˜¯ç«™åœ¨å¤©ç©ºä¸­çš„ä¿¯è§†è§†è§’ï¼‰  å‡è®¾è½¦è¾†çš„ç»“æ„å°±åƒè‡ªè¡Œè½¦ä¸€æ ·ï¼Œä¹Ÿå°±æ˜¯è¯´è½¦è¾†çš„å‰é¢ä¸¤ä¸ªè½®èƒæ‹¥æœ‰ä¸€ç›´çš„è§’åº¦å’Œè½¬é€Ÿç­‰ï¼ŒåŒæ ·åé¢çš„ä¸¤ä¸ªè½®èƒä¹Ÿæ˜¯å¦‚æ­¤ï¼Œé‚£ä¹ˆå‰åçš„è½®èƒå°±å¯ä»¥å„ç”¨ä¸€ä¸ªè½®èƒæ¥æè¿°  æˆ‘ä»¬å‡è®¾è½¦è¾†è¿åŠ¨ä¹Ÿå’Œè‡ªè¡Œè½¦ä¸€æ ·ï¼Œè¿™æ„å‘³ç€æ˜¯å‰é¢çš„è½®èƒæ§åˆ¶è¿™è½¦è¾†çš„è½¬è§’è‡ªè¡Œè½¦è¿åŠ¨å­¦æ¨¡å‹ä½œä¸ºä¸€ç§è‡ªè¡Œè½¦æ¨¡å‹ï¼Œè¿åŠ¨å­¦è‡ªè¡Œè½¦æ¨¡å‹ä¹Ÿå‡å®šè½¦è¾†å½¢å¦‚ä¸€è¾†è‡ªè¡Œè½¦ï¼Œæ•´ä¸ªçš„æ§åˆ¶é‡å¯ä»¥ç®€åŒ–ä¸º$\\alpha, \\delta_f, \\delta_r$.å…¶ä¸­$\\alpha$æ˜¯è½¦è¾†çš„åŠ é€Ÿåº¦ï¼Œè¸©æ²¹é—¨è¸æ¿æ„å‘³ç€æ­£çš„åŠ é€Ÿåº¦ï¼Œè¸©åˆ¹è½¦è¸æ¿æ„å‘³ç€è´Ÿçš„åŠ é€Ÿåº¦ã€‚$\\delta_f$æ˜¯å‰è½®è½¬è§’ï¼Œ$\\delta_r$æ˜¯åè½®è½¬è§’ã€‚è¿™æ ·æˆ‘ä»¬ä½¿ç”¨ä¸‰ä¸ªé‡æè¿°äº†è½¦è¾†çš„æ§åˆ¶è¾“å…¥(control input)ï¼Œå…¶ä¸­çŠ¶æ€é‡æˆ‘ä»¬ç”¨$\\psi, V, x, y$æ¥è¡¨ç¤ºã€‚å„å˜é‡è¯´æ˜å¦‚ä¸‹ï¼š  $\\delta_f$ å‰è½®è½¬è§’  $\\delta_r$ åè½®è½¬è§’  $\\psi$ èˆªå‘è§’  $V$é€Ÿåº¦æ–¹å‘  $\\beta$ é€Ÿåº¦æ–¹å‘ä¸è½¦è¾†æ–¹å‘å¤¹è§’(æ»‘ç§»è§’)  $l_r, l_f$ è´¨ç‚¹åˆ°å‰åè½´çš„è·ç¦»  $\\omega$ è§’é€Ÿåº¦  $R$ è½¬å¼¯åŠå¾„  $x, y$æ¨¡å‹çš„ä½ç½®ç”±ä¸‰è§’å‡½æ•°å¯å¾—ï¼š\\(\\begin{aligned}    \\dfrac{\\sin(\\delta_f - \\beta)}{l_f} &amp;amp;=  \\dfrac{\\sin( \\dfrac{\\pi}{2} - \\delta_f)}{R} \\\\    \\dfrac{\\sin(\\beta - \\delta_r)}{l_r} &amp;amp;= \\dfrac{\\sin(\\dfrac{\\pi}{2} + \\delta_r)}{R} \\\\\\end{aligned}\\)å±•å¼€ï¼š\\(\\begin{aligned}    \\dfrac{\\sin\\delta_f\\cos\\beta - \\cos\\delta_f\\sin\\beta}{l_f} &amp;amp;=  \\dfrac{\\cos\\delta_f}{R} \\qquad(1)\\\\    \\dfrac{\\sin\\beta\\cos\\delta_r - \\cos\\beta\\sin\\delta_r}{l_r} &amp;amp;= \\dfrac{\\cos\\delta_r}{R} \\qquad(2)\\\\\\end{aligned}\\)å¯ä»¥æ±‚å¾—$R, \\beta$ï¼š  $(1)$å¼åŒé™¤$\\delta_f$åŒä¹˜$l_f$åŠ ä¸Š$(2)$å¼åŒé™¤$\\delta_r$åŒä¹˜$l_r$å¾—:\\(\\begin{aligned} \\dfrac{l_f + l_r}{R} &amp;amp;= \\cos\\beta(\\tan\\delta_f - \\tan\\delta_r) \\\\ R &amp;amp;= \\dfrac{l_f + l_r}{\\cos\\beta(\\tan\\delta_f - \\tan\\delta_r)} \\qquad(3) \\\\\\end{aligned}\\)  $(1)$å¼é™¤ä»¥$(2)$å¼ï¼š\\(\\begin{aligned} \\dfrac{\\sin\\delta_f\\cos\\beta - \\cos\\delta_f\\sin\\beta}{\\sin\\beta\\cos\\delta_r - \\cos\\beta\\sin\\delta_r} &amp;amp;=  \\dfrac{\\cos\\delta_f * l_f}{\\cos\\delta_r * l_r} \\\\\\end{aligned}\\)  ç­‰å¼åŒæ—¶é™¤ä»¥$\\cos\\delta_f$ï¼Œä¹˜ä»¥$\\cos\\delta_r$å¾—:\\(\\begin{aligned} \\dfrac{\\tan\\delta_f\\cos\\beta - \\sin\\beta}{\\sin\\beta - \\cos\\beta\\tan\\delta_r} &amp;amp;=  \\dfrac{l_f}{l_r} \\\\\\end{aligned}\\)  ç­‰å¼å·¦è¾¹åŒæ—¶é™¤ä»¥$\\cos\\beta$å¾—:\\(\\begin{aligned} \\dfrac{\\tan\\delta_f - \\tan\\beta}{\\tan\\beta - \\tan\\delta_r} &amp;amp;=  \\dfrac{l_f}{l_r} \\\\\\end{aligned}\\)  åˆå¹¶æ•´ç†å¾—:\\(\\begin{aligned} \\tan\\beta &amp;amp;=  \\dfrac{l_r * \\tan\\delta_f + l_f * \\tan\\delta_r}{l_f + l_r} \\\\ \\beta &amp;amp;= \\arctan(\\dfrac{l_r * \\tan\\delta_f + l_f * \\tan\\delta_r}{l_f + l_r}) \\qquad(4) \\\\\\end{aligned}\\)ä½é€Ÿç¯å¢ƒä¸‹ï¼Œè½¦è¾†è¡Œé©¶è·¯å¾„çš„è½¬å¼¯åŠå¾„å˜åŒ–ç¼“æ…¢ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥å‡è®¾è½¦è¾†çš„æ–¹å‘å˜åŒ–ç‡ç­‰äºè½¦è¾†çš„è§’é€Ÿåº¦ã€‚åˆ™è½¦è¾†çš„è§’é€Ÿåº¦$\\omega$ä¸º\\(\\begin{aligned}    \\omega &amp;amp;= \\dfrac{V}{R} \\\\\\end{aligned}\\)ä»£å…¥$(3)$å¾—:\\(\\begin{aligned}    \\omega &amp;amp;= \\dfrac{V * \\cos\\beta * (\\tan\\delta_f - \\tan\\delta_r)}{l_f + l_r} \\qquad(5)\\\\\\end{aligned}\\)æ‰€ä»¥æ¨¡å‹çš„çŠ¶æ€é‡$x, y, \\psi, V$çš„æ›´æ–°å¦‚ä¸‹:\\(\\begin{aligned}    x_{t+1} &amp;amp;= x_t + V_t*\\cos(\\psi_t + \\beta) * \\Delta{t} \\\\    y_{t+1} &amp;amp;= y_t + V_t*\\sin(\\psi_t + \\beta) * \\Delta{t} \\\\    V_{t+1} &amp;amp;= V_t + \\alpha * \\Delta{t} \\\\    \\psi_{t+1} &amp;amp;= \\psi_t + \\omega * \\Delta{t} \\\\\\end{aligned}\\)å½“ä»…å‰è½®é©±åŠ¨æ—¶ï¼Œ$\\delta_r$å¯è®¤ä¸ºæ˜¯0åˆ™$\\psi, V, x, y$ï¼Œæ›´æ–°å…¬å¼å¦‚ä¸‹ï¼š\\(\\begin{aligned}    x_{t+1} &amp;amp;= x_t + V*\\cos(\\psi_t + \\beta) * \\Delta{t} \\\\    y_{t+1} &amp;amp;= y_t + V*\\sin(\\psi_t + \\beta) * \\Delta{t} \\\\    V_{t+1} &amp;amp;= V_t + \\alpha * \\Delta{t} \\\\    \\psi_{t+1} &amp;amp;= \\psi_t + \\frac{V_t}{l_f + l_r} * \\cos(\\beta) * \\tan(\\delta_f) * \\Delta{t} \\\\    \\beta &amp;amp;= \\arctan(\\frac{l_r}{l_r+l_f} * \\tan(\\delta_f))\\end{aligned}\\)ä»£ç å®ç°class KinematicModel(object):    def __init__(self, x, y, psi, v, f_len, r_len):        self.x = x        self.y = y        self.psi = psi        self.v = v`           self.f_len = f_len        self.r_len = r_len    def get_state(self):        return self.x, self.y, self.psi, self.v    def update_state(self, a, delta, dt):        beta = math.atan((self.r_len / (self.r_len + self.f_len)) * math.tan(delta))        self.x = self.x + self.v * math.cos(self.psi + beta) * dt        self.y = self.y + self.v * math.sin(self.psi + beta) * dt        self.psi = self.psi + (self.v / (self.f_len + self.r_len)) * math.cos(beta) * math.tan(delta) * dt        self.v = self.v + a * dt        return self.x, self.y, self.psi, self.v"
  },
  
  {
    "title": "çº¯é¢„ç„è·Ÿè¸ªç®—æ³•",
    "url": "/posts/pure_pursuit/",
    "categories": "ç®—æ³•, æ§åˆ¶ç®—æ³•",
    "tags": "é¢„ç„",
    "date": "2021-12-18 00:00:00 +0800",
    





    "snippet": "PurePursuit çº¯é¢„ç„ç®—æ³•é˜¿å…‹æ›¼è½¬å‘  é˜¿å…‹æ›¼è½¬å‘  é˜¿å…‹æ›¼è½¬å‘æ˜¯ä¸€ç§ç°ä»£æ±½è½¦çš„è½¬å‘æ–¹å¼ï¼Œåœ¨æ±½è½¦è½¬å¼¯çš„æ—¶å€™ï¼Œå†…å¤–è½®è½¬è¿‡çš„è§’åº¦ä¸ä¸€æ ·ï¼Œå†…ä¾§è½®èƒè½¬å¼¯åŠå¾„å°äºå¤–ä¾§è½®èƒã€‚æ ¹æ®é˜¿å…‹æ›¼è½¬å‘å‡ ä½•è®¾è®¡çš„è½¦è¾†ï¼Œæ²¿ç€å¼¯é“è½¬å¼¯æ—¶ï¼Œåˆ©ç”¨å››è¿æ†çš„ç›¸ç­‰æ›²æŸ„ä½¿å†…ä¾§è½®çš„è½¬å‘è§’æ¯”å¤–ä¾§è½®å¤§å¤§çº¦2~4åº¦ï¼Œä½¿å››ä¸ªè½®å­è·¯å¾„çš„åœ†å¿ƒå¤§è‡´ä¸Šäº¤ä¼šäºåè½´çš„å»¶é•¿çº¿ä¸Šç¬æ—¶è½¬å‘ä¸­å¿ƒï¼Œè®©è½¦è¾†å¯ä»¥é¡ºç•…çš„è½¬å¼¯.ä¸‹å›¾å°±æ˜¯ç†æƒ³çš„é˜¿å…‹æ›¼è½¬å‘ã€‚$\\alpha$æ±½è½¦å†…è½®è½¬è§’$\\beta$æ±½è½¦å¤–è½®è½¬è§’Kä¸¤ä¸»é”€ä¸­å¿ƒè·ç¦»Lè½´è·Rè½¬å¼¯åŠå¾„è½¬åŠ¨å½¢å¼:  ä»…å‰è½®è½¬å‘ï¼Œåè½®è§’åº¦ä¸å˜ã€‚  å‰åè½®å‡å¯è½¬å‘ã€‚  (1) å‰åè½®è§’åº¦ç›¸åï¼Œ(2) å‰åè½®è§’åº¦ç›¸åŒï¼Œè¿™ç§æ¨¡å¼å¯ä»¥å®ç°å…¨å‘è¿åŠ¨ã€‚è½¬å‘ç‰¹æ€§çš„ç‰¹ç‚¹ï¼š  æ±½è½¦ç›´çº¿è¡Œé©¶æ—¶ï¼Œ4ä¸ªè½¦è½®çš„è½´çº¿éƒ½äº’ç›¸å¹³è¡Œï¼Œè€Œä¸”å‚ç›´äºæ±½è½¦çºµå‘ä¸­å¿ƒé¢ã€‚  æ±½è½¦åœ¨è½¬å‘è¡Œé©¶è¿‡ç¨‹ä¸­ï¼Œå…¨éƒ¨è½¦è½®éƒ½å¿…é¡»ç»•ä¸€ä¸ªç¬æ—¶ä¸­å¿ƒç‚¹åšåœ†å‘¨æ»šåŠ¨ã€‚æ ¸å¿ƒå…¬å¼      $\\cot\\beta - \\cot\\alpha = \\cfrac{K}{L}$        $\\tan\\beta = \\cfrac{L}{R}$  PurePursuit  çº¯é¢„ç„ç®—æ³•  ä¸Šå›¾æ‰€â½°ä¸ºç®€åŒ–çš„è½¦è¾†è¿åŠ¨å­¦â¾ƒâ¾è½¦æ¨¡å‹ï¼Œå…¶åè½®ä¸­å¿ƒåœ¨è“â¾Šè™šçº¿è¡¨â½°çš„â½¬æ ‡è½¨è¿¹ä¸Šã€‚æœ¬ç®—æ³•é€šè¿‡æ§åˆ¶å‰è½®è½¬â»†æ¥è¿½è¸ªä¸‹â¼€ä¸ªè·¯ç‚¹ï¼Œä½¿è½¦è¾†å¯ä»¥æ²¿ç€ç»è¿‡â½¬æ ‡é¢„ç„ç‚¹çš„åœ†å¼§â¾é©¶ã€‚ç‰©ç†é‡æè¿°å¦‚ä¸‹:$R(m)$ è½¬å¼¯åŠå¾„$L(m)$ è½´è·$\\delta$ å‰è½®è½¬è§’$l_d$ é¢„ç„è·ç¦»$x_r$é¢„ç„ç‚¹æ¨ªåæ ‡$y_r$é¢„ç„ç‚¹çºµåæ ‡$e$æ¨ªå‘åå·®$\\alpha$è½¦èº«ä¸é¢„ç„ç‚¹å¤¹è§’æœ¬è´¨å°±æ˜¯å·²çŸ¥è½´è·ï¼Œé¢„ç„è·ç¦»ï¼Œæ¨ªå‘åå·®æ±‚å‰è½®è½¬è§’:ç”±æ­£å¼¦å®šç†å¯ä»¥çŸ¥é“  $\\cfrac{l_d}{\\sin2\\alpha} = \\cfrac{R}{\\sin{\\cfrac{\\pi - 2\\alpha}{2}}}$  $\\cfrac{l_d}{2 * \\sin\\alpha * \\cos\\alpha} = \\cfrac{R}{\\cos\\alpha}$  $R = \\cfrac{l_d}{2 * \\sin\\alpha}$å…¶ä¸­  $\\sin\\alpha = \\cfrac{e}{l_d}$é‚£ä¹ˆå°±æœ‰  $R = \\cfrac{l_d^2}{2e}$æ‰€ä»¥  $\\delta = \\arctan\\cfrac{L}{R} = \\arctan\\cfrac{2Le}{l_d^2}$ç”±ä¸Šå¼å¯çŸ¥æ§åˆ¶å™¨çš„æœ¬è´¨å°±æ˜¯å¯¹è½¬è§’è¿›è¡Œæ§åˆ¶ï¼Œä»¥å‡å°‘æ¨ªå‘è¯¯å·®ä¸ºç›®æ ‡çš„æ¨ªå‘æ§åˆ¶å™¨ã€‚å…¶ä¸­$\\cfrac{2L}{l_d^2}$å¯è§†ä¸ºæ§åˆ¶å™¨çš„På‚æ•°.Lä¸ºè½¦è¾†è½´è·,$l_d$ä¸ºè®¾å®šçš„é¢„ç„è·ç¦».æœ¬æ§åˆ¶å™¨çš„æ§åˆ¶æ•ˆæœä¸»è¦å–å†³äºé¢„ç„è·ç¦»çš„é€‰å–,â¼€èˆ¬æ¥è¯´é¢„ç„è·ç¦»è¶Šâ»“,æ§åˆ¶æ•ˆæœä¼šè¶Šå¹³æ»‘,é¢„ç„è·ç¦»è¶ŠçŸ­ï¼Œæ§åˆ¶æ•ˆæœä¼šè¶Šç²¾ç¡®ï¼ˆåŒæ—¶ä¹Ÿä¼šå¸¦æ¥â¼€å®šçš„éœ‡è¡ï¼‰.é¢„ç„è·ç¦»çš„é€‰å–ä¹Ÿå’Œå½“å‰è½¦é€Ÿæœ‰å…³,å¦‚ä»¥ä¸‹ä¸¤ç§:  $l_d = gv + l_f$å…¶ä¸­vä¸ºå½“å‰è½¦é€Ÿï¼Œgä¸ºâ¼€å¯è°ƒèŠ‚çš„å‚æ•°,$l_f$ä¸ºé¢„è®¾å‰è§†è·ç¦»  $l_d = Av^2 + Bv + C$å…¶ä¸­$A=1/(2a_{max})$, $a_{max}$ä¸ºæœ€â¼¤åˆ¶åŠ¨åŠ é€Ÿåº¦.$Av^2$è¡¨â½°æœ€çŸ­è½¦è¾†åˆ¶åŠ¨è·ç¦».Bè¡¨â½°è½¦è¾†é‡åˆ°å¼‚å¸¸æ—¶éœ€è¦çš„ååº”æ—¶é—´, $Bv$åˆ™ä¸ºå¯¹åº”çš„ååº”è·ç¦», $C$è¡¨â½°è½¦è¾†çš„æœ€â¼©è½¬å¼¯åŠå¾„.åœ¨å®é™…ä½¿ç”¨çš„æ—¶å€™ï¼Œé€šå¸¸ä¸éœ€è¦è§„åˆ’ç‚¹åˆ‡å®ç­‰äºé¢„ç„ç‚¹ï¼Œè€Œæ˜¯åœ¨é¢„ç„ç‚¹é™„è¿‘æ‰¾ä¸€ä¸ªæœ€æ¥è¿‘çš„è§„åˆ’ç‚¹ï¼ŒåŒæ—¶è¿˜å¯ä»¥ç”¨PIDè°ƒæ•´eå€¼ã€‚ä»£ç å®ç°é¢„ç„è¾“å…¥è‡ªè½¦ç»çº¬é«˜ä»¥åŠç›®æ ‡ç‚¹ç»çº¬é«˜ï¼Œè®¡ç®—è½¦è½®è½¬è§’// è®¡ç®—é¢„ç„è·ç¦»double PurePursuit::cal_ld(double vel){    return 1.0 / ( 2 * _max_braking_acc) * vel * vel + _reactime * vel + _min_turning_radius;}// http://www.movable-type.co.uk/scripts/latlong.html// è®¡ç®—gpsä¸¤ç‚¹è·ç¦»double PurePursuit::cal_gps_distance(double lng1, double lat1, double lng2, double lat2){    double radius_of_earth = 6378137.0;    lng1 = lng1 / 180 * M_PI;    lat1 = lat1 / 180 * M_PI;    lng2 = lng2 / 180 * M_PI;    lat2 = lat2 / 180 * M_PI;    double delt_lat = lat2 - lat1;    double delt_lng = lng2 - lng1;    double a = pow(sin(0.5 * delt_lat), 2) + pow(sin(0.5 * delt_lng), 2) * cos(lat1) * cos(lat2);    double c = 2.0 * atan2(sqrt(a), sqrt(1.0 - a));    return radius_of_earth * c;}// è®¡ç®—gpsä¸¤ç‚¹æ–¹ä½è§’double PurePursuit::cal_gps_bearing(double lng1, double lat1, double lng2, double lat2){    lng1 = lng1 / 180 * M_PI;    lat1 = lat1 / 180 * M_PI;    lng2 = lng2 / 180 * M_PI;    lat2 = lat2 / 180 * M_PI;    double delt_lat = lat2 - lat1;    double delt_lng = lng2 - lng1;    double y = sin(delt_lng) * cos(lat2);    double x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(delt_lng);    return atan2(y, x); }// è®¡ç®—æ¨ªå‘åå·®ï¼Œyawä¸ºè½¦è¾†çš„èˆªå‘è§’ï¼Œæ­£åŒ—æ–¹å‘çš„åèˆªdouble PurePursuit::cal_lateral(double lng1, double lat1, double lng2, double lat2, double yaw){    double distance = cal_gps_distance(lng1, lat1, lng2, lat2);    double heading = cal_gps_bearing(lng1, lat1, lng2, lat2);    if (heading &amp;lt; 0) heading += 2 * M_PI;    heading -= yaw;    double x = sin(heading) * distance;    double y = cos(heading) * distance;    return y; }// è®¡ç®—è½¦è¾†è½¬è§’ï¼Œvelè‡ªèº«è½¦é€Ÿdouble PurePursuit::cal_wheel_angle(double lng1, double lat1, double lng2, double lat2, double vel, double yaw){    double ld = cal_ld(vel);    double lateral = cal_lateral(lng1, lat1, lng2, lat2, 0);    return atan(2 * _wheel_base * lateral / ld / ld);}å®ç°2ï¼šè½¬æ¢utmåæ ‡ç³»ä¸”ä½¿ç”¨ç›®æ ‡ç‚¹èˆªå‘è®¡ç®—è¯¦ç»†å¯æ“ä½œä»£ç è§è„šæœ¬pure_pursuit_lateral_controller.py    from pyproj import Proj    proj_text = &quot;+proj=utm +zone=50 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs&quot;    trsfm = Proj(proj_text)    path_point = read_global_path(log_path)    # å…¨å±€è·¯å¾„è½¬utm    x, y = [], []    for point in path_point:        utm_x, utm_y = trsfm(point[0], point[1])        x.append(utm_x)        y.append(utm_y)    x = np.array(x)    y = np.array(y)    # è®¡ç®—é¢„ç„è·ç¦»    ld = max(km.v * g_rate, 2)    dx = km.x - x[target_pts_idx]    dy = km.y - y[target_pts_idx]    euler_dist = math.sqrt(dx**2 + dy**2)    if euler_dist &amp;lt; ld:        target_pts_idx += 1        continue    print(target_pts_idx, ld, euler_dist, dx, dy, km.x, km.y)    cos_target_heading = cos(path_point[target_pts_idx][-1] * DEG_TO_RAD)    sin_target_heading = sin(path_point[target_pts_idx][-1] * DEG_TO_RAD)    # è®¡ç®—æ¨ªçºµå‘åå·®    # lateral_error = cos_target_heading * dy - sin_target_heading * dx    # print(&quot;lateral_error&quot;, lateral_error)    lateral_error = cos_target_heading * dx - sin_target_heading * dy     longtidual_error = sin_target_heading * dx + cos_target_heading * dy        print(&quot;lateral_error&quot;, lateral_error)    # print(&quot;longtidual_error&quot;, longtidual_error)    # print(&quot;euler_dist:&quot;, math.sqrt(dx**2 + dy**2))    # è®¡ç®—å‰è½®è½¬è§’    alpha = atan(2 * 2.9 * lateral_error / euler_dist**2) + kp * lateral_error + ki * (lateral_error - last_error) + kd * (lateral_error - 2*(last_error) + last_last_error)    alpha = min(alpha, 30 * DEG_TO_RAD)    alpha = max(alpha, -30 * DEG_TO_RAD)"
  },
  
  {
    "title": "Canè§£æ",
    "url": "/posts/can/",
    "categories": "CAN",
    "tags": "CAN",
    "date": "2021-12-18 00:00:00 +0800",
    





    "snippet": "canè§£ææè¿°canè§£ææµç¨‹æ•°æ®æˆ‘ä»¬ä¸€èˆ¬æ‹¿åˆ°çš„canæ•°æ®ä¸€èˆ¬éƒ½æ˜¯è¿™ç§æ ·å­çš„            CAN ID      CAN DATA                  0x60b      0x11 0x22 0x33 0x44 0x55 0x66 0x77 0x88      è¿™ä¾¿æ˜¯ä¸€æ¡å®Œæ•´çš„canå¸§, ç”±idå’Œdataç»„æˆ.å…¶åœ¨linuxä¸­ç»“æ„å®šä¹‰å¦‚ä¸‹:#include &amp;lt;linux/can.h&amp;gt;/* CAN payload length and DLC definitions according to ISO 11898-1 */#define CAN_MAX_DLC 8#define CAN_MAX_DLEN 8/* special address description flags for the CAN_ID */#define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */#define CAN_RTR_FLAG 0x40000000U /* remote transmission request */#define CAN_ERR_FLAG 0x20000000U /* error message frame */struct can_frame {    canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */    __u8    can_dlc; /* frame payload length in byte (0 .. CAN_MAX_DLEN) */    __u8    __pad;   /* padding */    __u8    __res0;  /* reserved / padding */    __u8    __res1;  /* reserved / padding */    __u8    data[CAN_MAX_DLEN] __attribute__((aligned(8)));};canå¸§çš„ä¸»è¦å‡ ç±»:      æ•°æ®å¸§-æ ‡å‡†å¸§: é•¿åº¦11ä½,æœ€å¤§å€¼ä¸º0x7ff.        æ•°æ®å¸§-æ‰©å±•å¸§: é•¿åº¦29ä½, å¯é€šè¿‡canid &amp;amp; CAN_EFF_FLAG == 1 åˆ¤æ–­.    é”™è¯¯å¸§: é€šè¿‡ CAN_ERR_FLAG åˆ¤æ–­  è¿œç¨‹å¸§: é€šè¿‡ CAN_RTR_FLAG åˆ¤æ–­å…¶ä¸­æˆ‘ä»¬çœ‹åˆ°æœ€å¤šçš„æ˜¯æ•°æ®å¸§, å…¶ä»–å¸§åŸºæœ¬æ²¡æœ‰çœ‹åˆ°è¿‡.dbcæœ‰äº†æ•°æ®ä¹‹å,å¦‚ä½•è§£ç å‡ºæˆ‘ä»¬æ‰€éœ€è¦çš„ä¿¡æ¯å‘¢? é€šå¸¸æƒ…å†µéƒ½æ˜¯é€šè¿‡dbcæ¥ç¼–ç æˆ–è€…è§£ç çš„.DBCæ˜¯Database Cançš„ç¼©å†™ï¼Œå…¶ä»£è¡¨çš„æ˜¯CANçš„æ•°æ®åº“æ–‡ä»¶ï¼Œåœ¨è¿™ä¸ªæ–‡ä»¶ä¸­æŠŠCANé€šè®¯çš„ä¿¡æ¯å®šä¹‰å®Œæ•´.BO_ 1547 Obj_1_General: 8 ARS_ISF SG_ Obj_DynProp : 50|3@0+ (1,0) [0|7] &quot;&quot;  ExternalUnit SG_ Obj_RCS : 63|8@0+ (0.5,-64) [-64|63.5] &quot;dBmÂ²&quot;  ExternalUnit SG_ Obj_VrelLat : 45|9@0+ (0.25,-64) [-64|63.75] &quot;m/s&quot;  ExternalUnit SG_ Obj_ID : 7|8@0+ (1,0) [0|255] &quot;&quot;  ExternalUnit SG_ Obj_DistLong : 15|13@0+ (0.2,-500) [-500|1138.2] &quot;m&quot;  ExternalUnit SG_ Obj_VrelLong : 39|10@0+ (0.25,-128) [-128|127.75] &quot;m/s&quot;  ExternalUnit SG_ Obj_DistLat : 18|11@0+ (-0.2,204.6) [-204.8|204.6] &quot;m&quot;  ExternalUnitä¸Šé¢å±•ç¤ºäº†ä¸€æ®µarsçš„dbcä¸­å¯¹canidä¸º1547çš„canå¸§æè¿°.å…¶ä¸­ä¸»è¦æœ‰BO_ æŠ¥æ–‡, SG_ ä¿¡å·.ä¸€ä¸ªæŠ¥æ–‡ä¸‹ä¼šæœ‰å¤šä¸ªä¿¡å·. ä¸€ä¸ªæŠ¥æ–‡å°±æ˜¯ä¸€ä¸ªcanå¸§,å…¶æ•°æ®åŸŸé•¿åº¦ä¸º8å­—èŠ‚64ä½(è§å‰é¢å®šä¹‰).å¯¹äºä¿¡å·,æ¯ä¸€è¡Œéƒ½ç›¸ä¿¡çš„æè¿°äº†è¯¥ä¿¡å·åœ¨æ•°æ®åŸŸä¸­çš„ä½ç½®,è§£ç æ–¹å¼ç­‰.BO_ (æŠ¥æ–‡)åŸºæœ¬æ ¼å¼å¦‚ä¸‹:BO_ MessageId MessageName: MessageSize Transmitter  BO_ä¸ºå…³é”®å­—ï¼Œè¡¨ç¤ºæŠ¥æ–‡ï¼›  MessageIdä¸ºå®šä¹‰çš„æŠ¥æ–‡IDï¼Œæ˜¯ä»¥10è¿›åˆ¶æ•°è¡¨ç¤ºï¼›  MessageNameè¡¨ç¤ºè¯¥æŠ¥æ–‡çš„åå­—  MessageSizeè¡¨ç¤ºè¯¥æŠ¥æ–‡æ•°æ®åŸŸå­—èŠ‚æ•°ï¼Œä¸ºæ— ç¬¦å·æ•´å‹æ•°æ®ï¼›  Transmitterè¡¨ç¤ºå‘é€è¯¥æŠ¥æ–‡çš„ç½‘ç»œèŠ‚ç‚¹ï¼›å¦‚æœè¯¥æŠ¥æ–‡æ²¡æœ‰æŒ‡å®šå‘é€èŠ‚ç‚¹ï¼Œåˆ™è¯¥å€¼éœ€è®¾ç½®ä¸ºâ€ Vector__XXXâ€æˆ–è€…ä¸å†™ä»¥1547æŠ¥æ–‡ä¸¾ä¾‹è¯´æ˜:BO_ 1547 Obj_1_General: 8 ARS_ISF            å®šä¹‰      æè¿°                  BO_      æŠ¥æ–‡å…³é”®å­—              1547      can id 16è¿›åˆ¶ä¸º0x60b              Obj_1_General      æŠ¥æ–‡åå­—              8      æŠ¥æ–‡æ•°æ®åŸŸå­—èŠ‚æ•°              ARS_ISF      å‘é€è¯¥æŠ¥æ–‡çš„èŠ‚ç‚¹      SG_ (ä¿¡å·)åŸºæœ¬æ ¼å¼å¦‚ä¸‹:SG_ SignalName : StartBit|SignalSize@ByteOrder ValueType (Factor,Offset) [Min|Max] Unit Receiver  SG_ä¸ºå…³é”®å­—ï¼Œè¡¨ç¤ºä¿¡å·ï¼›  SignalNameã€ StartBitã€ SignalSizeåˆ†åˆ«è¡¨ç¤ºè¯¥ä¿¡å·çš„åå­—ã€èµ·å§‹ä½ã€ä¿¡å·é•¿åº¦ï¼›  ByteOrderè¡¨ç¤ºä¿¡å·çš„å­—èŠ‚é¡ºåºï¼š0ä»£è¡¨Motorolaæ ¼å¼(å¤§ç«¯åº)ï¼Œ1ä»£è¡¨Intelæ ¼å¼(å°ç«¯åº)ï¼›  ValueType è¡¨ç¤ºè¯¥ä¿¡å·çš„æ•°å€¼ç±»å‹ï¼š+è¡¨ç¤ºæ— ç¬¦å·æ•°ï¼Œ-è¡¨ç¤ºæœ‰ç¬¦å·æ•°ï¼›  Factorè¡¨ç¤ºå› å­ï¼ŒOffsetè¡¨ç¤ºåç§»é‡ï¼›è¿™ä¸¤ä¸ªå€¼äºè¯¥ä¿¡å·çš„åŸå§‹å€¼ä¸ç‰©ç†å€¼ä¹‹é—´çš„è½¬æ¢ã€‚è½¬æ¢å¦‚ä¸‹ï¼šç‰©ç†å€¼=åŸå§‹å€¼*å› å­+åç§»é‡ï¼›                              Min          Maxè¡¨ç¤ºè¯¥ä¿¡å·çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œå³æŒ‡å®šäº†è¯¥ä¿¡å·å€¼çš„èŒƒå›´ï¼›è¿™ä¸¤ä¸ªå€¼ä¸ºdoubleç±»å‹ï¼›                      Unitè¡¨ç¤ºè¯¥ä¿¡å·çš„å•ä½ï¼Œä¸ºå­—ç¬¦ä¸²ç±»å‹ï¼›  Receiverè¡¨ç¤ºè¯¥ä¿¡å·çš„æ¥æ”¶èŠ‚ç‚¹ï¼›è‹¥è¯¥ä¿¡å·æ²¡æœ‰æŒ‡å®šçš„æ¥æ”¶èŠ‚ç‚¹ï¼Œåˆ™å¿…é¡»è®¾ç½®ä¸ºâ€ Vector__XXXâ€ä¸¾ä¾‹å¦‚ä¸‹:SG_ Obj_DistLat : 18|11@0+ (-0.2,204.6) [-204.8|204.6] â€œmâ€  ExternalUnit            å®šä¹‰      æè¿°                  SG_      ä¿¡å·å…³é”®å­—              Obj_DistLat      ä¿¡å·å              18      èµ·å§‹ä½              11      é•¿åº¦              0      motorolaæ ¼å¼(å¤§ç«¯åº)              +      æ— ç¬¦å·æ•°              -0.2      ç¼©æ”¾å› å­              204.6      åç§»é‡              -204.8      æœ€å°å€¼              204.6      æœ€å¤§å€¼              m      å•ä½              ExternalUnit      æ¥æ”¶èŠ‚ç‚¹      è§£æé€šè¿‡dbcæˆ–è€…åè®®æ–‡æ¡£è·å–äº†æŠ¥æ–‡å’Œä¿¡å·çš„ç¼–è§£ç ä¿¡æ¯,ç„¶åå°±å¯ä»¥è§£æå‡ºæ˜æ–‡.è¿™é‡Œè¿˜æ˜¯ä»¥contiçš„ars 408é›·è¾¾ä¸¾ä¾‹.å¤§ç«¯åºåˆ—cveé‡‡é›†åˆ°çš„ä¸€æ¡arsæŠ¥æ–‡:0x60b 00 4e a4 01 80 20 01 7f      é¦–å…ˆæ„å»ºä½å›¾    å°†8å­—èŠ‚64ä½æ•°æ®è½¬æˆäºŒè¿›åˆ¶,ä¾æ¬¡å±•å¼€  å¤§ç«¯åºåˆ—ä»å·¦å¾€å³ç¼–å·, å°ç«¯åºä»å³å¾€å·¦ç¼–å·, ä»ä¸Šåˆ°ä¸‹ä¾æ¬¡å¢åŠ                             ä½åºç¼–å·          0          1          2          3          4          5          6          7                                      0x00          0          0          0          0          0          0          0          0                          0x4e          0          1          0          0          1          1          1          0                          0xa4          1          0          1          0          0          1          0          0                          0x01          0          0          0          0          0          0          0          1                          0x80          1          0          0          0          0          0          0          0                          0x20          0          0          1          0          0          0          0          0                          0x01          0          0          0          0          0          0          0          1                          0x7f          0          1          1          1          1          1          1          1                          æ ¹æ®ä¿¡å·æè¿°è·å–å¯¹åº”å­—èŠ‚è¿™é‡Œä»¥Obj_DistLatä¿¡å·ä½œä¸ºç¤ºä¾‹.å¦‚ä¸Šæ‰€ç¤º,åœ¨dbcä¸­å®šä¹‰çš„èµ·å§‹ä½start_bit = 18, é•¿åº¦length = 11.å¤§ç«¯åºçš„å®é™…èµ·å§‹ä½éœ€è¦è½¬æ¢, å°ç«¯åºæ— éœ€è½¬æ¢,è½¬æ¢å¦‚ä¸‹:    start_bit = 8 * (start_bit / 8) + (7 - (start_bit % 8));        è½¬æ¢ä¹‹åä¸º stat_bit = 21, length = 11,          ç„¶åä»ä½å›¾ä¸­æ‰¾åˆ°è¿™11ä½æ˜¯ 0xa4çš„å3ä½ åŠ ä¸Š 0x01çš„8ä½å³:100 00000001      ç„¶åæŒ‰ç…§å¤§ç«¯åºæ’åˆ—ä¸º 10000000001, å³10è¿›åˆ¶ä¸ºval = 1025;      ç”±äºå½“å‰ä¿¡å·æ˜¯æ— ç¬¦å·æ•°æ®,æ‰€ä»¥è¡¥ç ç­‰äºæºç ,å¦‚æœæ˜¯æœ‰ç¬¦å·æ•°ä¸”æ˜¯è´Ÿæ•°çš„è¯éœ€è¦å–ååŠ 1è®¡ç®—(åé¢ä¼šä»‹ç»)      ç¼©æ”¾ scale = -0.2, offset = 204.6, val = val * -0.2 + 204.6 = -0.4      å³ç®—å¾— Obj_DistLatåœ¨å½“å‰å¸§çš„å€¼ä¸º-0.4, å…¶ä»–ä¿¡å·æŒ‰æ­¤æ­¥éª¤è®¡ç®—å¯å¾—        {    &quot;Obj_DistLong&quot;: 3.2000000000000455,     &quot;Obj_VrelLong&quot;: 0.0,     &quot;Obj_DynProp&quot;: 1,     &quot;Obj_ID&quot;: 0,     &quot;Obj_RCS&quot;: -0.5,     &quot;Obj_VrelLat&quot;: 0.0,     &quot;Obj_DistLat&quot;: -0.4000000000000057}        è‡³æ­¤å½“å‰å¸§è§£æå®Œæ¯•.  å°ç«¯åºåˆ—cveé‡‡é›†åˆ°çš„ä¸€æ¡x1jæŠ¥æ–‡:0x76d 00 00 00 00 ae 1f 00 00å…¶0x76dæŠ¥æ–‡å®šä¹‰å¦‚ä¸‹:BO_ 1901 KeyCarFrameA1: 8 MINIEYE_TRANSMITTER SG_ on_route : 1|1@1+ (1,0) [0|1] &quot;&quot; Vector__XXX SG_ TargetVehicle_Status : 20|4@1+ (1,0) [0|15] &quot;&quot; Vector__XXX SG_ TargetVehicle_Width : 24|8@1+ (0.05,0) [0|12.5] &quot;M&quot; Vector__XXX SG_ FCW : 0|1@1+ (1,0) [0|1] &quot;&quot;  ADAS SG_ Vehicle_ID : 2|6@1+ (1,0) [0|63] &quot;&quot;  ADAS SG_ TargetVehicle_PosX : 8|12@1+ (0.0625,0) [0|250] &quot;m&quot;  ADAS SG_ TargetVehicle_PosY : 32|10@1- (0.0625,0) [-31.9375|31.9375] &quot;m&quot;  ADAS SG_ TargetVehicle_Type : 48|3@1+ (1,0) [0|7] &quot;&quot;  ADASè¿™é‡Œè€ƒè™‘TargetVehicle_PosY, ç”±ä¸Šé¢åˆ†æå¯å¾— start_bit = 32, length = 10, scale = 0.0625, offset = 0,å°ç«¯åº, æœ‰ç¬¦å·.      æ„å»ºä½å›¾  æ­¤æ—¶ä½åºä¸å¤§ç«¯åºå·åˆšåˆšç›¸å                            ä½åºç¼–å·          7          6          5          4          3          2          1          0                                      0x00          0          0          0          0          0          0          0          0                          0x00          0          0          0          0          0          0          0          0                          0x00          0          0          0          0          0          0          0          0                          0x00          0          0          0          0          0          0          0          0                          0xae          1          0          1          0          1          1          1          0                          0x1f          0          0          0          1          1          1          1          1                          0x00          0          0          0          0          0          0          0          0                          0x00          0          0          0          0          0          0          0          0                      ç„¶åä»ä½å›¾ä¸­æ‰¾åˆ°è¿™10ä½æ˜¯ 0xae åŠ ä¸Š 0xffçš„åä¸¤ä½ å³:10101110 11  ç„¶åæŒ‰ç…§å°ç«¯åºæ’åˆ—ä¸º 1110101110, å³10è¿›åˆ¶ä¸ºval = 942;  ç”±äºå½“å‰ä¿¡å·æ˜¯æœ‰ç¬¦å·æ•°æ®,ä¸”æœ€é«˜ä½ä¸º1,åˆ™è¯´æ˜è¯¥å€¼ä¸ºè´Ÿæ•°,éœ€è¦å–è¡¥ç ,è¡¥ç ä¸ºåŸç å–ååŠ 1,åˆ™:val = ((~val) + 1) *-1 = -82  ç¼©æ”¾åŠ åå·®ä¸ºval = val * 0.0625 + 0 = -5.125      å³ç®—å¾— TargetVehicle_PosYåœ¨å½“å‰å¸§çš„å€¼ä¸º-5.125, å…¶ä»–ä¿¡å·æŒ‰æ­¤æ­¥éª¤è®¡ç®—å¯å¾—      {      &quot;TargetVehicle_PosX&quot;: 0.0,       &quot;TargetVehicle_Status&quot;: 0,       &quot;TargetVehicle_Type&quot;: 0,       &quot;FCW&quot;: 0,       &quot;on_route&quot;: 0,       &quot;TargetVehicle_PosY&quot;: -5.125,       &quot;Vehicle_ID&quot;: 0,       &quot;TargetVehicle_Width&quot;: 0.0  }      å®ç°// å®šä¹‰æ•°æ®ç»“æ„typedef struct can_frame{    int can_id;    uint8_t can_data[8];}can_frame;typedef struct singal{    int start;    int length;    float scale;    float offest;    float min_val;    float max_val;    bool little_order;    bool is_unsigned;    char* name;}singal;typedef struct dbc_message{    string name;    int can_id;    vector&amp;lt;singal&amp;gt; singals;}dbc_message;map&amp;lt;int, dbc_message&amp;gt; dbc; map&amp;lt;string, map&amp;lt;int, string&amp;gt; &amp;gt; val_table;// åŠ è½½dbcvoid add_dbc(char* dbc_path){        FILE* fp = fopen(dbc_path, &quot;r&quot;);        char buf[10086];        int last_bo_id = -1;        while (fgets(buf, 10085, fp) != NULL){            string target(buf);            target.erase(0, target.find_first_not_of(&quot; &quot;));            target.erase(target.find_last_not_of(&quot; &quot;) + 1);            if( target.substr(0, 3) == &quot;BO_&quot;){                regex reg(&quot;BO_\\\\s+(\\\\d+)\\\\s+(\\\\w+):&quot;);                smatch sm;                regex_search(target, sm, reg);                if(sm.empty()) continue;                               string desc = sm[2];                long long can_id = atoll(sm[1].str().c_str());                if(can_id &amp;gt; 0x7ff) can_id -= 0x80000000;                    if (dbc.find(can_id) != dbc.end())                {                    cout &amp;lt;&amp;lt; &quot;can_id conflict &quot; &amp;lt;&amp;lt; endl;                }                dbc_message dm;                dm.can_id = can_id;                dm.name = desc;                dbc[can_id] = dm;                last_bo_id = can_id;            }else if (target.substr(0, 3) == &quot;SG_&quot;){                regex reg(&quot;SG_\\\\s+(\\\\w+)\\\\s+:\\\\s+(\\\\d+)\\\\|(\\\\d+)@(\\\\d+)(.)\\\\s+\\\\((.+?),(.+?)\\\\)\\\\s+\\\\[(.*?)\\\\|(.*?)\\\\]\\\\s+\\&quot;(.*?)\\&quot;&quot;);                smatch sm;                regex_search(target, sm, reg);                if(sm.empty()) continue;                if( last_bo_id == -1) continue;                singal s;                s.name = (char*)malloc(strlen(sm[1].str().c_str()) + 1);                strcpy(s.name, sm[1].str().c_str());                s.start = atoi(sm[2].str().c_str());                s.length = atoi(sm[3].str().c_str());                s.little_order = atoi(sm[4].str().c_str());                s.is_unsigned = sm[5].str() == &quot;+&quot; ? true : false;                s.scale = atof(sm[6].str().c_str());                s.offest = atof(sm[7].str().c_str());                s.min_val = atof(sm[8].str().c_str());                s.max_val = atof(sm[9].str().c_str());                // sm[9] type                dbc[last_bo_id].singals.push_back(s);            }else if( target.substr(0, 4) == &quot;VAL_&quot;){                regex reg(&quot;VAL_\\\\s+(\\\\d+)\\\\s+(\\\\w+)\\\\s+(\\\\d+\\\\s+\\&quot;.+\\&quot;\\\\s*)+&quot;);                smatch sm;                regex_search(target, sm, reg);                if(sm.empty()) continue;                int can_id = atoi(sm[1].str().c_str());                string signal_name = sm[2].str();                string desc = sm[3].str();                string buf;                int desc_sz = desc.size();                int cnt = 0, val = 0;                string real_val = &quot;&quot;;                map&amp;lt;int, string&amp;gt; v = val_table[to_string(can_id) + &quot;_&quot; + signal_name];                for( int i = 0; i &amp;lt; desc_sz; i++) {                    if( desc[i] == &#39;&quot;&#39;) continue;                    if( desc[i] == &#39; &#39;) {                        if(!buf.empty()) {                            if(cnt &amp;amp; 1) {                                // cout &amp;lt;&amp;lt; val &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; buf &amp;lt;&amp;lt; endl;                                v[val] = buf;                            }else{                                val = atoi(buf.c_str());                            }                            buf.clear();                        }                        cnt += 1;                        continue;                    }                    buf += desc[i];                }                val_table[to_string(can_id) + &quot;_&quot; + signal_name] = v;                // for( int i = 0; i &amp;lt; sm.size(); i++ ) cout &amp;lt;&amp;lt; sm[i] &amp;lt;&amp;lt; endl;;            }        }        fclose(fp);        cout &amp;lt;&amp;lt; &quot;add dbc file finish...&quot; &amp;lt;&amp;lt; endl;    }// è§£ç ä¿¡å·double decode(singal s, can_frame t) {        assert(s.length &amp;gt; 0);                // for motorola deal start_bit        if(!s.little_order) s.start = 8 * (s.start / 8) + (7 - (s.start % 8));        uint64_t res = 0;        int now_len = s.length, len = s.length;        int now_start = s.start, start = s.start;        uint8_t buf[8], bit_lengths[8];        int start_bits = start / 8;        int end_bits = ( start + len - 1 ) / 8;        // printf(&quot;%d %d %d\\n&quot;, s.start, s.length, s.little_order);        // printf(&quot;%d %d\\n&quot;, start_bits, end_bits);        for (size_t i = start_bits ; i &amp;lt;= end_bits; i++){             // printf(&quot;%d *\\n&quot;, t.can_data[i]);              int dt = (i+1)*8-now_start;            if( dt &amp;lt;= now_len){                if(! s.little_order) {                    buf[i] = t.can_data[i] &amp;lt;&amp;lt; (8 - dt);                    buf[i] = buf[i] &amp;gt;&amp;gt; (8 - dt);                } else{                    buf[i] = t.can_data[i] &amp;gt;&amp;gt; (8 - dt);                }                now_len -= dt;                now_start += dt;                bit_lengths[i] = dt;            }else{                int now_dt = now_len;                // printf(&quot;\\n%d %d &quot;, dt, now_dt);                if ( ! s.little_order) {                    buf[i] = (t.can_data[i] &amp;lt;&amp;lt; (8 - dt));                    buf[i] = buf[i] &amp;gt;&amp;gt; (8 - now_dt);                }else {                    buf[i] = t.can_data[i] &amp;gt;&amp;gt; ( 8 - dt);                    buf[i] = buf[i] &amp;lt;&amp;lt; (8 - now_dt);                    buf[i] = buf[i] &amp;gt;&amp;gt; (8 - now_dt);                }                               now_len = 0;                now_start += now_dt;                bit_lengths[i] = now_dt;            }            // printf(&quot;%d &amp;amp;\\n&quot;, buf[i]);        }        // printf(&quot;\\n&quot;);        for (size_t i = 0 ; i &amp;lt;= end_bits-start_bits; i++){               uint8_t b = 0;            if( !s.little_order){                // if(i + start_bits + 1 &amp;lt;= end_bits) b = bit_lengths[i + start_bits + 1];                res = res &amp;lt;&amp;lt; bit_lengths[i+start_bits] | buf[i+start_bits];            }else{                // if(end_bits-i-1 &amp;gt;= 0) b = bit_lengths[end_bits-i-1];                res = res &amp;lt;&amp;lt; bit_lengths[end_bits-i] | buf[end_bits-i];            }            // printf(&quot;%d * &quot;, res);        }        // printf(&quot;res :%d\\n&quot;, res);        double real_res = res*1.0;        if (!s.is_unsigned &amp;amp;&amp;amp; (res &amp;gt;&amp;gt; (s.length-1) &amp;amp; 0x1))        {            res = ~res;            res = res &amp;lt;&amp;lt; 64 - s.length &amp;gt;&amp;gt; 64-s.length;            debug(res);            real_res = res*1.0;            debug(real_res);            real_res = (real_res + 1) * -1;            debug(real_res);        }        debug(s.scale);        debug(s.offest);        debug(s.max_val);        debug(s.min_val);        real_res = real_res * s.scale + s.offest;        real_res = real_res &amp;gt; s.max_val ? s.max_val : real_res;        real_res = real_res &amp;lt; s.min_val ? s.min_val : real_res;        // printf(&quot;\\n%f\\n&quot;, real_res);        return real_res;}å®Œæ•´ä»£ç è§can_parser.cpp, éªŒè¯è„šæœ¬è§test_can.py.æœ¬äººæµ‹è¯•cveé‡‡é›†çš„ä¸€ç»„x1jå’Œarsæ•°æ®æ—¶åœ¨1e-5çš„ç²¾åº¦ä¸‹èƒ½ä¿è¯100%å‡†ç¡®ç‡. ç”±äºæœªåšå¤§é‡éªŒè¯,æ— æ³•ä¿è¯å®Œå…¨æ²¡æœ‰é—®é¢˜.ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“python - cantoolsimport cantoolsdbc = cantools.database.load_file(&quot;/home/cao/work-git/cve/cve/dbc/ARS408.dbc&quot;, strict=False)rf = open(&quot;./test_can_parser_data/ars.txt&quot;, &quot;r&quot;)ids = [m.frame_id for m in dbc.messages]for line in rf:    cols = line.split()    can_id = int(cols[3], 16)    data = b&#39;&#39;.join([int(x, 16).to_bytes(1, &#39;little&#39;) for x in cols[4:]])    if can_id in ids:        j = dbc.decode_message(can_id, data, decode_choices=False)        print(json.dumps(j))        breakcpp - dbcc  githubé“¾æ¥ : https://github.com/howerj/dbcc  å®‰è£…å®Œä¹‹å dbcc ARS408.dbc ä¾¿ä¼šç”Ÿæˆdbcå¯¹åº”çš„.h å’Œ.c.      ä½¿ç”¨      #include &quot;ARS408.h&quot;  #include &amp;lt;linux/can.h&amp;gt;  int main(int argc, char const *argv[])  {      can_obj_ars408_h_t t;      double l = -1, lat = -1;      // 1611196534 520939 CAN6 0x60b 00 4e a4 01 80 20 01 7f      uint8_t data[8] = { 0x00, 0x4e, 0xa4, 0x01, 0x80, 0x20, 0x01, 0x7f};      printf(&quot;%lld\\n&quot;, *(uint64_t*)data);      int ret = unpack_message(&amp;amp;t, 0x60b, *(uint64_t*)data, 8, 0);      ret = decode_can_0x60b_Obj_DistLong(&amp;amp;t, &amp;amp;l);      ret = decode_can_0x60b_Obj_DistLat(&amp;amp;t, &amp;amp;lat);      printf(&quot;ret: %d\\n&quot;, ret);      // printf(&quot;dist_long: %lf, dis_lat: %lf, tmp: %lf\\n&quot;, t.can_0x60b_Obj_1_General.Obj_DistLong, t.can_0x60b_Obj_1_General.Obj_DistLat, val);      printf(&quot;dist_long: %lf, dis_lat: %lf\\n&quot;, l, lat);      return 0;  }      "
  },
  
  {
    "title": "PIDæ§åˆ¶å™¨",
    "url": "/posts/pure_pid/",
    "categories": "ç®—æ³•, æ§åˆ¶ç®—æ³•",
    "tags": "PID, åé¦ˆæ§åˆ¶",
    "date": "2021-12-17 00:00:00 +0800",
    





    "snippet": "PIDæ§åˆ¶å™¨  PIDæ§åˆ¶å‚æ•°è¯¦è§£ PID  PIDæ§åˆ¶ï¼Œå³ æ¯”ä¾‹ï¼ˆproportionï¼‰ - ç§¯åˆ†ï¼ˆintegrationï¼‰ - å¾®åˆ†(differentiation) æ§åˆ¶æ˜¯è‡ªåŠ¨æ§åˆ¶åŸç†ä¸­å®šä¹‰çš„ä¸€ç§æ§åˆ¶æ–¹æ³•ä¹Ÿå¯ä»¥ç§°ä¸ºæ˜¯æ ¡æ­£æ–¹æ³•.ç§¯åˆ†å½¢å¼:$U(t) = K_pe(t) + K_i\\int_0^te(t)dt + K_d\\cfrac{de(t)}{dt}$ç¦»æ•£åŒ–:$U(t) = K_pe(t) + K_i\\sum{e(t)} + K_d(e(t) - e(t-1))$å¢é‡å¼:$U(t-1) = K_pe(t-1) + K_i\\sum{e(t-1)} + K_d(e(t-1) - e(t-2))$\\[\\begin{aligned}    \\Delta{U(t)} &amp;amp;= U(t) - U(t-1) \\\\ &amp;amp;=K_p(e(t)-e(t-1)) + K_ie(t) + K_d(e(t)-2e(t-1)+e(t-2))\\end{aligned}\\]å¦‚ä¸Šå›¾æ‰€ç¤ºï¼šKp Ki Kdä¸ºpidä¸‰ä¸ªå‚æ•°.      æ¯”ä¾‹ç¯èŠ‚æˆæ¯”ä¾‹åœ°åæ˜ æ§åˆ¶ç³»ç»Ÿçš„åå·®ä¿¡å·e(t)ï¼Œåå·®ä¸€æ—¦äº§ç”Ÿï¼Œæ§åˆ¶å™¨ç«‹å³äº§ç”Ÿæ§åˆ¶ä½œç”¨ï¼Œä»¥å‡å°åå·®ã€‚å½“ä»…æœ‰æ¯”ä¾‹æ§åˆ¶æ—¶ç³»ç»Ÿè¾“å‡ºå­˜åœ¨ç¨³æ€è¯¯å·®ï¼ˆSteady-state errorï¼‰ä¼˜ç‚¹: è°ƒæ•´ç³»ç»Ÿçš„å¼€ç¯æ¯”ä¾‹ç³»æ•°ï¼Œæé«˜ç³»ç»Ÿçš„ç¨³æ€ç²¾åº¦ï¼Œå‡ä½ç³»ç»Ÿçš„æƒ°æ€§ï¼ŒåŠ å¿«å“åº”é€Ÿåº¦ã€‚ç¼ºç‚¹: ä»…ç”¨Pæ§åˆ¶å™¨,è¿‡å¤§çš„å¼€ç¯æ¯”ä¾‹ç³»æ•°ä¸ä»…ä¼šä½¿ç³»ç»Ÿçš„è¶…è°ƒé‡å¢å¤§ï¼Œè€Œä¸”ä¼šä½¿ç³»ç»Ÿç¨³å®šè£•åº¦å˜å°ï¼Œç”šè‡³ä¸ç¨³å®šã€‚        ç§¯åˆ†ç¯èŠ‚æ§åˆ¶å™¨çš„è¾“å‡ºä¸è¾“å…¥è¯¯å·®ä¿¡å·çš„ç§¯åˆ†æˆæ­£æ¯”å…³ç³»ã€‚ä¸»è¦ç”¨äºæ¶ˆé™¤é™å·®ï¼Œæé«˜ç³»ç»Ÿçš„æ— å·®åº¦ã€‚ç§¯åˆ†ä½œç”¨çš„å¼ºå¼±å–å†³äºç§¯åˆ†æ—¶é—´å¸¸æ•°T,Tè¶Šå¤§ï¼Œç§¯åˆ†ä½œç”¨è¶Šå¼±ï¼Œåä¹‹åˆ™è¶Šå¼ºã€‚ä¼˜ç‚¹ï¼š æ¶ˆé™¤ç¨³æ€è¯¯å·®ã€‚ç¼ºç‚¹ï¼š ç§¯åˆ†æ§åˆ¶å™¨çš„åŠ å…¥ä¼šå½±å“ç³»ç»Ÿçš„ç¨³å®šæ€§ï¼Œä½¿ç³»ç»Ÿçš„ç¨³å®šè£•åº¦å‡å°ã€‚        å¾®åˆ†ç¯èŠ‚åæ˜ åå·®ä¿¡å·çš„å˜åŒ–è¶‹åŠ¿ï¼Œå¹¶èƒ½åœ¨åå·®ä¿¡å·å˜å¾—å¤ªå¤§ä¹‹å‰ï¼Œåœ¨ç³»ç»Ÿä¸­å¼•å…¥ä¸€ä¸ªæœ‰æ•ˆçš„æ—©æœŸä¿®æ­£ä¿¡å·ï¼Œä»è€ŒåŠ å¿«ç³»ç»Ÿçš„åŠ¨ä½œé€Ÿåº¦ï¼Œå‡å°‘è°ƒèŠ‚æ—¶é—´ã€‚åœ¨å¾®åˆ†æ§åˆ¶ä¸­ï¼Œæ§åˆ¶å™¨çš„è¾“å‡ºä¸è¾“å…¥è¯¯å·®ä¿¡å·çš„å¾®åˆ†ï¼ˆå³è¯¯å·®çš„å˜åŒ–ç‡ï¼‰æˆæ­£æ¯”å…³ç³».  æ— æ³•å•ç‹¬èµ·ä½œç”¨ã€‚ä¼˜ç‚¹ï¼šä½¿ç³»ç»Ÿçš„å“åº”é€Ÿåº¦å˜å¿«ï¼Œè¶…è°ƒå‡å°ï¼ŒæŒ¯è¡å‡è½»ï¼Œå¯¹åŠ¨æ€è¿‡ç¨‹æœ‰â€œé¢„æµ‹â€ä½œç”¨ã€‚  ä»£ç å®ç°è¾“å…¥è¯¯å·®ä¸è¾“å…¥å€¼ï¼Œé€šè¿‡å¢é‡å¼pidè°ƒæ•´double PurePid::step_control(double val, double err) {    double res = val;    errs[err_cnt%3] = err;        if(err_cnt &amp;gt;= 3)     {        res += _kp * (errs[err_cnt % 3] - errs[(err_cnt-1) % 3]) + _ki * errs[err_cnt % 3] + _kd * (errs[err_cnt % 3] - 2 * errs[(err_cnt - 1) % 3] + errs[(err_cnt - 2) % 3]);    }    err_cnt++;    return res;}"
  },
  
  {
    "title": "Ndk Chain",
    "url": "/posts/ndk-chain/",
    "categories": "",
    "tags": "",
    "date": "2021-11-15 00:00:00 +0800",
    





    "snippet": "cmake ndk äº¤å‰ç¼–è¯‘      ä»å®˜ç½‘ä¸‹è½½ndk        ç”Ÿæˆç‹¬ç«‹çš„ndkå·¥å…·é“¾     ## ç”Ÿæˆarm64ç‰ˆæœ¬çš„ ./build/tools/make_standalone_toolchain.sh \\ --arch arm64 \\ --install-dir=alone-sdk            cmake é…ç½®     set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -fPIE&quot;) set(CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} -fPIE -pie&quot;) # é…ç½®ä½¿ç”¨ NDK Standalone Toolchain ç¼–è¯‘ set(NDK_STANDALONE_TOOLCHAIN /home/cao/Android/Sdk/ndk/21.3.6528147/alone-sdk) # set(CMAKE_SYSTEM_NAME AndroidARM) # set(CMAKE_SYSTEM_VERSION 3) set(CMAKE_C_COMPILER ${NDK_STANDALONE_TOOLCHAIN}/bin/aarch64-linux-android-gcc) set(CMAKE_CXX_COMPILER ${NDK_STANDALONE_TOOLCHAIN}/bin/aarch64-linux-android-g++) # set(CMAKE_FIND_ROOT_PATH ${NDK_STANDALONE_TOOLCHAIN}) set (CMAKE_ANDROID_ARCH_ABI arm64-v8a) # set (CMAKE_ANDROID_STANDALONE_TOOLCHAIN ~/ndk_toolchain) # ä½¿ç”¨ NDK æä¾›çš„å¤´æ–‡ä»¶ add_definitions(&quot;--sysroot=${NDK_STANDALONE_TOOLCHAIN}/sysroot&quot;)        androidå¼•å…¥so                  å°†ç”Ÿæˆçš„.soæ”¾åˆ°src/main/jniLibs/arm64-v8a/,å¹¶å°†.hå¤åˆ¶åˆ°é»˜è®¤çš„src/main/cpp                    é…ç½®CMakeLists               add_library(dds SHARED IMPORTED) #è®¾ç½®soè·¯åŠ²  ${CMAKE_SOURCE_DIR}æ˜¯CMakeLists.txtçš„è·¯å¾„   ${ANDROID_ABI} æ ‡è¯†cpuç±»å‹ set_target_properties(dds PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/libdds.so) set_property(TARGET dds PROPERTY IMPORTED_NO_SONAME 1) # é“¾æ¥ddsåº“ target_link_libraries( # Specifies the target library.     native-lib     dds     flow_stream     # Links the target library to the log library     # included in the NDK.     ${log-lib})              é…ç½®app/build.gradle         ## defaultConfigä¸‹é…ç½® externalNativeBuild {     cmake {         cppFlags &quot;&quot;         arguments &quot;-DANDROID_STL=c++_shared&quot;     } } ndk {     # è¿™é‡Œåªé…ç½® arm64-v8a,å› ä¸ºåªç”Ÿæˆäº†è¿™ä¸ªç‰ˆæœ¬çš„åº“     abiFilters &#39;arm64-v8a&#39; } ## android æ ‡ç­¾ä¸‹é…ç½® splits {     abi {         enable true         reset()         include &#39;x86&#39;, &#39;x86_64&#39;, &#39;armeabi-v7a&#39;, &#39;arm64-v8a&#39; //select ABIs to build APKs for         universalApk true //generate an additional APK that contains all the ABIs     } } # map for the version code project.ext.versionCodes = [&#39;armeabi&#39;: 1, &#39;armeabi-v7a&#39;: 2, &#39;arm64-v8a&#39;: 3, &#39;mips&#39;: 5, &#39;mips64&#39;: 6, &#39;x86&#39;: 8, &#39;x86_64&#39;: 9] android.applicationVariants.all { variant -&amp;gt;     // assign different version code for each output     variant.outputs.each { output -&amp;gt;         output.versionCodeOverride =                 project.ext.versionCodes.get(output.getFilter(com.android.build.OutputFile.ABI), 0) * 1000000 + android.defaultConfig.versionCode     } }        androidä½¿ç”¨          ä½¿ç”¨é»˜è®¤ç”Ÿæˆnative-lib.cpp includeå¤´æ–‡ä»¶,åˆ›å»ºå¥½æš´éœ²æ¥å£å³å¯      é™„æ•°æ®å¯¹åº” https://blog.csdn.net/smilestone322/article/details/88607717      "
  },
  
  {
    "title": "Ctypes Cpp Demo",
    "url": "/posts/ctypes-cpp-demo/",
    "categories": "",
    "tags": "",
    "date": "2021-11-10 00:00:00 +0800",
    





    "snippet": "cythonè°ƒç”¨c++åŠ¨æ€åº“ç¤ºä¾‹  cppä»£ç æš´éœ²çš„å‡½æ•°å¦‚ä¸‹typedef struct can_frame{    int can_id;    uint8_t can_data[8];}can_frame;typedef struct singal{    int start;    int length;    float scale;    float offest;    float min_val;    float max_val;    bool little_order;    bool is_unsigned;    char* name;}singal;extern &quot;C&quot; {    float decode(singal s, can_frame t);    void add_dbc(char* dbc_path);    char* decode_message(can_frame t, bool use_val_table=true);}  åœ¨cmakeä¸­é€šè¿‡ add_library(test_can SHARED can_parser.cpp) å¯¼å‡ºlibtest_can.so,è‡³æ­¤åŠ¨æ€åº“å¯¼å‡ºå®Œæˆã€‚æ¥ä¸‹æ¥pythonè°ƒç”¨## å¯¼å…¥ctypesfrom ctypes import *## åŠ è½½åŠ¨æ€åº“decode_dll = cdll.LoadLibrary(&quot;/home/cao/CLionProjects/pcv/build/lib/libtest_can.so&quot;)## å®šä¹‰ç»“æ„ä½“ï¼ŒåŒcppå®šä¹‰ä¸€è‡´,å·¦ä¾§ä¸ºå˜é‡åï¼Œå³ä¾§ä¸ºç±»å‹ã€‚å…¶ä¸­cè¯­è¨€ä¸ctypesçš„ç±»å‹è½¬æ¢è§æœ«å°¾class singal(Structure):    _fields_ = [        (&quot;start&quot;, c_int),        (&quot;length&quot;, c_int),        (&quot;scale&quot;, c_float),        (&quot;offest&quot;, c_float),        (&quot;min_val&quot;, c_float),        (&quot;max_val&quot;, c_float),        (&quot;little_order&quot;, c_bool),        (&quot;is_unsigned&quot;, c_bool),        (&quot;name&quot;, c_char_p)    ]class can_frame(Structure):    _fields_ = [        (&quot;can_id&quot;, c_int),        (&quot;can_data&quot;, c_ubyte*8)    ]## è°ƒç”¨add_dbcå‡½æ•°name = c_char_p(bytes(&quot;./dbc/QZ_x1q_20200224.dbc&quot;, &quot;utf-8&quot;)) # str -&amp;gt; bytes -&amp;gt; c_char_pdecode_dll.add_dbc(name)## è°ƒç”¨decodecan_id = 10086can_data = [0, 1, 2, 3, 4, 5, 6, 7]data = (c_ubyte*8)(*can_data)c = can_frame(can_id, data)s = singal(8, 12, 0.0625, 0, 0, 250, True, True, c_char_p(bytes(&quot;test&quot;, &quot;utf-8&quot;)))decode_dll.decode.restype = c_floatpx = decode_dll.decode(s, c)## è°ƒç”¨decode_messagedecode_dll.decode_message.restype = c_char_p  # è®¾ç½®è¿”å›ç±»å‹res = decode_dll.decode_message(c)res = res.decode()  # bytes -&amp;gt; str  é™„å›¾å®˜æ–¹é“¾æ¥åŸºç¡€æ•°æ®ç±»å‹Â¶ctypes å®šä¹‰äº†ä¸€äº›å’ŒCå…¼å®¹çš„åŸºæœ¬æ•°æ®ç±»å‹ï¼šctypes ç±»å‹C ç±»å‹Python ç±»å‹c_bool_Boolbool (1)c_charcharå•å­—ç¬¦å­—èŠ‚å¯¹è±¡c_wcharwchar_tå•å­—ç¬¦å­—ç¬¦ä¸²c_bytecharæ•´å‹c_ubyteunsigned charæ•´å‹c_shortshortæ•´å‹c_ushortunsigned shortæ•´å‹c_intintæ•´å‹c_uintunsigned intæ•´å‹c_longlongæ•´å‹c_ulongunsigned longæ•´å‹c_longlong__int64 æˆ– long longæ•´å‹c_ulonglongunsigned __int64 æˆ– unsigned long longæ•´å‹c_size_tsize_tæ•´å‹c_ssize_tssize_t æˆ– Py_ssize_tæ•´å‹c_floatfloatæµ®ç‚¹æ•°c_doubledoubleæµ®ç‚¹æ•°c_longdoublelong doubleæµ®ç‚¹æ•°c_char_pchar * (ä»¥ NUL ç»“å°¾)å­—èŠ‚ä¸²å¯¹è±¡æˆ– Nonec_wchar_pwchar_t * (ä»¥ NUL ç»“å°¾)å­—ç¬¦ä¸²æˆ– Nonec_void_pvoid *int æˆ– None"
  },
  
  {
    "title": "Shm",
    "url": "/posts/shm/",
    "categories": "",
    "tags": "",
    "date": "2021-10-18 00:00:00 +0800",
    





    "snippet": "é‡‡ç”¨share memory åšipcé€šä¿¡ä»‹ç»      å…±äº«å†…å­˜å°±æ˜¯å…è®¸ä¸¤ä¸ªä¸ç›¸å…³çš„è¿›ç¨‹è®¿é—®åŒä¸€ä¸ªé€»è¾‘å†…å­˜ï¼›å…±äº«å†…å­˜æ˜¯åœ¨ä¸¤ä¸ªæ­£åœ¨è¿è¡Œçš„è¿›ç¨‹ä¹‹é—´å…±äº«å’Œä¼ é€’æ•°æ®çš„ä¸€ç§éå¸¸æœ‰æ•ˆçš„æ–¹å¼ï¼›ä¸åŒè¿›ç¨‹ä¹‹é—´å…±äº«çš„å†…å­˜é€šå¸¸å®‰æ’ä¸ºåŒä¸€æ®µç‰©ç†å†…å­˜ï¼Œè¿›ç¨‹å¯ä»¥å°†åŒä¸€æ®µå…±äº«å†…å­˜è¿æ¥åˆ°å®ƒä»¬è‡ªå·±çš„åœ°å€ç©ºé—´ä¸­ï¼Œæ‰€æœ‰è¿›ç¨‹éƒ½å¯ä»¥è®¿é—®å…±äº«å†…å­˜ä¸­çš„åœ°å€ï¼›è€Œå¦‚æœæŸä¸ªè¿›ç¨‹å‘å…±äº«å†…å­˜å†™å…¥æ•°æ®ï¼Œæ‰€åšçš„æ”¹åŠ¨å°†ç«‹å³å½±å“åˆ°å¯ä»¥è®¿é—®åŒä¸€æ®µå…±äº«å†…å­˜çš„ä»»ä½•å…¶ä»–è¿›ç¨‹ã€‚        å…±äº«å†…å­˜æ˜¯æœ€å¿«çš„å¯ç”¨IPCå½¢å¼ã€‚        å…±äº«å†…å­˜å¹¶æœªæä¾›åŒæ­¥æœºåˆ¶ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨ç¬¬ä¸€ä¸ªè¿›ç¨‹ç»“æŸå¯¹å…±äº«å†…å­˜çš„å†™æ“ä½œä¹‹å‰ï¼Œå¹¶æ— è‡ªåŠ¨æœºåˆ¶å¯ä»¥é˜»æ­¢ç¬¬äºŒä¸ªè¿›ç¨‹å¼€å§‹å¯¹å®ƒè¿›è¡Œè¯»å–ï¼›é€šå¸¸éœ€è¦ç”¨å…¶ä»–çš„æœºåˆ¶æ¥åŒæ­¥å¯¹å…±äº«å†…å­˜çš„è®¿é—®ï¼Œä¾‹å¦‚ä¿¡å·é‡ã€äº’æ–¥é”ã€‚        ä¸»è¦æœ‰ä¸¤ç±»å®ç° System Vï¼Œ Posixä¸¤ç§å®ç°ï¼Œ ä¸¤è€…é—´çš„åŒºåˆ«åŠç®€å•å®ç°ã€‚  æœ¬æ–‡é€šè¿‡Posixå’Œä¿¡å·é‡å®ç°ipcé€šä¿¡é˜Ÿåˆ—å¹¶æ”¯æŒå¤šç”Ÿäº§è€…å’Œå¤šæ¶ˆè´¹è€…ã€‚å®ç°è¿‡ç¨‹åŸç†      è§£é‡Šlä¸ºç¬¬ä¸€ä¸ªæ•°æ®çš„èµ·å§‹ä½ç½®ï¼Œ rä¸ºæœ€åä¸€ä¸ªæ•°æ®çš„èµ·å§‹ä½ç½®ï¼Œidä¸ºå½“å‰å†™å…¥çš„æ•°æ®idï¼ˆé»˜è®¤ä»0é€’å¢ï¼‰ï¼Œdataä¸ºåŸå§‹æ•°æ®ï¼Œd_idä¸ºå½“å‰å†™å…¥æ•°æ®çš„idå€¼ï¼Œsizeä¸ºå½“å‰data+d_id+sizeä¹‹åçš„å¤§å°ã€‚bufä¸ºæ•´ä¸ªå…±äº«å†…å­˜ï¼Œlï¼Œr,idä¸ºheader; size,d_idä¸ºæ•°æ®çš„headerã€‚é™¤äº†buf headerå‰©ä½™çš„ç©ºé—´ä¸ºæ•°æ®åŒºï¼Œæœ¬è´¨æ˜¯ä¸ªå¾ªç¯é˜Ÿåˆ—ï¼Œè¿™é‡Œå¤§å°ä¸ºqueue_size = buf_size - 12ã€‚        è¿‡ç¨‹        å†™æ“ä½œï¼Œè¯»å–l,r,id,å°è£…å½“å‰æ•°æ®ï¼ˆå¢åŠ d_id=id+1å’Œsizeï¼‰,åˆ¤æ–­(r-l+queue_size)%queue_sizeè®¡ç®—å½“å‰å‰©ä½™ç©ºé—´æ˜¯å¦èƒ½å¤Ÿæ”¾ä¸‹å½“å‰æ•°æ®ï¼Œå¦‚æœä¸å¤Ÿï¼Œ(l + l_size)%queue_size,å‰©ä½™ç©ºé—´å¢åŠ l_sizeã€‚å¾ªç¯ä¹‹ï¼Œç›´åˆ°å‰©ä½™ç©ºé—´èƒ½å¤Ÿæ”¾ä¸‹å½“å…ˆæ•°æ®ï¼Œç„¶åå¤åˆ¶åˆ°bufï¼Œå¾—åˆ°æ–°çš„rã€‚æ›´æ–°lï¼Œrï¼Œid=id+1åˆ°buf headerã€‚å†™æ“ä½œå®Œæˆã€‚        è¯»æ“ä½œ, è¯»å–lï¼Œrï¼Œidã€‚read_index,read_fidï¼ˆä¸ºå·²ç»è¯»å–çš„æ•°æ®ä½ç½®ï¼Œæ•°æ®çš„idï¼Œç”±readæ–¹ç»´æŠ¤ï¼‰ï¼Œè®¡ç®—rå¤„çš„r_id,lå¤„çš„l_id.å¦‚æœr_id&amp;lt;=read_fid,åˆ™å½“å‰æ— æ–°æ•°æ®å¯è¯»;å¦‚æœl_id&amp;lt;=read_idï¼Œåˆ™read_indexç§»åŠ¨read_sizeåˆ°ä¸‹ä¸€ä¸ªæ•°æ®çš„èµ·ç‚¹ï¼Œè¯»å–æ•°æ®å³å¯read_index=(read_size + read_index)%queue_size,read_id = read_index_id;å¦‚æœl_id&amp;gt;read_idåˆ™æ•°æ®å·²ç»è¢«è¦†ç›–ï¼Œread_index=l_indexï¼Œread_id=l_idã€‚è‡³æ¬¡è¯»å–æ•°æ®å®Œæ¯•ã€‚        ç”±äºå…±äº«å†…å­˜æ²¡æœ‰åŒæ­¥æ“ä½œï¼Œæ‰€ä»¥æ¯æ¬¡è¯»å†™æ“ä½œä¹‹å‰éƒ½éœ€è¦é€šè¿‡ä¿¡å·é‡æ¥åŒæ­¥ï¼Œç¡®ä¿æ¯æ¬¡è¯»å†™åˆ†ç¦»ã€‚  ä¸»è¦å‡½æ•°è§£é‡Š  prepare()åˆ›å»ºæˆ–æŒ‚è½½å…±äº«å†…å­˜ï¼Œåˆ›å»ºæˆ–ç»‘å®šä¿¡å·é‡void parare(){    int fd = shm_open(topic, O_CREAT | O_EXCL | O_RDWR, 0644);    if (fd == -1){        fd = shm_open(topic, O_EXCL | O_RDWR, 0644);        if( fd == -1) {            perror(&quot;shm_open&quot;);            exit(EXIT_FAILURE);        }      }    if( ftruncate(fd, shm_size) == -1){        perror(&quot;ftruncate&quot;);        exit(EXIT_FAILURE);    }    buf = (uint8_t*)mmap(NULL, shm_size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED, fd, 0);    if (buf == MAP_FAILED){        perror(&quot;mmap&quot;);        exit(EXIT_FAILURE);    }    close(fd);    sem = sem_open(topic, O_CREAT | O_RDWR  | O_EXCL, 0644, 1);    if( sem == SEM_FAILED){        sem = sem_open(topic, O_RDWR  | O_EXCL, 0644, 1);        if(sem == SEM_FAILED) {            perror(&quot;sem_open&quot;);            exit(EXIT_FAILURE);        }    }}  write(uint8_t* data, uint32_t size)è¯»å–æ•°æ®void write(uint8_t* data, uint32_t size){      if( sem_wait(sem) == -1) {        perror(&quot;sem_wait&quot;);        exit(EXIT_FAILURE);    }    uint32_t l = _uint8_2_uint32(0); //    uint32_t r = _uint8_2_uint32(4); //     uint32_t fid = _uint8_2_uint32(8);    // æ„é€ æ•°æ®    uint8_t* tmp = (uint8_t*)malloc(size + 8);    memcpy(tmp+8, data, size);    size += 8;    fid += 1;    for( int i = 0; i &amp;lt; 4; i++ ) tmp[3-i] = size &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    for( int i = 0; i &amp;lt; 4; i++ ) tmp[7-i] = fid &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    int real_size = (( r - l ) + queue_size) % queue_size;    int remain = queue_size - real_size - 1;    while( remain &amp;lt; size) {        uint32_t s = _uint8_2_uint32(l + 1 + head_size);        l = (l + s)%queue_size;        remain += s;    }    if( queue_size - r - 1 &amp;lt; size) {        int dt = size - queue_size + r + 1;        memcpy(buf + r + head_size + 1, tmp, queue_size - r - 1);        memcpy(buf + head_size, tmp + queue_size - r -1, dt);        r = dt - 1;    }else{        memcpy(buf + r + head_size + 1, tmp, size);        r = r + size;    }    for( int i = 0; i &amp;lt; 4; i++ ) buf[3-i] = l &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    for( int i = 0; i &amp;lt; 4; i++ ) buf[7-i] = r &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;        for( int i = 0; i &amp;lt; 4; i++ ) buf[11-i] = fid &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    printf(&quot;write fid is %d\\n&quot;, fid);    if( sem_post(sem) == -1) {        perror(&quot;sem_post&quot;);        exit(EXIT_FAILURE);    }}  uint_8* read()è¯»å–æ•°æ®uint8_t* read(){    if( sem_wait(sem) == -1) {        perror(&quot;sem_wait&quot;);        exit(EXIT_FAILURE);    }    uint32_t l = _uint8_2_uint32(0); //    uint32_t r = _uint8_2_uint32(4); //    uint32_t last_fid = _uint8_2_uint32(8);    if( read_index == -1) {        read_index = (l + 1)%queue_size;    }else{        if(last_fid &amp;lt;= read_fid) {            if( sem_post(sem) == -1) {                perror(&quot;sem_wait&quot;);                exit(EXIT_FAILURE);            }            return NULL;        }        uint32_t mi_fid = _uint8_2_uint32(l + 1 + head_size + 4);          if( mi_fid &amp;lt;= read_fid) {            uint32_t s = _uint8_2_uint32(read_index + head_size);            read_index = (s + read_index) % queue_size;        }else read_index = (l + 1)%queue_size;    }    uint32_t s = _uint8_2_uint32(read_index + head_size);    uint8_t* data = (uint8_t*)malloc(s);    if( s + read_index &amp;gt; queue_size){        uint32_t dt = s + read_index - queue_size;        memcpy(data, buf + head_size + read_index, s - dt);        memcpy(data + s - dt, buf + head_size, dt);    }else{        memcpy(data, buf + head_size + read_index, s);    }    read_fid = _uint8_2_uint32(read_index + head_size + 4);    printf(&quot;read fid os %d\\n&quot;, read_fid);    if( sem_post(sem) == -1) {        perror(&quot;sem_post&quot;);        exit(EXIT_FAILURE);    }    return data;    }  pythonæ¥å£extern &quot;C&quot;{    ShmFlow* shmflow = NULL;    void init_flow(char* topic, int size){        if(shmflow == NULL)  shmflow = new ShmFlow(topic, size);        printf(&quot;shmflow init ok\\n&quot;);    }    void write_data(char* data, int size) {        uint8_t* t = (uint8_t*)data;        shmflow-&amp;gt;write(t, size);    }    int read_data(char* data){        uint8_t* res = shmflow-&amp;gt;read();        if( res == NULL) return 0;        uint32_t tmp = 0;        for( uint32_t i = 0; i &amp;lt; 4; i++) tmp = (tmp &amp;lt;&amp;lt; 8) + res[i];        memcpy(data, res, tmp);        return 1;    }}  pythonè°ƒç”¨ç¤ºä¾‹è¯»å–æ•°æ®def test_shmflow_read():    import cv2    import numpy as np    shmflow_dll = cdll.LoadLibrary(&quot;/home/cao/CLionProjects/pcv/build/lib/libshmflow.so&quot;)    topic = c_char_p(bytes(&quot;video&quot;, &#39;utf-8&#39;))    shmflow_dll.init_flow(topic, 1280*3*720*10)    while True:        d = create_string_buffer(1280 * 3 * 720 * 10)        res = shmflow_dll.read_data(d)        if res == 0:            continue        size = int.from_bytes(d.raw[:4], byteorder=&quot;big&quot;, signed=False)        fid = int.from_bytes(d.raw[4:8], byteorder=&quot;big&quot;, signed=False)        print(fid, size)        d = d.raw[8:size]        png = np.fromstring(d, dtype=np.uint8).reshape((720, 1280, 3))        cv2.imshow(&quot;----&quot;, png)        cv2.waitKey(110)å†™æ•°æ®def test_shmflow_write():    import cv2    img = cv2.imread(&quot;/home/cao/pcview-v2/x1d3_view/pcview_data/20200527112701/cap-fig/20200527-113043-314863-cap.png&quot;)    shmflow_dll = cdll.LoadLibrary(&quot;/home/cao/CLionProjects/pcv/build/lib/libshmflow.so&quot;)    topic = c_char_p(bytes(&quot;video&quot;, &#39;utf-8&#39;))    shmflow_dll.init_flow(topic, 1280 * 3 * 720 * 10)    img = cv2.resize(img, (1280, 720))    img = img.tostring()    # t = np.fromstring(img, dtype=np.uint8).reshape((720, 1280, 3))    # cv2.imshow(&quot;---&quot;, t)    # cv2.waitKey(1000)    cp = c_char_p(img)    shmflow_dll.write_data(cp, 1280*720*3)äºŸå¾…å®Œå–„å†™å’Œå†™äº’æ–¥ï¼Œå†™å’Œè¯»äº’æ–¥ï¼Œè¯»å’Œè¯»ä¸äº’æ–¥æ„Ÿè°¢æ‚¨é˜…è¯»æ­¤æ–‡æ¡£"
  }
  
]

