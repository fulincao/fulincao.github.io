

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://fulincao.github.io/</id>
  <title>fulincao</title>
  <subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle>
  <updated>2022-06-10T19:47:10+08:00</updated>
  <author>
    <name>fulincao</name>
    <uri>https://fulincao.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://fulincao.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://fulincao.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator>
  <rights> © 2022 fulincao </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>动态加载class</title>
    <link href="https://fulincao.github.io/posts/poco/" rel="alternate" type="text/html" title="动态加载class" />
    <published>2022-06-10T00:00:00+08:00</published>
  
    <updated>2022-06-10T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/poco/</id>
    <content src="https://fulincao.github.io/posts/poco/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="C++编程" />
    
  

  
    <summary>
      





      了解一下apollo mainboard的启动流程,觉得挺灵活的。在此记录一下,并自己简单实现了一下demo。

mainboard 启动流程


  启动命令mainboad -d xxx.dag
  读取dag文件，尤其是module_library字段和class_name
  通过poco动态加载module_library，并在module_library中加载class_name
  实例化对象Component
  调用其Init,Proc函数
mainboard根据dag文件动态加载不同的class，执行不同的操作。具有极大的灵活方便且统一调度。同时所有component都基于一个基类ComponentBase，约束了其行为。



  示例dag文件
    module_config {
  module_library : "XXXX.so"
  compone...
    </summary>
  

  </entry>

  
  <entry>
    <title>匈牙利算法</title>
    <link href="https://fulincao.github.io/posts/hungarian/" rel="alternate" type="text/html" title="匈牙利算法" />
    <published>2022-06-09T00:00:00+08:00</published>
  
    <updated>2022-06-09T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/hungarian/</id>
    <content src="https://fulincao.github.io/posts/hungarian/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="算法" />
    
    <category term="关联算法" />
    
  

  
    <summary>
      





      匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。本质是为了解决二分图匹配问题。大致理解如下:
有n个男的，m个女的。男的只能跟女的配对，且只能一对一配对。同时，如果男女配对需要消耗彩礼cost，不同男女之间的彩礼是不一样的。问如何尽可能的配对，同时配对所消耗的彩礼最小。匈牙利本质就是解决这种问题。具体可以看匈牙利算法详解,此算法常用于目标关联，目标融合，目标匹配等场景。本文主要记录如何实现。

cost相同，尽可能匹配多

#include &amp;lt;bits/stdc++.h&amp;gt;
#define INF 0x3f3f3f3f;
using namespace std;
int L[505][505];
int boy[505];
int used[505];
int k,m,n;  //可能的组合数k，女生数m，男生数n 

// 二分图匹配 
bool fi...
    </summary>
  

  </entry>

  
  <entry>
    <title>类型转换</title>
    <link href="https://fulincao.github.io/posts/class-cast/" rel="alternate" type="text/html" title="类型转换" />
    <published>2022-02-25T00:00:00+08:00</published>
  
    <updated>2022-06-07T19:40:47+08:00</updated>
  
    <id>https://fulincao.github.io/posts/class-cast/</id>
    <content src="https://fulincao.github.io/posts/class-cast/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="C++编程" />
    
  

  
    <summary>
      





      C++ 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：


  
    
      关键字
      说明
    
  
  
    
      static_cast
      用于良性转换，一般不会导致意外发生，风险很低。
    
    
      const_cast
      用于 const 与非 const、volatile 与非 volatile 之间的转换。
    
    
      reinterpret_cast
      高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。
    
    
      dynamic_cast
      借助 RTTI，用于类型安全的向下转型（Downcasting）。
    
  



  具...
    </summary>
  

  </entry>

  
  <entry>
    <title>智能指针</title>
    <link href="https://fulincao.github.io/posts/smart-pointer/" rel="alternate" type="text/html" title="智能指针" />
    <published>2022-02-24T00:00:00+08:00</published>
  
    <updated>2022-02-24T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/smart-pointer/</id>
    <content src="https://fulincao.github.io/posts/smart-pointer/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="C++编程" />
    
  

  
    <summary>
      





      RAII与引用计数

  现代c++教程


在传统 C++ 中，需要手动释放资源，有可能就忘记了去释放资源而导致泄露。所以通常的做法是对于一个对象而言，在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。

凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 new 和 delete 去 『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针就包括 std::shared_ptr、std::unique_ptr、std::weak_ptr，使用它们需要包含头文件 。

std::shared_ptr
std::shared_ptr是一种智能指针，它能够记录多少个shared_ptr共同指向一个对...
    </summary>
  

  </entry>

  
  <entry>
    <title>动力学模型</title>
    <link href="https://fulincao.github.io/posts/dynamics_module/" rel="alternate" type="text/html" title="动力学模型" />
    <published>2022-02-09T00:00:00+08:00</published>
  
    <updated>2022-02-09T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/dynamics_module/</id>
    <content src="https://fulincao.github.io/posts/dynamics_module/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="模型" />
    
    <category term="动力学模型" />
    
  

  
    <summary>
      





      车辆动力学模型


  动力学模型


动力学主要研究作用于物体的力与物体运动的关系，车辆动力学模型一般用于分析车辆的平顺性和车辆操纵的稳定性。对于车来说，研究车辆动力学，主要是研究车辆轮胎及其相关部件的受力情况。比如纵向速度控制，通过控制轮胎转速实现；横向航向控制，通过控制轮胎转角实现。

正常情况下，车辆上的作用力沿着三个不同的轴分布：

  纵轴上的力包括驱动力和制动力，以及滚动阻力和拖拽阻力作滚摆运动；
  横轴上的力包括转向力、离心力和侧风力，汽车绕横轴作俯仰运动；
  立轴上的力包括车辆上下振荡施加的力，汽车绕立轴作偏摆或转向运动




而在单车模型假设的前提下，再作如下假设即可简单搭建车辆的动力学模型：

  只考虑纯侧偏轮胎特性，忽略轮胎力的纵横向耦合关系；
  用单车模型来描述车辆的运动，不考虑载荷的左右转移；
  忽略横纵向空气动力学。


其中需要考虑的受力点...
    </summary>
  

  </entry>

</feed>


