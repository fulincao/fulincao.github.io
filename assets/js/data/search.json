[
  
  {
    "title": "Kinematics_module",
    "url": "/posts/kinematics_module/",
    "categories": "",
    "tags": "",
    "date": "2021-12-20 00:00:00 +0800",
    





    "snippet": "运动学模型自行车模型  自行车模型  自行车模型基于如下几个假设：  车辆在垂直方向的运动被忽略掉了，也就是说我们描述的车辆是一个二维平面上的运动物体（可以等价与我们是站在天空中的俯视视角）  假设车辆的结构就像自行车一样，也就是说车辆的前面两个轮胎拥有一直的角度和转速等，同样后面的两个轮胎也是如此，那么前后的轮胎就可以各用一个轮胎来描述  我们假设车辆运动也和自行车一样，这意味着是前面的轮胎控制这车辆的转角自行车运动学模型作为一种自行车模型，运动学自行车模型也假定车辆形如一辆自行车，整个的控制量可以简化为$\\alpha, \\delta_f$.其中$\\alpha$是车辆的加速度，踩油门踏板意味着正的加速度，踩刹车踏板意味着负的加速度。$\\delta_f$是我们的方向盘转角，我们假定这个方向盘转角就是前轮胎当前的转角。这样，我们使用两个量描述了车辆的控制输入(control input)。各变量说明如下：  $\\delta_f$ 前轮转角  $\\psi$ 横摆角，车辆方向  $v$速度方向  $\\beta$ 速度方向与车辆方向夹角  $l_r, l_f$ 质点到前后轴的距离  $x, y$模型的位置其中模型的状态量为：$\\psi, v, x, y$，更新公式如下：\\(\\begin{aligned}    x_{t+1} = x_t + v*\\cos(\\psi + \\beta) * \\Delta{t} \\\\    y_{t+1} = y_t + v*\\sin(\\psi + \\beta) * \\Delta{t} \\\\    v_{t+1} = v_t + \\alpha * \\Delta{t} \\\\    \\psi_{t+1} = \\psi_t + \\frac{v_t}{l_r} * \\sin(\\beta) * \\Delta{t} \\\\    \\beta = \\arctan(\\frac{l_r}{l_r+l_f} * \\tan(\\delta_f))\\end{aligned}\\)其中关于$\\beta$和$\\psi$的推导如下:$$\\begin{aligned}    \\tan(\\delta_f) &amp;amp;= \\dfrac{l_r+l_f}{R}     \\Rightarrow R &amp;amp;=  \\dfrac{l_r + l_f}{\\tan(\\delta_f)} \\\\tan(\\beta) &amp;amp;= \\dfrac{l_r}{R} \\\\\\Rightarrow \\beta &amp;amp;= \\arctan(\\dfrac{l_r}{R}) \\\\                  &amp;amp;= \\arctan(\\dfrac{l_r}{l_r + l_f} * \\tan(\\delta_f)) \\tag{1}\\end{aligned}\\(\\)\\begin{aligned}    \\sin(\\beta) * v &amp;amp;= \\omega * l_r     \\Rightarrow \\omega &amp;amp;=  \\dfrac{\\sin(\\beta)*v}{l_r} \\\\psi_{t+1} &amp;amp;= \\psi_t + \\omega * \\Delta{t} \\\\        &amp;amp;= \\psi_t + \\dfrac{\\sin(\\beta)*v}{l_r} *  \\Delta{t} \\tag{2}\\\\ \\end{aligned} $$代码实现class KinematicModel(object):    def __init__(self, x, y, psi, v, f_len, r_len):        self.x = x        self.y = y        self.psi = psi        self.v = v        self.f_len = f_len        self.r_len = r_len    def get_state(self):        return self.x, self.y, self.psi, self.v    def update_state(self, a, delta, dt):        beta = math.atan((self.r_len / (self.r_len + self.f_len)) * math.tan(delta))        self.x = self.x + self.v * math.cos(self.psi + beta) * dt        self.y = self.y + self.v * math.sin(self.psi + beta) * dt        self.psi = self.psi + (self.v / self.f_len) * math.sin(beta) * dt        self.v = self.v + a * dt        return self.x, self.y, self.psi, self.v"
  },
  
  {
    "title": "Pure_pursuit",
    "url": "/posts/pure_pursuit/",
    "categories": "",
    "tags": "",
    "date": "2021-12-18 00:00:00 +0800",
    





    "snippet": "PurePursuit 纯预瞄算法阿克曼转向  阿克曼转向  阿克曼转向是一种现代汽车的转向方式，在汽车转弯的时候，内外轮转过的角度不一样，内侧轮胎转弯半径小于外侧轮胎。根据阿克曼转向几何设计的车辆，沿着弯道转弯时，利用四连杆的相等曲柄使内侧轮的转向角比外侧轮大大约2~4度，使四个轮子路径的圆心大致上交会于后轴的延长线上瞬时转向中心，让车辆可以顺畅的转弯.下图就是理想的阿克曼转向。$\\alpha$汽车内轮转角$\\beta$汽车外轮转角K两主销中心距离L轴距R转弯半径转动形式:  仅前轮转向，后轮角度不变。  前后轮均可转向。  (1) 前后轮角度相反，(2) 前后轮角度相同，这种模式可以实现全向运动。转向特性的特点：  汽车直线行驶时，4个车轮的轴线都互相平行，而且垂直于汽车纵向中心面。  汽车在转向行驶过程中，全部车轮都必须绕一个瞬时中心点做圆周滚动。核心公式      $\\cot\\beta - \\cot\\alpha = \\cfrac{K}{L}$        $\\tan\\beta = \\cfrac{L}{R}$  PurePursuit  纯预瞄算法  上图所⽰为简化的车辆运动学⾃⾏车模型，其后轮中心在蓝⾊虚线表⽰的⽬标轨迹上。本算法通过控制前轮转⻆来追踪下⼀个路点，使车辆可以沿着经过⽬标预瞄点的圆弧⾏驶。物理量描述如下:$R(m)$ 转弯半径$L(m)$ 轴距$\\delta$ 前轮转角$l_d$ 预瞄距离$x_r$预瞄点横坐标$y_r$预瞄点纵坐标$e$横向偏差$\\alpha$车身与预瞄点夹角本质就是已知轴距，预瞄距离，横向偏差求前轮转角:由正弦定理可以知道  $\\cfrac{l_d}{\\sin2\\alpha} = \\cfrac{R}{\\sin{\\cfrac{\\pi - 2\\alpha}{2}}}$  $\\cfrac{l_d}{2\\sin\\alpha\\cos\\alpha} = \\cfrac{R}{\\cos\\alpha}$  $R = \\cfrac{l_d}{2*\\sin\\alpha}$其中  $\\sin\\alpha = \\cfrac{e}{l_d}$那么就有  $R = \\cfrac{l_d^2}{2e}$所以  $\\delta = \\arctan\\cfrac{L}{R} = \\arctan\\cfrac{2Le}{l_d^2}$由上式可知控制器的本质就是对转角进行控制，以减少横向误差为目标的横向控制器。其中$\\cfrac{2L}{l_d^2}$可视为控制器的P参数.L为车辆轴距,$l_d$为设定的预瞄距离.本控制器的控制效果主要取决于预瞄距离的选取,⼀般来说预瞄距离越⻓,控制效果会越平滑,预瞄距离越短，控制效果会越精确（同时也会带来⼀定的震荡）.预瞄距离的选取也和当前车速有关,如以下两种:  $l_d = gv + l_f$其中v为当前车速，g为⼀可调节的参数,$l_f$为预设前视距离  $l_d = Av^2 + Bv + C$其中$A=1/(2a_{max})$, $a_{max}$为最⼤制动加速度.$Av^2$表⽰最短车辆制动距离.B表⽰车辆遇到异常时需要的反应时间, $Bv$则为对应的反应距离, $C$表⽰车辆的最⼩转弯半径.在实际使用的时候，通常不需要规划点切实等于预瞄点，而是在预瞄点附近找一个最接近的规划点，同时还可以用PID调整e值。代码实现预瞄输入自车经纬高以及目标点经纬高，计算车轮转角// 计算预瞄距离double PurePursuit::cal_ld(double vel){    return 1.0 / ( 2 * _max_braking_acc) * vel * vel + _reactime * vel + _min_turning_radius;}// http://www.movable-type.co.uk/scripts/latlong.html// 计算gps两点距离double PurePursuit::cal_gps_distance(double lng1, double lat1, double lng2, double lat2){    double radius_of_earth = 6378137.0;    lng1 = lng1 / 180 * M_PI;    lat1 = lat1 / 180 * M_PI;    lng2 = lng2 / 180 * M_PI;    lat2 = lat2 / 180 * M_PI;    double delt_lat = lat2 - lat1;    double delt_lng = lng2 - lng1;    double a = pow(sin(0.5 * delt_lat), 2) + pow(sin(0.5 * delt_lng), 2) * cos(lat1) * cos(lat2);    double c = 2.0 * atan2(sqrt(a), sqrt(1.0 - a));    return radius_of_earth * c;}// 计算gps两点方位角double PurePursuit::cal_gps_bearing(double lng1, double lat1, double lng2, double lat2){    lng1 = lng1 / 180 * M_PI;    lat1 = lat1 / 180 * M_PI;    lng2 = lng2 / 180 * M_PI;    lat2 = lat2 / 180 * M_PI;    double delt_lat = lat2 - lat1;    double delt_lng = lng2 - lng1;    double y = sin(delt_lng) * cos(lat2);    double x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(delt_lng);    return atan2(y, x); }// 计算横向偏差，yaw为车辆的航向角，正北方向的偏航double PurePursuit::cal_lateral(double lng1, double lat1, double lng2, double lat2, double yaw){    double distance = cal_gps_distance(lng1, lat1, lng2, lat2);    double heading = cal_gps_bearing(lng1, lat1, lng2, lat2);    if (heading &amp;lt; 0) heading += 2 * M_PI;    heading -= yaw;    double x = sin(heading) * distance;    double y = cos(heading) * distance;    return y; }// 计算车辆转角，vel自身车速double PurePursuit::cal_wheel_angle(double lng1, double lat1, double lng2, double lat2, double vel, double yaw){    double ld = cal_ld(vel);    double lateral = cal_lateral(lng1, lat1, lng2, lat2, 0);    return atan(2 * _wheel_base * lateral / ld / ld);}实现2：转换utm坐标系且使用目标点航向计算详细可操作代码见脚本lateral_controller.py    from pyproj import Proj    proj_text = &quot;+proj=utm +zone=50 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs&quot;    trsfm = Proj(proj_text)    path_point = read_global_path(log_path)    # 全局路径转utm    x, y = [], []    for point in path_point:        utm_x, utm_y = trsfm(point[0], point[1])        x.append(utm_x)        y.append(utm_y)    x = np.array(x)    y = np.array(y)    # 计算预瞄距离    ld = max(km.v * g_rate, 2)    dx = km.x - x[target_pts_idx]    dy = km.y - y[target_pts_idx]    euler_dist = math.sqrt(dx**2 + dy**2)    if euler_dist &amp;lt; ld:        target_pts_idx += 1        continue    print(target_pts_idx, ld, euler_dist, dx, dy, km.x, km.y)    cos_target_heading = cos(path_point[target_pts_idx][-1] * DEG_TO_RAD)    sin_target_heading = sin(path_point[target_pts_idx][-1] * DEG_TO_RAD)    # 计算横纵向偏差    # lateral_error = cos_target_heading * dy - sin_target_heading * dx    # print(&quot;lateral_error&quot;, lateral_error)    lateral_error = cos_target_heading * dx - sin_target_heading * dy     longtidual_error = sin_target_heading * dx + cos_target_heading * dy        print(&quot;lateral_error&quot;, lateral_error)    # print(&quot;longtidual_error&quot;, longtidual_error)    # print(&quot;euler_dist:&quot;, math.sqrt(dx**2 + dy**2))    # 计算前轮转角    alpha = atan(2 * 2.9 * lateral_error / euler_dist**2) + kp * lateral_error + ki * (lateral_error - last_error) + kd * (lateral_error - 2*(last_error) + last_last_error)    alpha = min(alpha, 30 * DEG_TO_RAD)    alpha = max(alpha, -30 * DEG_TO_RAD)"
  },
  
  {
    "title": "Pure_pid",
    "url": "/posts/pure_pid/",
    "categories": "",
    "tags": "",
    "date": "2021-12-17 00:00:00 +0800",
    





    "snippet": "PID控制器  PID控制参数详解 PID  PID控制，即 比例（proportion） - 积分（integration） - 微分(differentiation) 控制是自动控制原理中定义的一种控制方法也可以称为是校正方法.积分形式:$U(t) = K_pe(t) + K_i\\int_0^te(t)dt + K_d\\cfrac{de(t)}{dt}$离散化:$U(t) = K_pe(t) + K_i\\sum{e(t)} + K_d(e(t) - e(t-1))$增量式:$U(t-1) = K_pe(t-1) + K_i\\sum{e(t-1)} + K_d(e(t-1) - e(t-2))$\\[\\begin{aligned}    \\Delta{U(t)} &amp;amp;= U(t) - U(t-1) \\\\ &amp;amp;=K_p(e(t)-e(t-1)) + K_ie(t) + K_d(e(t)-2e(t-1)+e(t-2))\\end{aligned}\\]如上图所示：Kp Ki Kd为pid三个参数.      比例环节成比例地反映控制系统的偏差信号e(t)，偏差一旦产生，控制器立即产生控制作用，以减小偏差。当仅有比例控制时系统输出存在稳态误差（Steady-state error）优点: 调整系统的开环比例系数，提高系统的稳态精度，减低系统的惰性，加快响应速度。缺点: 仅用P控制器,过大的开环比例系数不仅会使系统的超调量增大，而且会使系统稳定裕度变小，甚至不稳定。        积分环节控制器的输出与输入误差信号的积分成正比关系。主要用于消除静差，提高系统的无差度。积分作用的强弱取决于积分时间常数T,T越大，积分作用越弱，反之则越强。优点： 消除稳态误差。缺点： 积分控制器的加入会影响系统的稳定性，使系统的稳定裕度减小。        微分环节反映偏差信号的变化趋势，并能在偏差信号变得太大之前，在系统中引入一个有效的早期修正信号，从而加快系统的动作速度，减少调节时间。在微分控制中，控制器的输出与输入误差信号的微分（即误差的变化率）成正比关系.  无法单独起作用。优点：使系统的响应速度变快，超调减小，振荡减轻，对动态过程有“预测”作用。  代码实现输入误差与输入值，通过增量式pid调整double PurePid::step_control(double val, double err) {    double res = val;    errs[err_cnt%3] = err;        if(err_cnt &amp;gt;= 3)     {        res += _kp * (errs[err_cnt % 3] - errs[(err_cnt-1) % 3]) + _ki * errs[err_cnt % 3] + _kd * (errs[err_cnt % 3] - 2 * errs[(err_cnt - 1) % 3] + errs[(err_cnt - 2) % 3]);    }    err_cnt++;    return res;}"
  },
  
  {
    "title": "Pid",
    "url": "/posts/pid/",
    "categories": "",
    "tags": "",
    "date": "2021-12-17 00:00:00 +0800",
    





    "snippet": "PID控制器  PID控制参数详解 PID  PID控制，即 比例（proportion） - 积分（integration） - 微分(differentiation) 控制是自动控制原理中定义的一种控制方法也可以称为是校正方法.积分形式:$U(t) = K_pe(t) + K_i\\int_0^te(t)dt + K_d\\cfrac{de(t)}{dt}$离散化:$U(t) = K_pe(t) + K_i\\sum{e(t)} + K_d(e(t) - e(t-1))$增量式:$U(t-1) = K_pe(t-1) + K_i\\sum{e(t-1)} + K_d(e(t-1) - e(t-2))$\\[\\begin{aligned}    \\Delta{U(t)} &amp;amp;= U(t) - U(t-1) \\\\ &amp;amp;=K_p(e(t)-e(t-1)) + K_ie(t) + K_d(e(t)-2e(t-1)+e(t-2))\\end{aligned}\\]如上图所示：Kp Ki Kd为pid三个参数.      比例环节成比例地反映控制系统的偏差信号e(t)，偏差一旦产生，控制器立即产生控制作用，以减小偏差。当仅有比例控制时系统输出存在稳态误差（Steady-state error）优点: 调整系统的开环比例系数，提高系统的稳态精度，减低系统的惰性，加快响应速度。缺点: 仅用P控制器,过大的开环比例系数不仅会使系统的超调量增大，而且会使系统稳定裕度变小，甚至不稳定。        积分环节控制器的输出与输入误差信号的积分成正比关系。主要用于消除静差，提高系统的无差度。积分作用的强弱取决于积分时间常数T,T越大，积分作用越弱，反之则越强。优点： 消除稳态误差。缺点： 积分控制器的加入会影响系统的稳定性，使系统的稳定裕度减小。        微分环节反映偏差信号的变化趋势，并能在偏差信号变得太大之前，在系统中引入一个有效的早期修正信号，从而加快系统的动作速度，减少调节时间。在微分控制中，控制器的输出与输入误差信号的微分（即误差的变化率）成正比关系.  无法单独起作用。优点：使系统的响应速度变快，超调减小，振荡减轻，对动态过程有“预测”作用。  代码实现输入误差与输入值，通过增量式pid调整double PurePid::step_control(double val, double err) {    double res = val;    errs[err_cnt%3] = err;        if(err_cnt &amp;gt;= 3)     {        res += _kp * (errs[err_cnt % 3] - errs[(err_cnt-1) % 3]) + _ki * errs[err_cnt % 3] + _kd * (errs[err_cnt % 3] - 2 * errs[(err_cnt - 1) % 3] + errs[(err_cnt - 2) % 3]);    }    err_cnt++;    return res;}"
  },
  
  {
    "title": "Can",
    "url": "/posts/can/",
    "categories": "",
    "tags": "",
    "date": "2021-12-16 00:00:00 +0800",
    





    "snippet": "从使用端分享下can解析从个人使用角度以及工作所接触了解的角度分享一下对can的了解, 有什么不对的请多见谅.数据我们一般拿到的can数据一般都是这种样子的            CAN ID      CAN DATA                  0x60b      0x11 0x22 0x33 0x44 0x55 0x66 0x77 0x88      这便是一条完整的can帧, 由id和data组成.其在linux中结构定义如下:#include &amp;lt;linux/can.h&amp;gt;/* CAN payload length and DLC definitions according to ISO 11898-1 */#define CAN_MAX_DLC 8#define CAN_MAX_DLEN 8/* special address description flags for the CAN_ID */#define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */#define CAN_RTR_FLAG 0x40000000U /* remote transmission request */#define CAN_ERR_FLAG 0x20000000U /* error message frame */struct can_frame {    canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */    __u8    can_dlc; /* frame payload length in byte (0 .. CAN_MAX_DLEN) */    __u8    __pad;   /* padding */    __u8    __res0;  /* reserved / padding */    __u8    __res1;  /* reserved / padding */    __u8    data[CAN_MAX_DLEN] __attribute__((aligned(8)));};can帧的主要几类:      数据帧-标准帧: 长度11位,最大值为0x7ff.        数据帧-扩展帧: 长度29位, 可通过canid &amp;amp; CAN_EFF_FLAG == 1 判断.    错误帧: 通过 CAN_ERR_FLAG 判断  远程帧: 通过 CAN_RTR_FLAG 判断其中我们看到最多的是数据帧, 其他帧基本没有看到过.dbc有了数据之后,如何解码出我们所需要的信息呢? 通常情况都是通过dbc来编码或者解码的.DBC是Database Can的缩写，其代表的是CAN的数据库文件，在这个文件中把CAN通讯的信息定义完整.BO_ 1547 Obj_1_General: 8 ARS_ISF SG_ Obj_DynProp : 50|3@0+ (1,0) [0|7] &quot;&quot;  ExternalUnit SG_ Obj_RCS : 63|8@0+ (0.5,-64) [-64|63.5] &quot;dBm²&quot;  ExternalUnit SG_ Obj_VrelLat : 45|9@0+ (0.25,-64) [-64|63.75] &quot;m/s&quot;  ExternalUnit SG_ Obj_ID : 7|8@0+ (1,0) [0|255] &quot;&quot;  ExternalUnit SG_ Obj_DistLong : 15|13@0+ (0.2,-500) [-500|1138.2] &quot;m&quot;  ExternalUnit SG_ Obj_VrelLong : 39|10@0+ (0.25,-128) [-128|127.75] &quot;m/s&quot;  ExternalUnit SG_ Obj_DistLat : 18|11@0+ (-0.2,204.6) [-204.8|204.6] &quot;m&quot;  ExternalUnit上面展示了一段ars的dbc中对canid为1547的can帧描述.其中主要有BO_ 报文, SG_ 信号.一个报文下会有多个信号. 一个报文就是一个can帧,其数据域长度为8字节64位(见前面定义).对于信号,每一行都相信的描述了该信号在数据域中的位置,解码方式等.BO_ (报文)基本格式如下:BO_ MessageId MessageName: MessageSize Transmitter  BO_为关键字，表示报文；  MessageId为定义的报文ID，是以10进制数表示；  MessageName表示该报文的名字  MessageSize表示该报文数据域字节数，为无符号整型数据；  Transmitter表示发送该报文的网络节点；如果该报文没有指定发送节点，则该值需设置为” Vector__XXX”或者不写以1547报文举例说明:BO_ 1547 Obj_1_General: 8 ARS_ISF            定义      描述                  BO_      报文关键字              1547      can id 16进制为0x60b              Obj_1_General      报文名字              8      报文数据域字节数              ARS_ISF      发送该报文的节点      SG_ (信号)基本格式如下:SG_ SignalName : StartBit|SignalSize@ByteOrder ValueType (Factor,Offset) [Min|Max] Unit Receiver  SG_为关键字，表示信号；  SignalName、 StartBit、 SignalSize分别表示该信号的名字、起始位、信号长度；  ByteOrder表示信号的字节顺序：0代表Motorola格式(大端序)，1代表Intel格式(小端序)；  ValueType 表示该信号的数值类型：+表示无符号数，-表示有符号数；  Factor表示因子，Offset表示偏移量；这两个值于该信号的原始值与物理值之间的转换。转换如下：物理值=原始值*因子+偏移量；                              Min          Max表示该信号的最小值和最大值，即指定了该信号值的范围；这两个值为double类型；                      Unit表示该信号的单位，为字符串类型；  Receiver表示该信号的接收节点；若该信号没有指定的接收节点，则必须设置为” Vector__XXX”举例如下:SG_ Obj_DistLat : 18|11@0+ (-0.2,204.6) [-204.8|204.6] “m”  ExternalUnit| 定义| 描述||  —-  | —-  || SG_ | 信号关键字 || Obj_DistLat| 信号名|| 18| 起始位 || 11| 长度||0 | motorola格式(大端序) || +| 无符号数 || -0.2| 缩放因子|| 204.6| 偏移量 || -204.8| 最小值|| 204.6| 最大值 || m| 单位||ExternalUnit| 接收节点|解析通过dbc或者协议文档获取了报文和信号的编解码信息,然后就可以解析出明文.这里还是以conti的ars 408雷达举例.大端序列cve采集到的一条ars报文:0x60b 00 4e a4 01 80 20 01 7f      首先构建位图    将8字节64位数据转成二进制,依次展开  大端序列从左往右编号, 小端序从右往左编号, 从上到下依次增加  |位序编号| 0|1 | 2|3 | 4|5 | 6|7|  |—-|  —-  | —-  |  —-  | —-  |  —-  | —-  |  —-  | —-  |  —-  | —-  |—-|  |0x00|0 |0 |0 |0 |0 |0 |0 |0 |  |0x4e|0 |1 |0 |0 |1 |1 |1 |0 |  |0xa4|1 |0 |1 |0 |0 |1 |0 |0 |  |0x01|0 |0 |0 |0 |0 |0 |0 |1 |  |0x80|1 |0 |0 |0 |0 |0 |0 |0 |  |0x20|0 |0 |1 |0 |0 |0 |0 |0 |  |0x01|0 |0 |0 |0 |0 |0 |0 |1 |  |0x7f|0 |1 |1 |1 |1 |1 |1 |1 |        根据信号描述获取对应字节这里以Obj_DistLat信号作为示例.如上所示,在dbc中定义的起始位start_bit = 18, 长度length = 11.大端序的实际起始位需要转换, 小端序无需转换,转换如下:    start_bit = 8 * (start_bit / 8) + (7 - (start_bit % 8));        转换之后为 stat_bit = 21, length = 11,                  然后从位图中找到这11位是 0xa4的后3位 加上 0x01的8位即:100 00000001            然后按照大端序排列为 10000000001, 即10进制为val = 1025;      由于当前信号是无符号数据,所以补码等于源码,如果是有符号数且是负数的话需要取反加1计算(后面会介绍)      缩放 scale = -0.2, offset = 204.6, val = val * -0.2 + 204.6 = -0.4      即算得 Obj_DistLat在当前帧的值为-0.4, 其他信号按此步骤计算可得        {    &quot;Obj_DistLong&quot;: 3.2000000000000455,     &quot;Obj_VrelLong&quot;: 0.0,     &quot;Obj_DynProp&quot;: 1,     &quot;Obj_ID&quot;: 0,     &quot;Obj_RCS&quot;: -0.5,     &quot;Obj_VrelLat&quot;: 0.0,     &quot;Obj_DistLat&quot;: -0.4000000000000057}        至此当前帧解析完毕.  小端序列cve采集到的一条x1j报文:0x76d 00 00 00 00 ae 1f 00 00其0x76d报文定义如下:BO_ 1901 KeyCarFrameA1: 8 MINIEYE_TRANSMITTER SG_ on_route : 1|1@1+ (1,0) [0|1] &quot;&quot; Vector__XXX SG_ TargetVehicle_Status : 20|4@1+ (1,0) [0|15] &quot;&quot; Vector__XXX SG_ TargetVehicle_Width : 24|8@1+ (0.05,0) [0|12.5] &quot;M&quot; Vector__XXX SG_ FCW : 0|1@1+ (1,0) [0|1] &quot;&quot;  ADAS SG_ Vehicle_ID : 2|6@1+ (1,0) [0|63] &quot;&quot;  ADAS SG_ TargetVehicle_PosX : 8|12@1+ (0.0625,0) [0|250] &quot;m&quot;  ADAS SG_ TargetVehicle_PosY : 32|10@1- (0.0625,0) [-31.9375|31.9375] &quot;m&quot;  ADAS SG_ TargetVehicle_Type : 48|3@1+ (1,0) [0|7] &quot;&quot;  ADAS这里考虑TargetVehicle_PosY, 由上面分析可得 start_bit = 32, length = 10, scale = 0.0625, offset = 0,小端序, 有符号.      构建位图  此时位序与大端序号刚刚相反  |位序编号| 7|6| 5|4| 3|2| 1|0|  |—-|  —-  | —-  |  —-  | —-  |  —-  | —-  |  —-  | —-  |  —-  | —-  |—-|  |0x00|0 |0 |0 |0 |0 |0 |0 |0 |  |0x00|0 |0 |0 |0 |0 |0 |0 |0 |  |0x00|0 |0 |0 |0 |0 |0 |0 |0 |  |0x00|0 |0 |0 |0 |0 |0 |0 |0 |  |0xae|1 |0 |1 |0 |1 |1 |1 |0 |  |0x1f|0 |0 |0 |1 |1 |1 |1 |1 |  |0x00|0 |0 |0 |0 |0 |0 |0 |0 |  |0x00|0 |0 |0 |0 |0 |0 |0 |0 |    然后从位图中找到这10位是 0xae 加上 0xff的后两位 即:10101110 11  然后按照小端序排列为 1110101110, 即10进制为val = 942;  由于当前信号是有符号数据,且最高位为1,则说明该值为负数,需要取补码,补码为原码取反加1,则:val = ((~val) + 1) *-1 = -82  缩放加偏差为val = val * 0.0625 + 0 = -5.125      即算得 TargetVehicle_PosY在当前帧的值为-5.125, 其他信号按此步骤计算可得      {      &quot;TargetVehicle_PosX&quot;: 0.0,       &quot;TargetVehicle_Status&quot;: 0,       &quot;TargetVehicle_Type&quot;: 0,       &quot;FCW&quot;: 0,       &quot;on_route&quot;: 0,       &quot;TargetVehicle_PosY&quot;: -5.125,       &quot;Vehicle_ID&quot;: 0,       &quot;TargetVehicle_Width&quot;: 0.0  }      实现// 定义数据结构typedef struct can_frame{    int can_id;    uint8_t can_data[8];}can_frame;typedef struct singal{    int start;    int length;    float scale;    float offest;    float min_val;    float max_val;    bool little_order;    bool is_unsigned;    char* name;}singal;typedef struct dbc_message{    string name;    int can_id;    vector&amp;lt;singal&amp;gt; singals;}dbc_message;map&amp;lt;int, dbc_message&amp;gt; dbc; map&amp;lt;string, map&amp;lt;int, string&amp;gt; &amp;gt; val_table;// 加载dbcvoid add_dbc(char* dbc_path){        FILE* fp = fopen(dbc_path, &quot;r&quot;);        char buf[10086];        int last_bo_id = -1;        while (fgets(buf, 10085, fp) != NULL){            string target(buf);            target.erase(0, target.find_first_not_of(&quot; &quot;));            target.erase(target.find_last_not_of(&quot; &quot;) + 1);            if( target.substr(0, 3) == &quot;BO_&quot;){                regex reg(&quot;BO_\\\\s+(\\\\d+)\\\\s+(\\\\w+):&quot;);                smatch sm;                regex_search(target, sm, reg);                if(sm.empty()) continue;                               string desc = sm[2];                long long can_id = atoll(sm[1].str().c_str());                if(can_id &amp;gt; 0x7ff) can_id -= 0x80000000;                    if (dbc.find(can_id) != dbc.end())                {                    cout &amp;lt;&amp;lt; &quot;can_id conflict &quot; &amp;lt;&amp;lt; endl;                }                dbc_message dm;                dm.can_id = can_id;                dm.name = desc;                dbc[can_id] = dm;                last_bo_id = can_id;            }else if (target.substr(0, 3) == &quot;SG_&quot;){                regex reg(&quot;SG_\\\\s+(\\\\w+)\\\\s+:\\\\s+(\\\\d+)\\\\|(\\\\d+)@(\\\\d+)(.)\\\\s+\\\\((.+?),(.+?)\\\\)\\\\s+\\\\[(.*?)\\\\|(.*?)\\\\]\\\\s+\\&quot;(.*?)\\&quot;&quot;);                smatch sm;                regex_search(target, sm, reg);                if(sm.empty()) continue;                if( last_bo_id == -1) continue;                singal s;                s.name = (char*)malloc(strlen(sm[1].str().c_str()) + 1);                strcpy(s.name, sm[1].str().c_str());                s.start = atoi(sm[2].str().c_str());                s.length = atoi(sm[3].str().c_str());                s.little_order = atoi(sm[4].str().c_str());                s.is_unsigned = sm[5].str() == &quot;+&quot; ? true : false;                s.scale = atof(sm[6].str().c_str());                s.offest = atof(sm[7].str().c_str());                s.min_val = atof(sm[8].str().c_str());                s.max_val = atof(sm[9].str().c_str());                // sm[9] type                dbc[last_bo_id].singals.push_back(s);            }else if( target.substr(0, 4) == &quot;VAL_&quot;){                regex reg(&quot;VAL_\\\\s+(\\\\d+)\\\\s+(\\\\w+)\\\\s+(\\\\d+\\\\s+\\&quot;.+\\&quot;\\\\s*)+&quot;);                smatch sm;                regex_search(target, sm, reg);                if(sm.empty()) continue;                int can_id = atoi(sm[1].str().c_str());                string signal_name = sm[2].str();                string desc = sm[3].str();                string buf;                int desc_sz = desc.size();                int cnt = 0, val = 0;                string real_val = &quot;&quot;;                map&amp;lt;int, string&amp;gt; v = val_table[to_string(can_id) + &quot;_&quot; + signal_name];                for( int i = 0; i &amp;lt; desc_sz; i++) {                    if( desc[i] == &#39;&quot;&#39;) continue;                    if( desc[i] == &#39; &#39;) {                        if(!buf.empty()) {                            if(cnt &amp;amp; 1) {                                // cout &amp;lt;&amp;lt; val &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; buf &amp;lt;&amp;lt; endl;                                v[val] = buf;                            }else{                                val = atoi(buf.c_str());                            }                            buf.clear();                        }                        cnt += 1;                        continue;                    }                    buf += desc[i];                }                val_table[to_string(can_id) + &quot;_&quot; + signal_name] = v;                // for( int i = 0; i &amp;lt; sm.size(); i++ ) cout &amp;lt;&amp;lt; sm[i] &amp;lt;&amp;lt; endl;;            }        }        fclose(fp);        cout &amp;lt;&amp;lt; &quot;add dbc file finish...&quot; &amp;lt;&amp;lt; endl;    }// 解码信号double decode(singal s, can_frame t) {        assert(s.length &amp;gt; 0);                // for motorola deal start_bit        if(!s.little_order) s.start = 8 * (s.start / 8) + (7 - (s.start % 8));        uint64_t res = 0;        int now_len = s.length, len = s.length;        int now_start = s.start, start = s.start;        uint8_t buf[8], bit_lengths[8];        int start_bits = start / 8;        int end_bits = ( start + len - 1 ) / 8;        // printf(&quot;%d %d %d\\n&quot;, s.start, s.length, s.little_order);        // printf(&quot;%d %d\\n&quot;, start_bits, end_bits);        for (size_t i = start_bits ; i &amp;lt;= end_bits; i++){             // printf(&quot;%d *\\n&quot;, t.can_data[i]);              int dt = (i+1)*8-now_start;            if( dt &amp;lt;= now_len){                if(! s.little_order) {                    buf[i] = t.can_data[i] &amp;lt;&amp;lt; (8 - dt);                    buf[i] = buf[i] &amp;gt;&amp;gt; (8 - dt);                } else{                    buf[i] = t.can_data[i] &amp;gt;&amp;gt; (8 - dt);                }                now_len -= dt;                now_start += dt;                bit_lengths[i] = dt;            }else{                int now_dt = now_len;                // printf(&quot;\\n%d %d &quot;, dt, now_dt);                if ( ! s.little_order) {                    buf[i] = (t.can_data[i] &amp;lt;&amp;lt; (8 - dt));                    buf[i] = buf[i] &amp;gt;&amp;gt; (8 - now_dt);                }else {                    buf[i] = t.can_data[i] &amp;gt;&amp;gt; ( 8 - dt);                    buf[i] = buf[i] &amp;lt;&amp;lt; (8 - now_dt);                    buf[i] = buf[i] &amp;gt;&amp;gt; (8 - now_dt);                }                               now_len = 0;                now_start += now_dt;                bit_lengths[i] = now_dt;            }            // printf(&quot;%d &amp;amp;\\n&quot;, buf[i]);        }        // printf(&quot;\\n&quot;);        for (size_t i = 0 ; i &amp;lt;= end_bits-start_bits; i++){               uint8_t b = 0;            if( !s.little_order){                // if(i + start_bits + 1 &amp;lt;= end_bits) b = bit_lengths[i + start_bits + 1];                res = res &amp;lt;&amp;lt; bit_lengths[i+start_bits] | buf[i+start_bits];            }else{                // if(end_bits-i-1 &amp;gt;= 0) b = bit_lengths[end_bits-i-1];                res = res &amp;lt;&amp;lt; bit_lengths[end_bits-i] | buf[end_bits-i];            }            // printf(&quot;%d * &quot;, res);        }        // printf(&quot;res :%d\\n&quot;, res);        double real_res = res*1.0;        if (!s.is_unsigned &amp;amp;&amp;amp; (res &amp;gt;&amp;gt; (s.length-1) &amp;amp; 0x1))        {            res = ~res;            res = res &amp;lt;&amp;lt; 64 - s.length &amp;gt;&amp;gt; 64-s.length;            debug(res);            real_res = res*1.0;            debug(real_res);            real_res = (real_res + 1) * -1;            debug(real_res);        }        debug(s.scale);        debug(s.offest);        debug(s.max_val);        debug(s.min_val);        real_res = real_res * s.scale + s.offest;        real_res = real_res &amp;gt; s.max_val ? s.max_val : real_res;        real_res = real_res &amp;lt; s.min_val ? s.min_val : real_res;        // printf(&quot;\\n%f\\n&quot;, real_res);        return real_res;}完整代码见can_parser.cpp, 验证脚本见test_can.py.本人测试cve采集的一组x1j和ars数据时在1e-5的精度下能保证100%准确率. 由于未做大量验证,无法保证完全没有问题.使用第三方库python - cantoolsimport cantoolsdbc = cantools.database.load_file(&quot;/home/cao/work-git/cve/cve/dbc/ARS408.dbc&quot;, strict=False)rf = open(&quot;./test_can_parser_data/ars.txt&quot;, &quot;r&quot;)ids = [m.frame_id for m in dbc.messages]for line in rf:    cols = line.split()    can_id = int(cols[3], 16)    data = b&#39;&#39;.join([int(x, 16).to_bytes(1, &#39;little&#39;) for x in cols[4:]])    if can_id in ids:        j = dbc.decode_message(can_id, data, decode_choices=False)        print(json.dumps(j))        breakcpp - dbcc  github链接 : https://github.com/howerj/dbcc  安装完之后 dbcc ARS408.dbc 便会生成dbc对应的.h 和.c.      使用      #include &quot;ARS408.h&quot;  #include &amp;lt;linux/can.h&amp;gt;  int main(int argc, char const *argv[])  {      can_obj_ars408_h_t t;      double l = -1, lat = -1;      // 1611196534 520939 CAN6 0x60b 00 4e a4 01 80 20 01 7f      uint8_t data[8] = { 0x00, 0x4e, 0xa4, 0x01, 0x80, 0x20, 0x01, 0x7f};      printf(&quot;%lld\\n&quot;, *(uint64_t*)data);      int ret = unpack_message(&amp;amp;t, 0x60b, *(uint64_t*)data, 8, 0);      ret = decode_can_0x60b_Obj_DistLong(&amp;amp;t, &amp;amp;l);      ret = decode_can_0x60b_Obj_DistLat(&amp;amp;t, &amp;amp;lat);      printf(&quot;ret: %d\\n&quot;, ret);      // printf(&quot;dist_long: %lf, dis_lat: %lf, tmp: %lf\\n&quot;, t.can_0x60b_Obj_1_General.Obj_DistLong, t.can_0x60b_Obj_1_General.Obj_DistLat, val);      printf(&quot;dist_long: %lf, dis_lat: %lf\\n&quot;, l, lat);      return 0;  }      "
  },
  
  {
    "title": "Ndk Chain",
    "url": "/posts/ndk-chain/",
    "categories": "",
    "tags": "",
    "date": "2021-11-15 00:00:00 +0800",
    





    "snippet": "cmake ndk 交叉编译      从官网下载ndk        生成独立的ndk工具链     ## 生成arm64版本的 ./build/tools/make_standalone_toolchain.sh \\ --arch arm64 \\ --install-dir=alone-sdk            cmake 配置     set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -fPIE&quot;) set(CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} -fPIE -pie&quot;) # 配置使用 NDK Standalone Toolchain 编译 set(NDK_STANDALONE_TOOLCHAIN /home/cao/Android/Sdk/ndk/21.3.6528147/alone-sdk) # set(CMAKE_SYSTEM_NAME AndroidARM) # set(CMAKE_SYSTEM_VERSION 3) set(CMAKE_C_COMPILER ${NDK_STANDALONE_TOOLCHAIN}/bin/aarch64-linux-android-gcc) set(CMAKE_CXX_COMPILER ${NDK_STANDALONE_TOOLCHAIN}/bin/aarch64-linux-android-g++) # set(CMAKE_FIND_ROOT_PATH ${NDK_STANDALONE_TOOLCHAIN}) set (CMAKE_ANDROID_ARCH_ABI arm64-v8a) # set (CMAKE_ANDROID_STANDALONE_TOOLCHAIN ~/ndk_toolchain) # 使用 NDK 提供的头文件 add_definitions(&quot;--sysroot=${NDK_STANDALONE_TOOLCHAIN}/sysroot&quot;)        android引入so                  将生成的.so放到src/main/jniLibs/arm64-v8a/,并将.h复制到默认的src/main/cpp                    配置CMakeLists               add_library(dds SHARED IMPORTED) #设置so路劲  ${CMAKE_SOURCE_DIR}是CMakeLists.txt的路径   ${ANDROID_ABI} 标识cpu类型 set_target_properties(dds PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/libdds.so) set_property(TARGET dds PROPERTY IMPORTED_NO_SONAME 1) # 链接dds库 target_link_libraries( # Specifies the target library.     native-lib     dds     flow_stream     # Links the target library to the log library     # included in the NDK.     ${log-lib})              配置app/build.gradle         ## defaultConfig下配置 externalNativeBuild {     cmake {         cppFlags &quot;&quot;         arguments &quot;-DANDROID_STL=c++_shared&quot;     } } ndk {     # 这里只配置 arm64-v8a,因为只生成了这个版本的库     abiFilters &#39;arm64-v8a&#39; } ## android 标签下配置 splits {     abi {         enable true         reset()         include &#39;x86&#39;, &#39;x86_64&#39;, &#39;armeabi-v7a&#39;, &#39;arm64-v8a&#39; //select ABIs to build APKs for         universalApk true //generate an additional APK that contains all the ABIs     } } # map for the version code project.ext.versionCodes = [&#39;armeabi&#39;: 1, &#39;armeabi-v7a&#39;: 2, &#39;arm64-v8a&#39;: 3, &#39;mips&#39;: 5, &#39;mips64&#39;: 6, &#39;x86&#39;: 8, &#39;x86_64&#39;: 9] android.applicationVariants.all { variant -&amp;gt;     // assign different version code for each output     variant.outputs.each { output -&amp;gt;         output.versionCodeOverride =                 project.ext.versionCodes.get(output.getFilter(com.android.build.OutputFile.ABI), 0) * 1000000 + android.defaultConfig.versionCode     } }        android使用          使用默认生成native-lib.cpp include头文件,创建好暴露接口即可      附数据对应 https://blog.csdn.net/smilestone322/article/details/88607717      "
  },
  
  {
    "title": "Ctypes Cpp Demo",
    "url": "/posts/ctypes-cpp-demo/",
    "categories": "",
    "tags": "",
    "date": "2021-11-10 00:00:00 +0800",
    





    "snippet": "cython调用c++动态库示例  cpp代码暴露的函数如下typedef struct can_frame{    int can_id;    uint8_t can_data[8];}can_frame;typedef struct singal{    int start;    int length;    float scale;    float offest;    float min_val;    float max_val;    bool little_order;    bool is_unsigned;    char* name;}singal;extern &quot;C&quot; {    float decode(singal s, can_frame t);    void add_dbc(char* dbc_path);    char* decode_message(can_frame t, bool use_val_table=true);}  在cmake中通过 add_library(test_can SHARED can_parser.cpp) 导出libtest_can.so,至此动态库导出完成。接下来python调用## 导入ctypesfrom ctypes import *## 加载动态库decode_dll = cdll.LoadLibrary(&quot;/home/cao/CLionProjects/pcv/build/lib/libtest_can.so&quot;)## 定义结构体，同cpp定义一致,左侧为变量名，右侧为类型。其中c语言与ctypes的类型转换见末尾class singal(Structure):    _fields_ = [        (&quot;start&quot;, c_int),        (&quot;length&quot;, c_int),        (&quot;scale&quot;, c_float),        (&quot;offest&quot;, c_float),        (&quot;min_val&quot;, c_float),        (&quot;max_val&quot;, c_float),        (&quot;little_order&quot;, c_bool),        (&quot;is_unsigned&quot;, c_bool),        (&quot;name&quot;, c_char_p)    ]class can_frame(Structure):    _fields_ = [        (&quot;can_id&quot;, c_int),        (&quot;can_data&quot;, c_ubyte*8)    ]## 调用add_dbc函数name = c_char_p(bytes(&quot;./dbc/QZ_x1q_20200224.dbc&quot;, &quot;utf-8&quot;)) # str -&amp;gt; bytes -&amp;gt; c_char_pdecode_dll.add_dbc(name)## 调用decodecan_id = 10086can_data = [0, 1, 2, 3, 4, 5, 6, 7]data = (c_ubyte*8)(*can_data)c = can_frame(can_id, data)s = singal(8, 12, 0.0625, 0, 0, 250, True, True, c_char_p(bytes(&quot;test&quot;, &quot;utf-8&quot;)))decode_dll.decode.restype = c_floatpx = decode_dll.decode(s, c)## 调用decode_messagedecode_dll.decode_message.restype = c_char_p  # 设置返回类型res = decode_dll.decode_message(c)res = res.decode()  # bytes -&amp;gt; str  附图基础数据类型¶ctypes 定义了一些和C兼容的基本数据类型：ctypes 类型C 类型Python 类型c_bool_Boolbool (1)c_charchar单字符字节对象c_wcharwchar_t单字符字符串c_bytechar整型c_ubyteunsigned char整型c_shortshort整型c_ushortunsigned short整型c_intint整型c_uintunsigned int整型c_longlong整型c_ulongunsigned long整型c_longlong__int64 或 long long整型c_ulonglongunsigned __int64 或 unsigned long long整型c_size_tsize_t整型c_ssize_tssize_t 或 Py_ssize_t整型c_floatfloat浮点数c_doubledouble浮点数c_longdoublelong double浮点数c_char_pchar * (以 NUL 结尾)字节串对象或 Nonec_wchar_pwchar_t * (以 NUL 结尾)字符串或 Nonec_void_pvoid *int 或 None[官方链接](https://docs.python.org/zh-cn/3.7/library/ctypes.html &quot;ctypes&quot;)"
  },
  
  {
    "title": "Shm",
    "url": "/posts/shm/",
    "categories": "",
    "tags": "",
    "date": "2021-10-18 00:00:00 +0800",
    





    "snippet": "采用share memory 做ipc通信介绍      共享内存就是允许两个不相关的进程访问同一个逻辑内存；共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式；不同进程之间共享的内存通常安排为同一段物理内存，进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址；而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。        共享内存是最快的可用IPC形式。        共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取；通常需要用其他的机制来同步对共享内存的访问，例如信号量、互斥锁。        主要有两类实现 System V， Posix两种实现， 两者间的区别及简单实现。  本文通过Posix和信号量实现ipc通信队列并支持多生产者和多消费者。实现过程原理      解释l为第一个数据的起始位置， r为最后一个数据的起始位置，id为当前写入的数据id（默认从0递增），data为原始数据，d_id为当前写入数据的id值，size为当前data+d_id+size之后的大小。buf为整个共享内存，l，r,id为header; size,d_id为数据的header。除了buf header剩余的空间为数据区，本质是个循环队列，这里大小为queue_size = buf_size - 12。        过程        写操作，读取l,r,id,封装当前数据（增加d_id=id+1和size）,判断(r-l+queue_size)%queue_size计算当前剩余空间是否能够放下当前数据，如果不够，(l + l_size)%queue_size,剩余空间增加l_size。循环之，直到剩余空间能够放下当先数据，然后复制到buf，得到新的r。更新l，r，id=id+1到buf header。写操作完成。        读操作, 读取l，r，id。read_index,read_fid（为已经读取的数据位置，数据的id，由read方维护），计算r处的r_id,l处的l_id.如果r_id&amp;lt;=read_fid,则当前无新数据可读;如果l_id&amp;lt;=read_id，则read_index移动read_size到下一个数据的起点，读取数据即可read_index=(read_size + read_index)%queue_size,read_id = read_index_id;如果l_id&amp;gt;read_id则数据已经被覆盖，read_index=l_index，read_id=l_id。至次读取数据完毕。        由于共享内存没有同步操作，所以每次读写操作之前都需要通过信号量来同步，确保每次读写分离。  主要函数解释  prepare()创建或挂载共享内存，创建或绑定信号量void parare(){    int fd = shm_open(topic, O_CREAT | O_EXCL | O_RDWR, 0644);    if (fd == -1){        fd = shm_open(topic, O_EXCL | O_RDWR, 0644);        if( fd == -1) {            perror(&quot;shm_open&quot;);            exit(EXIT_FAILURE);        }      }    if( ftruncate(fd, shm_size) == -1){        perror(&quot;ftruncate&quot;);        exit(EXIT_FAILURE);    }    buf = (uint8_t*)mmap(NULL, shm_size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED, fd, 0);    if (buf == MAP_FAILED){        perror(&quot;mmap&quot;);        exit(EXIT_FAILURE);    }    close(fd);    sem = sem_open(topic, O_CREAT | O_RDWR  | O_EXCL, 0644, 1);    if( sem == SEM_FAILED){        sem = sem_open(topic, O_RDWR  | O_EXCL, 0644, 1);        if(sem == SEM_FAILED) {            perror(&quot;sem_open&quot;);            exit(EXIT_FAILURE);        }    }}  write(uint8_t* data, uint32_t size)读取数据void write(uint8_t* data, uint32_t size){      if( sem_wait(sem) == -1) {        perror(&quot;sem_wait&quot;);        exit(EXIT_FAILURE);    }    uint32_t l = _uint8_2_uint32(0); //    uint32_t r = _uint8_2_uint32(4); //     uint32_t fid = _uint8_2_uint32(8);    // 构造数据    uint8_t* tmp = (uint8_t*)malloc(size + 8);    memcpy(tmp+8, data, size);    size += 8;    fid += 1;    for( int i = 0; i &amp;lt; 4; i++ ) tmp[3-i] = size &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    for( int i = 0; i &amp;lt; 4; i++ ) tmp[7-i] = fid &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    int real_size = (( r - l ) + queue_size) % queue_size;    int remain = queue_size - real_size - 1;    while( remain &amp;lt; size) {        uint32_t s = _uint8_2_uint32(l + 1 + head_size);        l = (l + s)%queue_size;        remain += s;    }    if( queue_size - r - 1 &amp;lt; size) {        int dt = size - queue_size + r + 1;        memcpy(buf + r + head_size + 1, tmp, queue_size - r - 1);        memcpy(buf + head_size, tmp + queue_size - r -1, dt);        r = dt - 1;    }else{        memcpy(buf + r + head_size + 1, tmp, size);        r = r + size;    }    for( int i = 0; i &amp;lt; 4; i++ ) buf[3-i] = l &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    for( int i = 0; i &amp;lt; 4; i++ ) buf[7-i] = r &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;        for( int i = 0; i &amp;lt; 4; i++ ) buf[11-i] = fid &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    printf(&quot;write fid is %d\\n&quot;, fid);    if( sem_post(sem) == -1) {        perror(&quot;sem_post&quot;);        exit(EXIT_FAILURE);    }}  uint_8* read()读取数据uint8_t* read(){    if( sem_wait(sem) == -1) {        perror(&quot;sem_wait&quot;);        exit(EXIT_FAILURE);    }    uint32_t l = _uint8_2_uint32(0); //    uint32_t r = _uint8_2_uint32(4); //    uint32_t last_fid = _uint8_2_uint32(8);    if( read_index == -1) {        read_index = (l + 1)%queue_size;    }else{        if(last_fid &amp;lt;= read_fid) {            if( sem_post(sem) == -1) {                perror(&quot;sem_wait&quot;);                exit(EXIT_FAILURE);            }            return NULL;        }        uint32_t mi_fid = _uint8_2_uint32(l + 1 + head_size + 4);          if( mi_fid &amp;lt;= read_fid) {            uint32_t s = _uint8_2_uint32(read_index + head_size);            read_index = (s + read_index) % queue_size;        }else read_index = (l + 1)%queue_size;    }    uint32_t s = _uint8_2_uint32(read_index + head_size);    uint8_t* data = (uint8_t*)malloc(s);    if( s + read_index &amp;gt; queue_size){        uint32_t dt = s + read_index - queue_size;        memcpy(data, buf + head_size + read_index, s - dt);        memcpy(data + s - dt, buf + head_size, dt);    }else{        memcpy(data, buf + head_size + read_index, s);    }    read_fid = _uint8_2_uint32(read_index + head_size + 4);    printf(&quot;read fid os %d\\n&quot;, read_fid);    if( sem_post(sem) == -1) {        perror(&quot;sem_post&quot;);        exit(EXIT_FAILURE);    }    return data;    }  python接口extern &quot;C&quot;{    ShmFlow* shmflow = NULL;    void init_flow(char* topic, int size){        if(shmflow == NULL)  shmflow = new ShmFlow(topic, size);        printf(&quot;shmflow init ok\\n&quot;);    }    void write_data(char* data, int size) {        uint8_t* t = (uint8_t*)data;        shmflow-&amp;gt;write(t, size);    }    int read_data(char* data){        uint8_t* res = shmflow-&amp;gt;read();        if( res == NULL) return 0;        uint32_t tmp = 0;        for( uint32_t i = 0; i &amp;lt; 4; i++) tmp = (tmp &amp;lt;&amp;lt; 8) + res[i];        memcpy(data, res, tmp);        return 1;    }}  python调用示例读取数据def test_shmflow_read():    import cv2    import numpy as np    shmflow_dll = cdll.LoadLibrary(&quot;/home/cao/CLionProjects/pcv/build/lib/libshmflow.so&quot;)    topic = c_char_p(bytes(&quot;video&quot;, &#39;utf-8&#39;))    shmflow_dll.init_flow(topic, 1280*3*720*10)    while True:        d = create_string_buffer(1280 * 3 * 720 * 10)        res = shmflow_dll.read_data(d)        if res == 0:            continue        size = int.from_bytes(d.raw[:4], byteorder=&quot;big&quot;, signed=False)        fid = int.from_bytes(d.raw[4:8], byteorder=&quot;big&quot;, signed=False)        print(fid, size)        d = d.raw[8:size]        png = np.fromstring(d, dtype=np.uint8).reshape((720, 1280, 3))        cv2.imshow(&quot;----&quot;, png)        cv2.waitKey(110)写数据def test_shmflow_write():    import cv2    img = cv2.imread(&quot;/home/cao/pcview-v2/x1d3_view/pcview_data/20200527112701/cap-fig/20200527-113043-314863-cap.png&quot;)    shmflow_dll = cdll.LoadLibrary(&quot;/home/cao/CLionProjects/pcv/build/lib/libshmflow.so&quot;)    topic = c_char_p(bytes(&quot;video&quot;, &#39;utf-8&#39;))    shmflow_dll.init_flow(topic, 1280 * 3 * 720 * 10)    img = cv2.resize(img, (1280, 720))    img = img.tostring()    # t = np.fromstring(img, dtype=np.uint8).reshape((720, 1280, 3))    # cv2.imshow(&quot;---&quot;, t)    # cv2.waitKey(1000)    cp = c_char_p(img)    shmflow_dll.write_data(cp, 1280*720*3)亟待完善写和写互斥，写和读互斥，读和读不互斥感谢您阅读此文档"
  }
  
]

