[
  
  {
    "title": "匈牙利算法",
    "url": "/posts/hungarian/",
    "categories": "算法, 关联算法",
    "tags": "算法, 目标关联",
    "date": "2022-06-09 00:00:00 +0800",
    





    "snippet": "匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。本质是为了解决二分图匹配问题。大致理解如下:有n个男的，m个女的。男的只能跟女的配对，且只能一对一配对。同时，如果男女配对需要消耗彩礼cost，不同男女之间的彩礼是不一样的。问如何尽可能的配对，同时配对所消耗的彩礼最小。匈牙利本质就是解决这种问题。具体可以看匈牙利算法详解,此算法常用于目标关联，目标融合，目标匹配等场景。本文主要记录如何实现。cost相同，尽可能匹配多#include &amp;lt;bits/stdc++.h&amp;gt;#define INF 0x3f3f3f3f;using namespace std;int L[505][505];int boy[505];int used[505];int k,m,n;  //可能的组合数k，女生数m，男生数n // 二分图匹配 bool find(int i){    for(int j=1;j&amp;lt;=n;j++){        if(L[i][j] &amp;amp;&amp;amp; !used[j]){  //跟他有关系而且没有搜索过             used[j]=1;            if(!boy[j] || find(boy[j])){                boy[j]=i;                return true;            }        }    }    return false;}int main(){    while(cin&amp;gt;&amp;gt;k&amp;gt;&amp;gt;m&amp;gt;&amp;gt;n){        memset(L,0,sizeof(L));        memset(boy,0,sizeof(boy));        for(int i=1;i&amp;lt;=k;i++){            int n1,n2;            cin&amp;gt;&amp;gt;n1&amp;gt;&amp;gt;n2;            L[n1][n2]=1;        }        int sum=0;        for(int i=1;i&amp;lt;=m;i++){            memset(used,0,sizeof(used));            if(find(i)) sum++;        }        cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;endl;    }    return 0;} cost不同，尽可能cost最小，递归方法#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int INF = 0x3f3f3f3f;int love[305][305];    // 每个妹子对每个男生的好感度 int ex_girl[305];      // 每个妹子的期望值int ex_boy[305];       // 每个男生的期望值bool vis_girl[305];    // 每一轮匹配匹配过的女生bool vis_boy[305];     // 每一轮匹配匹配过的男生int match[305];        // 每个男生匹配到的妹子 如果没有则为-1int slack[305];        // 每个汉子如果能被妹子倾心最少还需要多少期望值int n;bool dfs(int girl){    vis_girl[girl] = true;    for (int boy = 0; boy &amp;lt; n; boy++) {        if (vis_boy[boy]) continue; // 每一轮匹配 每个男生只尝试一次        int gap = ex_girl[girl] + ex_boy[boy] - love[girl][boy];        if (gap == 0) {  // 如果符合要求            vis_boy[boy] = true;            if (match[boy] == -1 || dfs( match[boy] )) {    // 找到一个没有匹配的男生 或者该男生的妹子可以找到其他人                match[boy] = girl;                return true;            }        }else{            slack[boy] = min(slack[boy], gap);  // slack 可以理解为该男生要得到女生的倾心 还需多少期望值 取最小值 备胎的样子        }    }    return false;}int KM(){    memset(match, -1, sizeof match);    // 初始每个男生都没有匹配的女生    memset(ex_boy, 0, sizeof ex_boy);   // 初始每个男生的期望值为0    // 每个女生的初始期望值是与她相连的男生最大的好感度    for (int i = 0; i &amp;lt; n; i++) {        ex_girl[i] = love[i][0];        for (int j = 1; j &amp;lt; n; j++) {            ex_girl[i] = max(ex_girl[i], love[i][j]);        }    }    // 尝试为每一个女生解决归宿问题    for (int i = 0; i &amp;lt; n; i++) {        fill(slack, slack + n, INF);    // 因为要取最小值 初始化为无穷大        while(1){            // 为每个女生解决归宿问题的方法是 ：如果找不到就降低期望值，直到找到为止            // 记录每轮匹配中男生女生是否被尝试匹配过            memset(vis_girl, false, sizeof vis_girl);            memset(vis_boy, false, sizeof vis_boy);            if(dfs(i)) break;  // 找到归宿 退出            // 如果不能找到 就降低期望值            // 最小可降低的期望值            int d = INF;            for (int j = 0; j &amp;lt; n; j++)                if (!vis_boy[j])    d = min(d, slack[j]);            for (int j = 0; j &amp;lt; n; j++) {                // 所有访问过的女生降低期望值                if (vis_girl[j]) ex_girl[j] -= d;                // 所有访问过的男生增加期望值                if (vis_boy[j]) ex_boy[j] += d;                // 没有访问过的boy 因为girl们的期望值降低，距离得到女生倾心又进了一步！                else slack[j] -= d;            }        }    }    // 匹配完成 求出所有配对的好感度的和    int res = 0;    for (int i = 0; i &amp;lt; n; i++)        res += love[match[i]][i];    return res;}int main(){    while (cin&amp;gt;&amp;gt;n) {        for (int i = 0; i &amp;lt; n; i++)            for (int j = 0; j &amp;lt; n; j++)                cin&amp;gt;&amp;gt;love[i][j];        cout&amp;lt;&amp;lt;KM()&amp;lt;&amp;lt;endl;    }    return 0;}        cost不同，尽可能cost最小，矩阵方法import numpy as npclass Munkres:    def __init__(self, cost: list, inv_eps=1000) -&amp;gt; None:        &quot;&quot;&quot;[summary]        https://brc2.com/the-algorithm-workshop/        Args:            cost (list): [二维权值方阵]        &quot;&quot;&quot;        self.cost = np.array(cost) * inv_eps        self.cost.astype(np.int32)        self.run_cost = self.cost        self.rows = len(cost)        self.cols = len(cost[0])        self.step = 1        self.running = True        assert(self.rows == self.cols)        self.mp = {            1: self.step_one,            2: self.step_two,            3: self.step_three,            4: self.step_four,            5: self.step_five,            6: self.step_six,            7: self.step_seven        }        self.mask = np.zeros((self.rows, self.cols))        self.row_cover = np.zeros(self.rows)        self.col_cover = np.zeros(self.cols)        self.paths = []    def step_one(self):        &quot;&quot;&quot;[summary]            For each row of the matrix, find the smallest element and subtract it from every element in its row.  Go to Step 2        &quot;&quot;&quot;        for i in range(self.rows):            self.run_cost[i] -= min(self.run_cost[i])        self.step = 2    def step_two(self):        &quot;&quot;&quot;[summary]        Find a zero (Z) in the resulting matrix. If there is no starred zero in its row or column, star Z. Repeat for each element in the matrix. Go to Step 3        &quot;&quot;&quot;        for i in range(self.rows):            for j in range(self.cols):                if self.run_cost[i][j] == 0 and self.row_cover[i] == 0 and self.col_cover[j] == 0:                    self.mask[i][j] = 1                    self.row_cover[i] = 1                    self.col_cover[j] = 1        for i in range(self.rows):            self.row_cover[i] = 0        for j in range(self.cols):            self.col_cover[j] = 0        self.step = 3    def step_three(self):        &quot;&quot;&quot;[summary]            Cover each column containing a starred zero.              If K columns are covered, the starred zeros describe a complete set of unique assignments.              In this case, Go to DONE, otherwise, Go to Step 4.        &quot;&quot;&quot;        for i in range(self.rows):            for j in range(self.cols):                if self.mask[i][j] == 1:                    self.col_cover[j] = 1        colcount = np.sum(self.col_cover)        if colcount &amp;gt;= self.rows or colcount &amp;gt;= self.cols:            self.step = 7        else:            self.step = 4    def __find_a_zero(self):        &quot;&quot;&quot;[summary]         Find a noncovered zero        Returns:            [type]: [row, col , default -1]        &quot;&quot;&quot;        r, c = -1, -1        for i in range(self.rows):            for j in range(self.cols):                if self.run_cost[i][j] == 0 and self.row_cover[i] == 0 and self.col_cover[j] == 0:                    return i, j        return r, c    def __find_star_in_row(self, row):        &quot;&quot;&quot;[summary]        Args:            row ([type]): [row]        Returns:            [int]: [find stared col in row, default -1]        &quot;&quot;&quot;        for j in range(self.cols):            if self.mask[row][j] == 1:                return j        return -1    def step_four(self):        &quot;&quot;&quot;[summary]            Find a noncovered zero and prime it.  If there is no starred zero in the row containing this primed zero, Go to Step 5.              Otherwise, cover this row and uncover the column containing the starred zero.             Continue in this manner until there are no uncovered zeros left. Save the smallest uncovered value and Go to Step 6.        &quot;&quot;&quot;        done = False        while not done:            noncover_r, noncover_c = self.__find_a_zero()            if noncover_r == -1:                done = True                self.step = 6            else:                self.mask[noncover_r][noncover_c] = 2                star_col = self.__find_star_in_row(noncover_r)                if star_col != -1:                    self.row_cover[noncover_r] = 1                    self.col_cover[star_col] = 0                else:                    done = True                    self.step = 5                    self.paths.append((noncover_r, noncover_c))    def __find_star_in_col(self, col):        for i in range(self.rows):            if self.mask[i][col] == 1:                return i        return -1    def __find_prime_in_row(self, row):        &quot;&quot;&quot;[summary]        Args:            col ([type]): [col]        Returns:            [int]: [find prime row in col, default -1]        &quot;&quot;&quot;        for j in range(self.cols):            if self.mask[row][j] == 2:                return j        return -1    def step_five(self):        &quot;&quot;&quot;[summary]            Construct a series of alternating primed and starred zeros as follows.  Let Z0 represent the uncovered primed zero found in Step 4.             Let Z1 denote the starred zero in the column of Z0 (if any). Let Z2 denote the primed zero in the row of Z1 (there will always be one).              Continue until the series terminates at a primed zero that has no starred zero in its column.             Unstar each starred zero of the series, star each primed zero of the series, erase all primes and uncover every line in the matrix.  Return to Step 3        &quot;&quot;&quot;                done = False        while not done:            star_r = self.__find_star_in_col(self.paths[-1][1])            if star_r &amp;gt; -1:                self.paths.append( (star_r, self.paths[-1][1]) )            else:                done = True            if not done:                prime_c = self.__find_prime_in_row( self.paths[-1][0] )                self.paths.append( (self.paths[-1][0], prime_c))        # argument path        for i, j in self.paths:            if self.mask[i][j] == 1:                self.mask[i][j] = 0            else:                self.mask[i][j] = 1        # clear covers        for i in range(self.rows):            self.row_cover[i] = 0        for j in range(self.cols):            self.col_cover[j] = 0        # erase prime        for i in range(self.rows):            for j in range(self.cols):                if self.mask[i][j] == 2:                    self.mask[i][j] = 0        self.paths.clear()        self.step = 3    def step_six(self):        &quot;&quot;&quot;[summary]            Add the value found in Step 4 to every element of each covered row, and subtract it from every element of each uncovered column.              Return to Step 4 without altering any stars, primes, or covered lines        &quot;&quot;&quot;        minval = 1 &amp;lt;&amp;lt; 31        for i in range(self.rows):            for j in range(self.cols):                if self.row_cover[i] == 0 and self.col_cover[j] == 0:                    minval = min(self.run_cost[i][j], minval)        for i in range(self.rows):            for j in range(self.cols):                if self.row_cover[i] == 1:                    self.run_cost[i][j] += minval                if self.col_cover[j] == 0:                    self.run_cost[i][j] -= minval        self.step = 4    def step_seven(self):        # print(&quot;done !&quot;)        # print(self.run_cost)        # print(self.mask)        self.running = False    def run(self):        while self.running:            # print(self.step)            self.mp[self.step]()            # print(self.run_cost)            # print(&quot;&quot;)    def get_result(self):        res = []        vis = [0] * self.cols        for i in range(self.rows):            for j in range(self.cols):                if self.mask[i][j] == 1 and vis[j] == 0:                    res.append(j)                    vis[j] = 1                    break        if len(res) != self.rows:            print(&quot;algorithm error ...&quot;)            return None        return resif  __name__ == &quot;__main__&quot;:    cost = [ [1.2, 1., 1.], [1., 1.2, 1.], [1., 1., 1.2]]    mkr = Munkres(cost)    mkr.run()    print(mkr.get_result())以上三种方式中，第三种广泛使用目标关联中。其具体原理见Munkres’ Assignment Algorithm"
  },
  
  {
    "title": "类型转换",
    "url": "/posts/class-cast/",
    "categories": "C++编程",
    "tags": "类型转换",
    "date": "2022-02-25 00:00:00 +0800",
    





    "snippet": "C++ 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：            关键字      说明                  static_cast      用于良性转换，一般不会导致意外发生，风险很低。              const_cast      用于 const 与非 const、volatile 与非 volatile 之间的转换。              reinterpret_cast      高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。              dynamic_cast      借助 RTTI，用于类型安全的向下转型（Downcasting）。        具体实践"
  },
  
  {
    "title": "智能指针",
    "url": "/posts/smart-pointer/",
    "categories": "C++编程",
    "tags": "智能指针",
    "date": "2022-02-24 00:00:00 +0800",
    





    "snippet": "RAII与引用计数  现代c++教程在传统 C++ 中，需要手动释放资源，有可能就忘记了去释放资源而导致泄露。所以通常的做法是对于一个对象而言，在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 new 和 delete 去 『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针就包括 std::shared_ptr、std::unique_ptr、std::weak_ptr，使用它们需要包含头文件 。std::shared_ptrstd::shared_ptr是一种智能指针，它能够记录多少个shared_ptr共同指向一个对象，从而消除显式的调用delete，当引用计数变为零的时候就会将对象自动删除。但还不够，因为使用std::shared_ptr仍然需要使用new来调用，这使得代码出现了某种程度上的不对称,std::make_shared就能够用来消除显式的使用 new，所以std::make_shared会分配创建传入参数中的对象，并返回这个对象类型的std::shared_ptr指针.#include &amp;lt;iostream&amp;gt;#include &amp;lt;memory&amp;gt;int main() {    // auto pointer = new int(10); // illegal, no direct assignment    // Constructed a std::shared_ptr    std::shared_ptr&amp;lt;int&amp;gt; pointer = std::make_shared&amp;lt;int&amp;gt;(10);    std::cout &amp;lt;&amp;lt; *pointer &amp;lt;&amp;lt; std::endl; // 11    return 0;}std::shared_ptr可以通过get() 方法来获取原始指针，通过reset() 来减少一个引用计数，并通过use_count() 来查看一个对象的引用计数。例如：auto pointer = std::make_shared&amp;lt;int&amp;gt;(10);auto pointer2 = pointer; // 引用计数+1auto pointer3 = pointer; // 引用计数+1int *p = pointer.get(); // 这样不会增加引用计数std::cout &amp;lt;&amp;lt; &quot;pointer.use_count() = &quot; &amp;lt;&amp;lt; pointer.use_count() &amp;lt;&amp;lt; std::endl; // 3std::cout &amp;lt;&amp;lt; &quot;pointer2.use_count() = &quot; &amp;lt;&amp;lt; pointer2.use_count() &amp;lt;&amp;lt; std::endl; // 3std::cout &amp;lt;&amp;lt; &quot;pointer3.use_count() = &quot; &amp;lt;&amp;lt; pointer3.use_count() &amp;lt;&amp;lt; std::endl; // 3pointer2.reset();std::cout &amp;lt;&amp;lt; &quot;reset pointer2:&quot; &amp;lt;&amp;lt; std::endl;std::cout &amp;lt;&amp;lt; &quot;pointer.use_count() = &quot; &amp;lt;&amp;lt; pointer.use_count() &amp;lt;&amp;lt; std::endl; // 2std::cout &amp;lt;&amp;lt; &quot;pointer2.use_count() = &quot; &amp;lt;&amp;lt; pointer2.use_count() &amp;lt;&amp;lt; std::endl; // 0, pointer2 已 resetstd::cout &amp;lt;&amp;lt; &quot;pointer3.use_count() = &quot; &amp;lt;&amp;lt; pointer3.use_count() &amp;lt;&amp;lt; std::endl; // 2pointer3.reset();std::cout &amp;lt;&amp;lt; &quot;reset pointer3:&quot; &amp;lt;&amp;lt; std::endl;std::cout &amp;lt;&amp;lt; &quot;pointer.use_count() = &quot; &amp;lt;&amp;lt; pointer.use_count() &amp;lt;&amp;lt; std::endl; // 1std::cout &amp;lt;&amp;lt; &quot;pointer2.use_count() = &quot; &amp;lt;&amp;lt; pointer2.use_count() &amp;lt;&amp;lt; std::endl; // 0std::cout &amp;lt;&amp;lt; &quot;pointer3.use_count() = &quot; &amp;lt;&amp;lt; pointer3.use_count() &amp;lt;&amp;lt; std::endl; // 0, pointer3 已 resetstd::unique_ptrstd::unique_ptr是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全：std::unique_ptr&amp;lt;int&amp;gt; pointer = std::make_unique&amp;lt;int&amp;gt;(10); // make_unique 从 C++14 引入std::unique_ptr&amp;lt;int&amp;gt; pointer2 = pointer; // 非法std::weak_ptrstd::weak_ptr是一种弱引用（相比较而言std::shared_ptr就是一种强引用）。弱引用不会引起引用计数增加.std::weak_ptr没有 * 运算符和 -&amp;gt; 运算符，所以不能够对资源进行操作，它可以用于检查std::shared_ptr是否存在，其expired()方法能在资源未被释放时，会返回 false，否则返回 true；除此之外，它也可以用于获取指向原始对象的 std::shared_ptr 指针，其 lock() 方法在原始对象未被释放时，返回一个指向原始对象的 std::shared_ptr 指针，进而访问原始对象的资源，否则返回nullptr。代码实现一种简单的shared_ptr实现#include &amp;lt;string.h&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;memory&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;std::map&amp;lt;uint64_t, uint64_t&amp;gt; ref_count;template &amp;lt;typename T&amp;gt;class MySharedPointer{private:    T *value_;    uint64_t idx_;public:    MySharedPointer(T &amp;amp;value)    {        value_ = new T;        memcpy(value_, &amp;amp;value, sizeof(T));        idx_ = reinterpret_cast&amp;lt;uint64_t&amp;gt;(value_);        ref_count[idx_] += 1;    }    ~MySharedPointer()    {        std::cout &amp;lt;&amp;lt; *value_ &amp;lt;&amp;lt; std::endl;        uint64_t count = ref_count[idx_];        if (count &amp;gt; 0)        {            count -= 1;            ref_count[idx_] -= 1;        }        if (count &amp;lt;= 0)        {            printf(&quot;destory memory ..\\n&quot;);            delete value_;            ref_count.erase(idx_);        }    }    MySharedPointer(MySharedPointer &amp;amp;others)    {        idx_ = others.idx_;        value_ = others.value_;        ref_count[idx_] += 1;    }};struct TestNode{    int a, b;    double c;    friend std::ostream &amp;amp; operator&amp;lt;&amp;lt; (std::ostream &amp;amp;os, TestNode &amp;amp;c)    {        os &amp;lt;&amp;lt; c.a &amp;lt;&amp;lt; &quot;#&quot; &amp;lt;&amp;lt; c.b &amp;lt;&amp;lt; &quot;#&quot; &amp;lt;&amp;lt; c.c ;        return os;    }};int main(int argc, char *argv[]){    TestNode node;    node.a = node.b = node.c = 10;    MySharedPointer&amp;lt;TestNode&amp;gt; a(node);    MySharedPointer&amp;lt;TestNode&amp;gt; b(a);    return 0;}"
  },
  
  {
    "title": "动力学模型",
    "url": "/posts/dynamics_module/",
    "categories": "模型, 动力学模型",
    "tags": "模型, 动力学学",
    "date": "2022-02-09 00:00:00 +0800",
    





    "snippet": "车辆动力学模型  动力学模型动力学主要研究作用于物体的力与物体运动的关系，车辆动力学模型一般用于分析车辆的平顺性和车辆操纵的稳定性。对于车来说，研究车辆动力学，主要是研究车辆轮胎及其相关部件的受力情况。比如纵向速度控制，通过控制轮胎转速实现；横向航向控制，通过控制轮胎转角实现。正常情况下，车辆上的作用力沿着三个不同的轴分布：  纵轴上的力包括驱动力和制动力，以及滚动阻力和拖拽阻力作滚摆运动；  横轴上的力包括转向力、离心力和侧风力，汽车绕横轴作俯仰运动；  立轴上的力包括车辆上下振荡施加的力，汽车绕立轴作偏摆或转向运动而在单车模型假设的前提下，再作如下假设即可简单搭建车辆的动力学模型：  只考虑纯侧偏轮胎特性，忽略轮胎力的纵横向耦合关系；  用单车模型来描述车辆的运动，不考虑载荷的左右转移；  忽略横纵向空气动力学。其中需要考虑的受力点有：  横向运动：曲线行驶时的离心力，侧偏力等  纵向运动：受总驱动阻力、加速、减速等的影响。总驱动阻力由滚动阻力、拖拽阻力和坡度阻力等构成。横向车辆动力学各变量说明如下：  $m, m_f, m_r$整车质量，前挂质量，后挂质量  $\\delta_f, \\delta_r$ 前后轮转角  $\\alpha_f, \\alpha_r$ 前后轮滑移角  $C_{\\alpha f}, C_{\\alpha r}$ 前后轮侧偏刚度  $\\psi，\\dot{\\psi}$ 航向角，角速度  $V_x, V_y$ 纵横向速度  $F_{yf},F_{yr}$ 前后轮y方向受力  $F_{cf},F_{cr}$ 前后轮侧向力  $l_f, l_r$ 前后轴长度  $I_z=m_f * l_{f}^2 + m_r * l_{r}^2$转动惯量在y轴上：\\(\\begin{aligned}    ma_y = F_{yf} + F_{y_r} \\qquad(1)\\end{aligned}\\)在z轴上：\\(\\begin{aligned}    I_z\\ddot{\\psi} = l_f * F_{yf} - l_r * F_{yr} \\qquad(2)\\end{aligned}\\)y轴方向加速由y轴方向位移相关的加速度$\\ddot{y}$和向心加速度$V_x\\dot{\\psi}$构成：\\(\\begin{aligned}    a_y = \\ddot{y} + V_x\\dot{\\psi} \\qquad(3)\\end{aligned}\\)即:\\(\\begin{aligned}    m(\\ddot{y} + V_x\\dot{\\psi}) =  F_{yf} + F_{y_r} \\qquad(4)\\end{aligned}\\)轮胎收到横向压力，会产生很小的滑移角则前后轮滑移角(默认前轮驱动，后轮不动即后轮偏移角为0):\\(\\begin{aligned}    \\alpha_f &amp;amp;= \\delta_f - \\theta_{vf} \\\\    \\alpha_r &amp;amp;= - \\theta_{vr}\\end{aligned}\\)即前后轮所受横向力为：\\(\\begin{aligned}    F_{yf} &amp;amp;= 2C_{\\alpha f}(\\delta_f - \\theta_{vf}) \\qquad(5)\\\\    F_{yr} &amp;amp;= 2C_{\\alpha r}(-\\theta_{vr}) \\qquad(6) \\\\\\end{aligned}\\)其中$\\theta_{vf},\\theta_{vr}可以通过y方向速度和切线速度计算$：\\(\\begin{aligned}    \\tan(\\theta_{vf}) = \\dfrac{V_y + l_f\\dot{\\psi}}{V_x} \\\\    \\tan(\\theta_{vr}) = \\dfrac{V_y - l_r\\dot{\\psi}}{V_x}\\end{aligned}\\)在小角度下，正切函数和正比例函数相似，因此可以近似为：\\(\\begin{aligned}    \\theta_{vf} = \\dfrac{V_y + l_f\\dot{\\psi}}{V_x} \\qquad(7) \\\\    \\theta_{vr} = \\dfrac{V_y - l_r\\dot{\\psi}}{V_x} \\qquad(8)\\end{aligned}\\)将(5),(6),(7),(8)带入(1)(2)中得到:整理得到动力学模型:代码实现&#39;&#39;&#39;动力学模型模拟&#39;&#39;&#39;import mathimport scipy.linalg as lafrom numpy import fromiterL = 4  # [m]Lr = L / 2.0  # [m]Lf = L - LrCf = 1600.0 * 2.0  # N/radCr = 1700.0 * 2.0  # N/radIz = 1500 * 8  # kg * m^2 =  m_front * l_f^2 + m_rear * l_r^2M = 1500.0 # kgclass DynamicsModel(object):    def __init__(self, x=0.0, y=0.0, yaw=0.0, vx=0.01, vy=0.0, omega=0.0):        self.x = x        self.y = y        self.yaw = yaw        self.vx = vx        self.vy = vy        self.omega = omega    def update_state(self, a, delta, dt=0.1):        self.x = self.x + self.vx * math.cos(self.yaw) * dt - self.vy * math.sin(self.yaw) * dt        self.y = self.y + self.vx * math.sin(self.yaw) * dt + self.vy * math.cos(self.yaw) * dt        self.yaw = self.yaw + self.omega * dt        Ffy = -Cf * math.atan2(((self.vy + Lf * self.omega) / self.vx - delta), 1.0)        Fry = -Cr * math.atan2((self.vy - Lr * self.omega) / self.vx, 1.0)                self.vx = self.vx + (a - Ffy * math.sin(delta) / M + self.vy * self.omega) * dt        self.vy = self.vy + (Fry / M + Ffy * math.cos(delta) / M - self.vx * self.omega) * dt        self.omega = self.omega + (Ffy * Lf * math.cos(delta) - Fry * Lr) / Iz * dt        return self    def get_state(self):        return self.x, self.y, self.yaw, self.v"
  },
  
  {
    "title": "曲率和航向的计算",
    "url": "/posts/curvature_heading/",
    "categories": "数学",
    "tags": "曲率, 航向",
    "date": "2022-01-07 00:00:00 +0800",
    





    "snippet": "曲率和航向  曲率航向曲线的曲率（curvature）就是针对曲线上某个点的切线方向角对弧长的转动率，通过微分来定义，表明曲线偏离直线的程度。数学上表明曲线在某一点的弯曲程度的数值。曲率越大，表示曲线的弯曲程度越大。曲率的倒数就是曲率半径。设曲线直角坐标方程$y = f(x)$且具有二阶导数，那么曲率公式为：\\(\\begin{aligned}    K = \\dfrac{|y^{&#39;&#39;}|}{(1+y^{&#39;2})^{\\dfrac{3}{2}} }\\end{aligned}\\)航向为：\\(\\begin{aligned}    Yaw = \\arctan(y&#39;)\\end{aligned}\\)如果曲线是由参数方程\\(\\begin{aligned}    x &amp;amp;= \\psi(t) \\\\    y &amp;amp;= \\omega(t)\\end{aligned}\\)那么曲率为:\\(\\begin{aligned}  K = \\dfrac{|\\psi&#39;(t)\\omega&#39;&#39;(t) - \\omega&#39;(t)\\psi&#39;&#39;(t)|}{[\\psi^{&#39;2}(t) + \\omega^{&#39;2}(t)]^{\\dfrac{3}{2}}}  \\end{aligned}\\)那么航向为:\\(\\begin{aligned}    Yaw = \\arctan(\\dfrac{\\omega&#39;(t)}{\\psi&#39;(t)})\\end{aligned}\\)附录求导公式：\\(\\begin{aligned}    \\dfrac{dy}{dx} &amp;amp;= \\dfrac{\\dfrac{dy}{dt}}{\\dfrac{dx}{dt}} = \\dfrac{\\omega&#39;(t)}{\\psi&#39;(t)} \\\\    \\dfrac{d^2y}{dx^2} &amp;amp;= \\dfrac{d}{dt}(\\dfrac{dy}{dx})(\\dfrac{1}{\\dfrac{dx}{dt}}) = (\\dfrac{dy}{dx})&#39;(\\dfrac{1}{\\dfrac{dx}{dt}}) \\\\    &amp;amp;=  (\\dfrac{\\omega&#39;(t)}{\\psi&#39;(t)})&#39;(\\dfrac{1}{\\psi&#39;(t)}) \\\\    &amp;amp;= \\dfrac{\\omega^{&#39;2}(t)\\psi^{&#39;}(t) - \\psi^{&#39;2}(t)\\omega^{&#39;}(t)}{\\psi^{&#39;3}(t)}\\end{aligned}\\)"
  },
  
  {
    "title": "三次样条插值",
    "url": "/posts/cubic_spline/",
    "categories": "算法, 控制算法",
    "tags": "样条插值",
    "date": "2022-01-04 00:00:00 +0800",
    





    "snippet": "三次样条(cubic spline)插值  样条插值 PythonRobotics已知某些点而不知道具体方程时候，通常有拟合和插值两种做法。拟合不要求方程通过所有的已知点，整体趋势一致。插值则是每个已知点都必会穿过，但是高阶会出现龙格现象，所以一般采用分段插值。而三次样条插值则是分段采用一元三次方程进行插值问题定义已知n+1个点$[(x_0, y_0), (x_1, y_1),…,(x_{n-1}, y_{n-1}), (x_n, y_n)]$，n个区间段为$[(x0, x1), (x1, x2),…,(x_{n-1}, x_n)]$三次样条就是说每个小区间的曲线是一个三次方程，三次样条方程满足以下条件:  在每个分段小区间$[x_i, x_{i+1}], S(x)=S_i(x) = a_i + b_ix + c_ix^2 + d_ix^3$  满足插值条件，即$S(x_i) = y_i\\qquad(i=0,1,…,n)$  曲线光滑，即$S(x), S’(x), S^{‘’}(x)$连续每个区间$S_i(x)$都有个四个未知数$(a_i, b_i, c_i, d_i)$,有n个小区间，则有4n个未知数，要解出这些未知数，则我们需要4n个方程来求解。求解  所有n-1个内部端点都满足$S_i(x_{i+1}) = y_{i+1}, S_{i+1}(x_{i+1})=y_{i+1}$,则有2(n-1)个方程，再加上首尾两个端点分别满足第一个方程和最后一个方程，则有2n个方程。  其次n-1个内部点的一阶导数应该是连续的，即在第i区间的末点和第i+1区间的起点是同一个点，它们的一阶导数应该也相等,即$S_{i}^{‘}(x_{i+1}) = S_{i+1}^{‘}(x_{i+1})$, 则有n-1个方程。      其次n-1个内部点的二阶导数应该是连续的，即在第i区间的末点和第i+1区间的起点是同一个点，它们的二阶导数应该也相等,即$S_{i}^{‘’}(x_{i+1})=S_{i+1}^{‘’}(x_{i+1})$则有n-1个方程。    边界条件指定最后两个方程          自然边界(Natural Spline)：指定端点二阶导数为0, $S_{0}^{‘’}(x_0) = 0 = S_{n}^{‘’}(x_{n})$      固定边界 ( Clamped Spline ): 指定端点一阶导数，这里分别定为A和B,$S_{0}^{‘}(x_0) = A,S_{n}^{‘}(x_{n}) = B$      非扭结边界( Not-A-Knot Spline ): 强制第一个插值点的三阶导数值等于第二个点的三阶导数值，最后第一个点的三阶导数值等于倒数第二个点的三阶导数值.即 $S_{0}^{‘’’}(x_0) = S_{1}^{‘’’}(x_1), S_{n-1}^{‘’’}(x_{n-1}) = S_{n}^{‘’’}(x_n)$      由以上3点和边界边界条件便可以得到4n个方程。具体推导构造$S_i(x), S’_i(x), S’‘_i(x)$\\(\\begin{aligned}    S_i(x) &amp;amp;= a_i + b_i(x-x_i) + c_i(x-x_i)^2 + d_i(x-x_i)^3 \\qquad(1)\\\\    S&#39;_i(x) &amp;amp;= b_i + 2c_i(x-x_i) + 3d_i(x-x_i)^2 \\\\    S&#39;&#39;_i(x) &amp;amp;= 2c_i + 6d_i(x-x_i) \\\\\\end{aligned}\\)  由$(1)$得\\(\\begin{aligned} S_i(x_i) &amp;amp;= a_i + b_i(x_i-x_i) + c_i(x_i-x_i)^2 + d_i(x_i-x_i)^3 = y_i \\\\ \\therefore a_i &amp;amp;= y_i \\\\\\end{aligned}\\)  用$h_i=x_{i+1} - x_i$表示步长\\(\\begin{aligned} S_i(x_{i+1}) &amp;amp;= a_i + b_i(x_{i+1}-x_i) + c_i(x_{i+1}-x_i)^2 + d_i(x_{i+1}-x_i)^3 = y_{i+1} \\\\ S_i(x_{i+1}) &amp;amp;= a_i + h_ib_i + h_i^2c_i + h_i^3d_i = y_{i+1} \\\\ \\therefore a_i + h_ib_i + h_i^2c_i + h_i^3d_i &amp;amp;= y_{i+1} \\\\\\end{aligned}\\)  由$S_{i}^{‘}(x_{i+1})=S_{i+1}^{‘}(x_{i+1})$得到：\\(\\begin{aligned} S&#39;_i(x_{i+1}) &amp;amp;= b_i + 2c_i(x_{i+1}-x_i) + 3d_i(x_{i+1}-x_i)^2  = b_i + 2h_ic_i +3h_i^2d_i\\\\ S&#39;_{i+1}(x_{i+1}) &amp;amp;= b_{i+1} + 2c_{i+1}(x_{i+1}-x_{i+1}) + 3d_{i+1}(x_{i+1}-x_{i+1})^2 \\\\ \\therefore b_i + 2h_ic_i +3h_i^2d_i &amp;amp;= b_{i+1} \\\\\\end{aligned}\\)  由$S_{i}^{‘’}(x_{i+1})=S_{i+1}^{‘’}(x_{i+1})$得到：\\(\\begin{aligned} S&#39;&#39;_i(x_{i+1}) &amp;amp;= 2c_i + 6d_i(x_{i+1}-x_i) \\\\ S&#39;&#39;_{i+1}(x_{i+1}) &amp;amp;= 2c_{i+1} + 6d_{i+1}(x_{i+1}-x_{i+1}) \\\\ \\therefore 2c_i + 6h_id_i &amp;amp;= 2c_{i+1} \\\\\\end{aligned}\\)  设$m_i = S’‘_i(x_i) = 2*c_i$得到：\\(\\begin{aligned} 2c_i + 6h_id_i &amp;amp;= 2c_{i+1} \\\\ 2m_i + 6h_id_i &amp;amp;= m_{i+1} \\\\ \\therefore d_i &amp;amp;= \\dfrac{m_{i+1} - m_i}{6h_i}\\\\ c_i &amp;amp;= \\dfrac{1}{2}m_i \\\\\\end{aligned}\\)  将$a_i,c_i,d_i$代入$a_i + h_ib_i + h_i^2c_i + h_i^3d_i = y_{i+1}$可得：\\(\\begin{aligned} y_i + h_ib_i + h^2_i*(\\dfrac{1}{2}m_i) + h^3_i*(\\dfrac{m_{i+1} - m_i}{6h_i}) &amp;amp;= y_{i+1} \\\\ \\therefore b_i &amp;amp;= \\dfrac{y_{i+1} - y_i}{h_i} - \\dfrac{h_i}{2}m_i - \\dfrac{h_i}{6}(m_{i+1} - m_i)  \\\\\\end{aligned}\\)  将$a_i,b_i,c_i,d_i$代入$b_i + 2h_ic_i +3h_i^2d_i = b_{i+1}$可得:\\(\\begin{aligned} \\dfrac{y_{i+1} - y_i}{h_i} - \\dfrac{h_i}{2}m_i - \\dfrac{h_i}{6}(m_{i+1} - m_i) + 2h_i(\\dfrac{1}{2}m_i) + 3h_i^2(\\dfrac{m_{i+1} - m_i}{6h_i}) &amp;amp;= \\dfrac{y_{i+2} - y_{i+1}}{h_{i+1}} - \\dfrac{h_{i+1}}{2}m_{i+1} - \\dfrac{h_{i+1}}{6}(m_{i+2} - m_{i+1}) \\\\ h_im_i + 2(h_i + h_{i+1})m_{i+1} + h_{i+1}m_{i+2} &amp;amp;= 6(\\dfrac{y_{i+2} - y_{i+1}}{h_{i+1}} - \\dfrac{y_{i+1} - y_i}{h_i}) \\\\ \\end{aligned} \\\\\\)          其中左边跟$m_i$相关，而右边都是已知的，因此可以构造一个以m为未知数的线性方程组            在自然边界条件时, $m_0 = 0, m_n = 0$:    因此可以高斯消元,Givens Rotation等方式求得$m$从而得到$a_i,b_i,c_i,d_i$        在夹持边界条件下：        在非扭结边界条件下：  在自然条件下，除了构造矩阵显性的求解$Ax=b$，还可以通过数值分析[numerical_analysis_9th.pdf page149]的方法求解:代码实现import mathimport numpy as npimport bisectclass Spline:    &quot;&quot;&quot;    Cubic Spline class    &quot;&quot;&quot;    def __init__(self, x, y):        self.b, self.c, self.d, self.w = [], [], [], []        self.x = x        self.y = y        self.nx = len(x)  # dimension of x        h = np.diff(x) # x(i+1) - x(i)        # calc coefficient c        self.a = [iy for iy in y]        # Ax = B        A = self.__calc_A(h)         B = self.__calc_B(h)        # 解Ax = B，得到的m = 2×c，再构建B的时候除了2,所以此处m = c        self.c = np.linalg.solve(A, B)        #  print(self.c1)        # calc spline coefficient b and d        for i in range(self.nx - 1):            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0            self.b.append(tb)    def calc(self, t):        &quot;&quot;&quot;        Calc position        if t is outside of the input x, return None        &quot;&quot;&quot;        if t &amp;lt; self.x[0]:            return None        elif t &amp;gt; self.x[-1]:            return None        i = self.__search_index(t)        dx = t - self.x[i]        result = self.a[i] + self.b[i] * dx + \\            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0        return result    def calcd(self, t):        &quot;&quot;&quot;        Calc first derivative        if t is outside of the input x, return None        &quot;&quot;&quot;        if t &amp;lt; self.x[0]:            return None        elif t &amp;gt; self.x[-1]:            return None        i = self.__search_index(t)        dx = t - self.x[i]        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0        return result    def calcdd(self, t):        &quot;&quot;&quot;        Calc second derivative        &quot;&quot;&quot;        if t &amp;lt; self.x[0]:            return None        elif t &amp;gt; self.x[-1]:            return None        i = self.__search_index(t)        dx = t - self.x[i]        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx        return result    def __search_index(self, x):        &quot;&quot;&quot;        search data segment index        &quot;&quot;&quot;        return bisect.bisect(self.x, x) - 1    def __calc_A(self, h):        &quot;&quot;&quot;        calc matrix A for spline coefficient c        &quot;&quot;&quot;        A = np.zeros((self.nx, self.nx))        A[0, 0] = 1.0        for i in range(self.nx - 1):            if i != (self.nx - 2):                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])            A[i + 1, i] = h[i]            A[i, i + 1] = h[i]        A[0, 1] = 0.0        A[self.nx - 1, self.nx - 2] = 0.0        A[self.nx - 1, self.nx - 1] = 1.0        #  print(A)        return A    def __calc_B(self, h):        &quot;&quot;&quot;        calc matrix B for spline coefficient c        &quot;&quot;&quot;        B = np.zeros(self.nx)        for i in range(self.nx - 2):            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]        return Bclass NumericalAnalysisSpline(Spline):    def __init__(self, x, y):        self.nx = len(x)        self.a, self.b = np.zeros(self.nx), np.zeros(self.nx)        self.c, self.d = np.zeros(self.nx), np.zeros(self.nx)                self.x = np.copy(x)        self.a = np.copy(y)                self.__cal()    def __cal(self):        l = np.zeros(self.nx)        u = np.zeros(self.nx)        z = np.zeros(self.nx)        A = np.zeros(self.nx)        h = np.diff(self.x)        n = self.nx - 1        for i in range(1, n):            A[i] = 3 * (self.a[i + 1] - self.a[i]) / h[i] - 3 * (self.a[i] - self.a[i - 1]) / h[i - 1];        l[0] = 1            for i in range(1, n):            l[i] = 2 * (self.x[i + 1] - self.x[i - 1]) - h[i - 1] * u[i - 1]            u[i] = h[i] / l[i];            z[i] = (A[i] - h[i - 1] * z[i - 1]) / l[i]        l[n] = 1        for j in range(n-1, -1, -1):            self.c[j] = z[j] - u[j] * self.c[j + 1]            self.b[j] = (self.a[j + 1] - self.a[j]) / h[j] - h[j] * (self.c[j + 1] + 2 * self.c[j]) / 3            self.d[j] = (self.c[j + 1] - self.c[j]) / (3 * h[j])其中2d样条插值(参数方程)的实现如下，有关航向和曲率的解释见对应的文章class Spline2D:    &quot;&quot;&quot;    2D Cubic Spline class    &quot;&quot;&quot;    def __init__(self, x, y):        self.s = self.__calc_s(x, y)        self.sx = Spline(self.s, x)        self.sy = Spline(self.s, y)    def __calc_s(self, x, y):        dx = np.diff(x)        dy = np.diff(y)        # print(&quot;dx:&quot;, dx)        # print(&quot;dy:&quot;, dy)        self.ds = np.hypot(dx, dy)        # print(&quot;ds:&quot;, self.ds)        s = [0]        s.extend(np.cumsum(self.ds))        return s    def calc_position(self, s):        &quot;&quot;&quot;        calc position        &quot;&quot;&quot;        x = self.sx.calc(s)        y = self.sy.calc(s)        return x, y    def calc_curvature(self, s):        &quot;&quot;&quot;        calc curvature        &quot;&quot;&quot;        dx = self.sx.calcd(s)        ddx = self.sx.calcdd(s)        dy = self.sy.calcd(s)        ddy = self.sy.calcdd(s)        k = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))        return k    def calc_yaw(self, s):        &quot;&quot;&quot;        calc yaw        &quot;&quot;&quot;        dx = self.sx.calcd(s)        dy = self.sy.calcd(s)        yaw = math.atan2(dy, dx)        return yawdef calc_spline_course(x, y, ds=0.1):    sp = Spline2D(x, y)    s = list(np.arange(0, sp.s[-1], ds))    rx, ry, ryaw, rk = [], [], [], []    for i_s in s:        ix, iy = sp.calc_position(i_s)        rx.append(ix)        ry.append(iy)        ryaw.append(sp.calc_yaw(i_s))        rk.append(sp.calc_curvature(i_s))    return rx, ry, ryaw, rk, s"
  },
  
  {
    "title": "LQR调节器",
    "url": "/posts/LQR/",
    "categories": "算法, 控制算法",
    "tags": "LQR, 反馈控制",
    "date": "2022-01-03 00:00:00 +0800",
    





    "snippet": "LQR调节器  LQR百度百科 LQR  LQR (linear quadratic regulator)即线性二次型调节器，其对象是现代控制理论中以状态空间形式给出的线性系统，而目标函数为对象状态和控制输入的二次型函数。LQR最优设计是指设计出的状态反馈控制器 K要使二次型目标函数J 取最小值，而 K由权矩阵Q 与 R 唯一决定，故此 Q、 R 的选择尤为重要。LQR理论是现代控制理论中发展最早也最为成熟的一种状态空间设计法。特别可贵的是，LQR可得到状态线性反馈的最优控制规律，易于构成闭环最优控制。推导假设有一个线性系统能用状态向量的形式表示:\\(\\begin{aligned}    \\dot{x} = Ax + Bu \\qquad(1)\\end{aligned}\\)其中$x(t)\\in R^n, u(t)\\in R^m$,其中x为状态变量可观测，u为控制矩阵。全状态反馈控制全状态反馈控制系统如下所示：状态反馈控制器为：\\(\\begin{aligned}    u = -Kx\\end{aligned}\\)使得闭环系统能够满足我们期望的性能。我们把这种控制代入$(1)$得到:\\(\\begin{aligned}    \\dot{x} = (A - BK)x = A_cx\\qquad(2)\\end{aligned}\\)对于$(1)$式的开环系统，由现代控制理论我们知道开环传递函数的极点就是系统矩阵A的特征值。现在变成了$(2)$的闭环形式，状态变换矩阵$A$变成了$(A-BK)$。因此通过配置反馈矩阵$K$，可以使得闭环系统的极点达到我们期望的状态.LQR的目标(损失，能量)函数一般设计如下：\\(\\begin{aligned}    J = \\dfrac{1}{2}\\int^{\\infty}_0(x^TQx + u^TRu)dt \\qquad(3)\\end{aligned}\\)其中$Q,R$通常取为对角阵，$Q$为半正定的状态加权矩阵, $R$为正定的控制加权矩阵.为什么能量函数(或称系统的目标函数)得设计成这个样子呢？    首先假设状态向量x(t)是1维的，那么其实就是一个平方项 Qx^2 &amp;gt;= 0，同理. 能量函数J要最小，那么状态向量x(t)，u(t)都得小。    J最小，那肯定是个有界的函数，我们能推断当t趋于无穷时，状态向量x(t)将趋于0，这也保证了闭环系统的稳定性。    那输入u(t)要小是什么意思呢？它意味着我们用最小的控制代价得到最优的控制。譬如控制电机，输入PWM小，将节省能量。矩阵Q,R的选取?    𝑄矩阵元素变大意味着希望跟踪偏差能够快速趋近于零      𝑅矩阵元素变大意味着希望控制输入能够尽可能小    一般来说，Q值选得大意味着，要使得J小，那x(t)需要更小，也就是意味着闭环系统的矩阵(A-BK)的特征值处于S平面左边更远的地方，这样状态x(t)就以更快的速度衰减到0。    另一方面，大的R表示更加关注输入变量u(t),u(t)的减小，意味着状态衰减将变慢。    同时，Q为半正定矩阵意味着他的特征值非负，R为正定矩阵意味着它的特征值为正数。如果你选择Q,R都是对角矩阵的话，那么Q的对角元素为正数，允许出现几个0.R的对角元素只能是正数。将$u = -Kx$代入$(3)$得到：\\(\\begin{aligned}    J = \\dfrac{1}{2}\\int^{\\infty}_0 x^T(Q + K^TRK)x\\quad dt \\qquad(4)\\end{aligned}\\)为了找到K,我们先不防假设存在一个常量矩阵P使得：\\(\\begin{aligned}    \\dfrac{d}{dt}(x^TPx) = -x^T(Q + K^TRK) \\qquad(5)\\end{aligned}\\)带入$(4)$得: \\(\\begin{aligned}    J = \\dfrac{1}{2}\\int^{\\infty}_0 \\dfrac{d}{dt}(x^TPx)dt = \\dfrac{1}{2}x^T(0)Px(0) \\qquad(6)\\end{aligned}\\)注意，我们已经假设闭环系统是稳定的，也就是t趋于无穷时，x(t)趋于0.现在把(5)式左边的微分展开，并把状态变量x的微分用(2)式替代得到：\\(\\begin{aligned}    \\dot{x}^TPx + x^TP\\dot{x} + x^TQx + x^TK^TRKx = 0 \\\\    x^TA^T_cPx + x^TPA_cx + x^TQx + x^TK^TRKx = 0 \\\\    x^T(A^T_cP + PA_c + Q + K^TRK)x = 0\\end{aligned}\\)这个式子要始终成立的话，括号里的项必须恒等于0.\\(\\begin{aligned}    (A-BK)^TP + P(A-BK) + Q + K^TRK = 0 \\\\    A^TP - K^TB^TP + PA - PBK + Q + K^TRK = 0\\end{aligned}\\)取$K=R^{-1}B^TP$带入得：\\(\\begin{aligned}    A^TP + PA + Q + (R^{-1}B^TP)^TR(R^{-1}B^TP) - (R^{-1}B^TP)^TB^TP - PB(R^{-1}B^TP) &amp;amp;= 0 \\\\    A^TP + PA + Q - PBR^{-1}B^TP &amp;amp;= 0 \\qquad(7)\\end{aligned}\\)K的二次项没有了，可K的取值和P有关，而P是我们假设的一个量，P只要使得的(7)式成立就行了。而(6)式在现代控制理论中极其重要，它就是有名的Riccati方程。一般采用迭代方式解此方程，如下图所示：总结      选择参数矩阵Q,R        求解Riccati 方程得到矩阵P        计算$K=R^{-1}B^TP$        计算$u = -Kx$的到控制量  代码实现输入A B Q R矩阵计算Kimport scipy.linalg as laimport numpy as npdef solve_DARE(A, B, Q, R):    &quot;&quot;&quot;    solve a discrete time_Algebraic Riccati equation (DARE)    &quot;&quot;&quot;    X = Q    maxiter = 150    eps = 0.01    for i in range(maxiter):        Xn = A.T @ X @ A - A.T @ X @ B @ \\            la.inv(R + B.T @ X @ B) @ B.T @ X @ A + Q        if (abs(Xn - X)).max() &amp;lt; eps:            break        X = Xn    return Xndef dlqr(A, B, Q, R):    &quot;&quot;&quot;Solve the discrete time lqr controller.    x[k+1] = A x[k] + B u[k]    cost = sum x[k].T*Q*x[k] + u[k].T*R*u[k]    # ref Bertsekas, p.151    &quot;&quot;&quot;    # first, try to solve the ricatti equation    X = solve_DARE(A, B, Q, R)    # compute the LQR gain    K = la.inv(B.T @ X @ B + R) @ (B.T @ X @ A)    eigVals, eigVecs = la.eig(A - B @ K)    return K, X, eigVals"
  },
  
  {
    "title": "自行车运动学模型",
    "url": "/posts/kinematics_module/",
    "categories": "模型, 运动学模型",
    "tags": "模型, 运动学",
    "date": "2021-12-20 00:00:00 +0800",
    





    "snippet": "运动学模型自行车模型  自行车模型 车辆运动学模型  自行车模型基于如下几个假设：  车辆在垂直方向的运动被忽略掉了，也就是说我们描述的车辆是一个二维平面上的运动物体（可以等价与我们是站在天空中的俯视视角）  假设车辆的结构就像自行车一样，也就是说车辆的前面两个轮胎拥有一直的角度和转速等，同样后面的两个轮胎也是如此，那么前后的轮胎就可以各用一个轮胎来描述  我们假设车辆运动也和自行车一样，这意味着是前面的轮胎控制这车辆的转角自行车运动学模型作为一种自行车模型，运动学自行车模型也假定车辆形如一辆自行车，整个的控制量可以简化为$\\alpha, \\delta_f, \\delta_r$.其中$\\alpha$是车辆的加速度，踩油门踏板意味着正的加速度，踩刹车踏板意味着负的加速度。$\\delta_f$是前轮转角，$\\delta_r$是后轮转角。这样我们使用三个量描述了车辆的控制输入(control input)，其中状态量我们用$\\psi, V, x, y$来表示。各变量说明如下：  $\\delta_f$ 前轮转角  $\\delta_r$ 后轮转角  $\\psi$ 航向角  $V$速度方向  $\\beta$ 速度方向与车辆方向夹角(滑移角)  $l_r, l_f$ 质点到前后轴的距离  $\\omega$ 角速度  $R$ 转弯半径  $x, y$模型的位置由三角函数可得：\\(\\begin{aligned}    \\dfrac{\\sin(\\delta_f - \\beta)}{l_f} &amp;amp;=  \\dfrac{\\sin( \\dfrac{\\pi}{2} - \\delta_f)}{R} \\\\    \\dfrac{\\sin(\\beta - \\delta_r)}{l_r} &amp;amp;= \\dfrac{\\sin(\\dfrac{\\pi}{2} + \\delta_r)}{R} \\\\\\end{aligned}\\)展开：\\(\\begin{aligned}    \\dfrac{\\sin\\delta_f\\cos\\beta - \\cos\\delta_f\\sin\\beta}{l_f} &amp;amp;=  \\dfrac{\\cos\\delta_f}{R} \\qquad(1)\\\\    \\dfrac{\\sin\\beta\\cos\\delta_r - \\cos\\beta\\sin\\delta_r}{l_r} &amp;amp;= \\dfrac{\\cos\\delta_r}{R} \\qquad(2)\\\\\\end{aligned}\\)可以求得$R, \\beta$：  $(1)$式同除$\\delta_f$同乘$l_f$加上$(2)$式同除$\\delta_r$同乘$l_r$得:\\(\\begin{aligned} \\dfrac{l_f + l_r}{R} &amp;amp;= \\cos\\beta(\\tan\\delta_f - \\tan\\delta_r) \\\\ R &amp;amp;= \\dfrac{l_f + l_r}{\\cos\\beta(\\tan\\delta_f - \\tan\\delta_r)} \\qquad(3) \\\\\\end{aligned}\\)  $(1)$式除以$(2)$式：\\(\\begin{aligned} \\dfrac{\\sin\\delta_f\\cos\\beta - \\cos\\delta_f\\sin\\beta}{\\sin\\beta\\cos\\delta_r - \\cos\\beta\\sin\\delta_r} &amp;amp;=  \\dfrac{\\cos\\delta_f * l_f}{\\cos\\delta_r * l_r} \\\\\\end{aligned}\\)  等式同时除以$\\cos\\delta_f$，乘以$\\cos\\delta_r$得:\\(\\begin{aligned} \\dfrac{\\tan\\delta_f\\cos\\beta - \\sin\\beta}{\\sin\\beta - \\cos\\beta\\tan\\delta_r} &amp;amp;=  \\dfrac{l_f}{l_r} \\\\\\end{aligned}\\)  等式左边同时除以$\\cos\\beta$得:\\(\\begin{aligned} \\dfrac{\\tan\\delta_f - \\tan\\beta}{\\tan\\beta - \\tan\\delta_r} &amp;amp;=  \\dfrac{l_f}{l_r} \\\\\\end{aligned}\\)  合并整理得:\\(\\begin{aligned} \\tan\\beta &amp;amp;=  \\dfrac{l_r * \\tan\\delta_f + l_f * \\tan\\delta_r}{l_f + l_r} \\\\ \\beta &amp;amp;= \\arctan(\\dfrac{l_r * \\tan\\delta_f + l_f * \\tan\\delta_r}{l_f + l_r}) \\qquad(4) \\\\\\end{aligned}\\)低速环境下，车辆行驶路径的转弯半径变化缓慢，此时我们可以假设车辆的方向变化率等于车辆的角速度。则车辆的角速度$\\omega$为\\(\\begin{aligned}    \\omega &amp;amp;= \\dfrac{V}{R} \\\\\\end{aligned}\\)代入$(3)$得:\\(\\begin{aligned}    \\omega &amp;amp;= \\dfrac{V * \\cos\\beta * (\\tan\\delta_f - \\tan\\delta_r)}{l_f + l_r} \\qquad(5)\\\\\\end{aligned}\\)所以模型的状态量$x, y, \\psi, V$的更新如下:\\(\\begin{aligned}    x_{t+1} &amp;amp;= x_t + V_t*\\cos(\\psi_t + \\beta) * \\Delta{t} \\\\    y_{t+1} &amp;amp;= y_t + V_t*\\sin(\\psi_t + \\beta) * \\Delta{t} \\\\    V_{t+1} &amp;amp;= V_t + \\alpha * \\Delta{t} \\\\    \\psi_{t+1} &amp;amp;= \\psi_t + \\omega * \\Delta{t} \\\\\\end{aligned}\\)当仅前轮驱动时，$\\delta_r$可认为是0则$\\psi, V, x, y$，更新公式如下：\\(\\begin{aligned}    x_{t+1} &amp;amp;= x_t + V*\\cos(\\psi_t + \\beta) * \\Delta{t} \\\\    y_{t+1} &amp;amp;= y_t + V*\\sin(\\psi_t + \\beta) * \\Delta{t} \\\\    V_{t+1} &amp;amp;= V_t + \\alpha * \\Delta{t} \\\\    \\psi_{t+1} &amp;amp;= \\psi_t + \\frac{V_t}{l_f + l_r} * \\cos(\\beta) * \\tan(\\delta_f) * \\Delta{t} \\\\    \\beta &amp;amp;= \\arctan(\\frac{l_r}{l_r+l_f} * \\tan(\\delta_f))\\end{aligned}\\)代码实现class KinematicModel(object):    def __init__(self, x, y, psi, v, f_len, r_len):        self.x = x        self.y = y        self.psi = psi        self.v = v`           self.f_len = f_len        self.r_len = r_len    def get_state(self):        return self.x, self.y, self.psi, self.v    def update_state(self, a, delta, dt):        beta = math.atan((self.r_len / (self.r_len + self.f_len)) * math.tan(delta))        self.x = self.x + self.v * math.cos(self.psi + beta) * dt        self.y = self.y + self.v * math.sin(self.psi + beta) * dt        self.psi = self.psi + (self.v / (self.f_len + self.r_len)) * math.cos(beta) * math.tan(delta) * dt        self.v = self.v + a * dt        return self.x, self.y, self.psi, self.v"
  },
  
  {
    "title": "纯预瞄跟踪算法",
    "url": "/posts/pure_pursuit/",
    "categories": "算法, 控制算法",
    "tags": "预瞄",
    "date": "2021-12-18 00:00:00 +0800",
    





    "snippet": "PurePursuit 纯预瞄算法阿克曼转向  阿克曼转向  阿克曼转向是一种现代汽车的转向方式，在汽车转弯的时候，内外轮转过的角度不一样，内侧轮胎转弯半径小于外侧轮胎。根据阿克曼转向几何设计的车辆，沿着弯道转弯时，利用四连杆的相等曲柄使内侧轮的转向角比外侧轮大大约2~4度，使四个轮子路径的圆心大致上交会于后轴的延长线上瞬时转向中心，让车辆可以顺畅的转弯.下图就是理想的阿克曼转向。$\\alpha$汽车内轮转角$\\beta$汽车外轮转角K两主销中心距离L轴距R转弯半径转动形式:  仅前轮转向，后轮角度不变。  前后轮均可转向。  (1) 前后轮角度相反，(2) 前后轮角度相同，这种模式可以实现全向运动。转向特性的特点：  汽车直线行驶时，4个车轮的轴线都互相平行，而且垂直于汽车纵向中心面。  汽车在转向行驶过程中，全部车轮都必须绕一个瞬时中心点做圆周滚动。核心公式      $\\cot\\beta - \\cot\\alpha = \\cfrac{K}{L}$        $\\tan\\beta = \\cfrac{L}{R}$  PurePursuit  纯预瞄算法  上图所⽰为简化的车辆运动学⾃⾏车模型，其后轮中心在蓝⾊虚线表⽰的⽬标轨迹上。本算法通过控制前轮转⻆来追踪下⼀个路点，使车辆可以沿着经过⽬标预瞄点的圆弧⾏驶。物理量描述如下:$R(m)$ 转弯半径$L(m)$ 轴距$\\delta$ 前轮转角$l_d$ 预瞄距离$x_r$预瞄点横坐标$y_r$预瞄点纵坐标$e$横向偏差$\\alpha$车身与预瞄点夹角本质就是已知轴距，预瞄距离，横向偏差求前轮转角:由正弦定理可以知道  $\\cfrac{l_d}{\\sin2\\alpha} = \\cfrac{R}{\\sin{\\cfrac{\\pi - 2\\alpha}{2}}}$  $\\cfrac{l_d}{2 * \\sin\\alpha * \\cos\\alpha} = \\cfrac{R}{\\cos\\alpha}$  $R = \\cfrac{l_d}{2 * \\sin\\alpha}$其中  $\\sin\\alpha = \\cfrac{e}{l_d}$那么就有  $R = \\cfrac{l_d^2}{2e}$所以  $\\delta = \\arctan\\cfrac{L}{R} = \\arctan\\cfrac{2Le}{l_d^2}$由上式可知控制器的本质就是对转角进行控制，以减少横向误差为目标的横向控制器。其中$\\cfrac{2L}{l_d^2}$可视为控制器的P参数.L为车辆轴距,$l_d$为设定的预瞄距离.本控制器的控制效果主要取决于预瞄距离的选取,⼀般来说预瞄距离越⻓,控制效果会越平滑,预瞄距离越短，控制效果会越精确（同时也会带来⼀定的震荡）.预瞄距离的选取也和当前车速有关,如以下两种:  $l_d = gv + l_f$其中v为当前车速，g为⼀可调节的参数,$l_f$为预设前视距离  $l_d = Av^2 + Bv + C$其中$A=1/(2a_{max})$, $a_{max}$为最⼤制动加速度.$Av^2$表⽰最短车辆制动距离.B表⽰车辆遇到异常时需要的反应时间, $Bv$则为对应的反应距离, $C$表⽰车辆的最⼩转弯半径.在实际使用的时候，通常不需要规划点切实等于预瞄点，而是在预瞄点附近找一个最接近的规划点，同时还可以用PID调整e值。代码实现预瞄输入自车经纬高以及目标点经纬高，计算车轮转角// 计算预瞄距离double PurePursuit::cal_ld(double vel){    return 1.0 / ( 2 * _max_braking_acc) * vel * vel + _reactime * vel + _min_turning_radius;}// http://www.movable-type.co.uk/scripts/latlong.html// 计算gps两点距离double PurePursuit::cal_gps_distance(double lng1, double lat1, double lng2, double lat2){    double radius_of_earth = 6378137.0;    lng1 = lng1 / 180 * M_PI;    lat1 = lat1 / 180 * M_PI;    lng2 = lng2 / 180 * M_PI;    lat2 = lat2 / 180 * M_PI;    double delt_lat = lat2 - lat1;    double delt_lng = lng2 - lng1;    double a = pow(sin(0.5 * delt_lat), 2) + pow(sin(0.5 * delt_lng), 2) * cos(lat1) * cos(lat2);    double c = 2.0 * atan2(sqrt(a), sqrt(1.0 - a));    return radius_of_earth * c;}// 计算gps两点方位角double PurePursuit::cal_gps_bearing(double lng1, double lat1, double lng2, double lat2){    lng1 = lng1 / 180 * M_PI;    lat1 = lat1 / 180 * M_PI;    lng2 = lng2 / 180 * M_PI;    lat2 = lat2 / 180 * M_PI;    double delt_lat = lat2 - lat1;    double delt_lng = lng2 - lng1;    double y = sin(delt_lng) * cos(lat2);    double x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(delt_lng);    return atan2(y, x); }// 计算横向偏差，yaw为车辆的航向角，正北方向的偏航double PurePursuit::cal_lateral(double lng1, double lat1, double lng2, double lat2, double yaw){    double distance = cal_gps_distance(lng1, lat1, lng2, lat2);    double heading = cal_gps_bearing(lng1, lat1, lng2, lat2);    if (heading &amp;lt; 0) heading += 2 * M_PI;    heading -= yaw;    double x = sin(heading) * distance;    double y = cos(heading) * distance;    return y; }// 计算车辆转角，vel自身车速double PurePursuit::cal_wheel_angle(double lng1, double lat1, double lng2, double lat2, double vel, double yaw){    double ld = cal_ld(vel);    double lateral = cal_lateral(lng1, lat1, lng2, lat2, 0);    return atan(2 * _wheel_base * lateral / ld / ld);}实现2：转换utm坐标系且使用目标点航向计算详细可操作代码见脚本pure_pursuit_lateral_controller.py    from pyproj import Proj    proj_text = &quot;+proj=utm +zone=50 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs&quot;    trsfm = Proj(proj_text)    path_point = read_global_path(log_path)    # 全局路径转utm    x, y = [], []    for point in path_point:        utm_x, utm_y = trsfm(point[0], point[1])        x.append(utm_x)        y.append(utm_y)    x = np.array(x)    y = np.array(y)    # 计算预瞄距离    ld = max(km.v * g_rate, 2)    dx = km.x - x[target_pts_idx]    dy = km.y - y[target_pts_idx]    euler_dist = math.sqrt(dx**2 + dy**2)    if euler_dist &amp;lt; ld:        target_pts_idx += 1        continue    print(target_pts_idx, ld, euler_dist, dx, dy, km.x, km.y)    cos_target_heading = cos(path_point[target_pts_idx][-1] * DEG_TO_RAD)    sin_target_heading = sin(path_point[target_pts_idx][-1] * DEG_TO_RAD)    # 计算横纵向偏差    # lateral_error = cos_target_heading * dy - sin_target_heading * dx    # print(&quot;lateral_error&quot;, lateral_error)    lateral_error = cos_target_heading * dx - sin_target_heading * dy     longtidual_error = sin_target_heading * dx + cos_target_heading * dy        print(&quot;lateral_error&quot;, lateral_error)    # print(&quot;longtidual_error&quot;, longtidual_error)    # print(&quot;euler_dist:&quot;, math.sqrt(dx**2 + dy**2))    # 计算前轮转角    alpha = atan(2 * 2.9 * lateral_error / euler_dist**2) + kp * lateral_error + ki * (lateral_error - last_error) + kd * (lateral_error - 2*(last_error) + last_last_error)    alpha = min(alpha, 30 * DEG_TO_RAD)    alpha = max(alpha, -30 * DEG_TO_RAD)"
  },
  
  {
    "title": "Can解析",
    "url": "/posts/can/",
    "categories": "CAN",
    "tags": "CAN",
    "date": "2021-12-18 00:00:00 +0800",
    





    "snippet": "can解析描述can解析流程数据我们一般拿到的can数据一般都是这种样子的            CAN ID      CAN DATA                  0x60b      0x11 0x22 0x33 0x44 0x55 0x66 0x77 0x88      这便是一条完整的can帧, 由id和data组成.其在linux中结构定义如下:#include &amp;lt;linux/can.h&amp;gt;/* CAN payload length and DLC definitions according to ISO 11898-1 */#define CAN_MAX_DLC 8#define CAN_MAX_DLEN 8/* special address description flags for the CAN_ID */#define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */#define CAN_RTR_FLAG 0x40000000U /* remote transmission request */#define CAN_ERR_FLAG 0x20000000U /* error message frame */struct can_frame {    canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */    __u8    can_dlc; /* frame payload length in byte (0 .. CAN_MAX_DLEN) */    __u8    __pad;   /* padding */    __u8    __res0;  /* reserved / padding */    __u8    __res1;  /* reserved / padding */    __u8    data[CAN_MAX_DLEN] __attribute__((aligned(8)));};can帧的主要几类:      数据帧-标准帧: 长度11位,最大值为0x7ff.        数据帧-扩展帧: 长度29位, 可通过canid &amp;amp; CAN_EFF_FLAG == 1 判断.    错误帧: 通过 CAN_ERR_FLAG 判断  远程帧: 通过 CAN_RTR_FLAG 判断其中我们看到最多的是数据帧, 其他帧基本没有看到过.dbc有了数据之后,如何解码出我们所需要的信息呢? 通常情况都是通过dbc来编码或者解码的.DBC是Database Can的缩写，其代表的是CAN的数据库文件，在这个文件中把CAN通讯的信息定义完整.BO_ 1547 Obj_1_General: 8 ARS_ISF SG_ Obj_DynProp : 50|3@0+ (1,0) [0|7] &quot;&quot;  ExternalUnit SG_ Obj_RCS : 63|8@0+ (0.5,-64) [-64|63.5] &quot;dBm²&quot;  ExternalUnit SG_ Obj_VrelLat : 45|9@0+ (0.25,-64) [-64|63.75] &quot;m/s&quot;  ExternalUnit SG_ Obj_ID : 7|8@0+ (1,0) [0|255] &quot;&quot;  ExternalUnit SG_ Obj_DistLong : 15|13@0+ (0.2,-500) [-500|1138.2] &quot;m&quot;  ExternalUnit SG_ Obj_VrelLong : 39|10@0+ (0.25,-128) [-128|127.75] &quot;m/s&quot;  ExternalUnit SG_ Obj_DistLat : 18|11@0+ (-0.2,204.6) [-204.8|204.6] &quot;m&quot;  ExternalUnit上面展示了一段ars的dbc中对canid为1547的can帧描述.其中主要有BO_ 报文, SG_ 信号.一个报文下会有多个信号. 一个报文就是一个can帧,其数据域长度为8字节64位(见前面定义).对于信号,每一行都相信的描述了该信号在数据域中的位置,解码方式等.BO_ (报文)基本格式如下:BO_ MessageId MessageName: MessageSize Transmitter  BO_为关键字，表示报文；  MessageId为定义的报文ID，是以10进制数表示；  MessageName表示该报文的名字  MessageSize表示该报文数据域字节数，为无符号整型数据；  Transmitter表示发送该报文的网络节点；如果该报文没有指定发送节点，则该值需设置为” Vector__XXX”或者不写以1547报文举例说明:BO_ 1547 Obj_1_General: 8 ARS_ISF            定义      描述                  BO_      报文关键字              1547      can id 16进制为0x60b              Obj_1_General      报文名字              8      报文数据域字节数              ARS_ISF      发送该报文的节点      SG_ (信号)基本格式如下:SG_ SignalName : StartBit|SignalSize@ByteOrder ValueType (Factor,Offset) [Min|Max] Unit Receiver  SG_为关键字，表示信号；  SignalName、 StartBit、 SignalSize分别表示该信号的名字、起始位、信号长度；  ByteOrder表示信号的字节顺序：0代表Motorola格式(大端序)，1代表Intel格式(小端序)；  ValueType 表示该信号的数值类型：+表示无符号数，-表示有符号数；  Factor表示因子，Offset表示偏移量；这两个值于该信号的原始值与物理值之间的转换。转换如下：物理值=原始值*因子+偏移量；                              Min          Max表示该信号的最小值和最大值，即指定了该信号值的范围；这两个值为double类型；                      Unit表示该信号的单位，为字符串类型；  Receiver表示该信号的接收节点；若该信号没有指定的接收节点，则必须设置为” Vector__XXX”举例如下:SG_ Obj_DistLat : 18|11@0+ (-0.2,204.6) [-204.8|204.6] “m”  ExternalUnit            定义      描述                  SG_      信号关键字              Obj_DistLat      信号名              18      起始位              11      长度              0      motorola格式(大端序)              +      无符号数              -0.2      缩放因子              204.6      偏移量              -204.8      最小值              204.6      最大值              m      单位              ExternalUnit      接收节点      解析通过dbc或者协议文档获取了报文和信号的编解码信息,然后就可以解析出明文.这里还是以conti的ars 408雷达举例.大端序列cve采集到的一条ars报文:0x60b 00 4e a4 01 80 20 01 7f      首先构建位图    将8字节64位数据转成二进制,依次展开  大端序列从左往右编号, 小端序从右往左编号, 从上到下依次增加                            位序编号          0          1          2          3          4          5          6          7                                      0x00          0          0          0          0          0          0          0          0                          0x4e          0          1          0          0          1          1          1          0                          0xa4          1          0          1          0          0          1          0          0                          0x01          0          0          0          0          0          0          0          1                          0x80          1          0          0          0          0          0          0          0                          0x20          0          0          1          0          0          0          0          0                          0x01          0          0          0          0          0          0          0          1                          0x7f          0          1          1          1          1          1          1          1                          根据信号描述获取对应字节这里以Obj_DistLat信号作为示例.如上所示,在dbc中定义的起始位start_bit = 18, 长度length = 11.大端序的实际起始位需要转换, 小端序无需转换,转换如下:    start_bit = 8 * (start_bit / 8) + (7 - (start_bit % 8));        转换之后为 stat_bit = 21, length = 11,          然后从位图中找到这11位是 0xa4的后3位 加上 0x01的8位即:100 00000001      然后按照大端序排列为 10000000001, 即10进制为val = 1025;      由于当前信号是无符号数据,所以补码等于源码,如果是有符号数且是负数的话需要取反加1计算(后面会介绍)      缩放 scale = -0.2, offset = 204.6, val = val * -0.2 + 204.6 = -0.4      即算得 Obj_DistLat在当前帧的值为-0.4, 其他信号按此步骤计算可得        {    &quot;Obj_DistLong&quot;: 3.2000000000000455,     &quot;Obj_VrelLong&quot;: 0.0,     &quot;Obj_DynProp&quot;: 1,     &quot;Obj_ID&quot;: 0,     &quot;Obj_RCS&quot;: -0.5,     &quot;Obj_VrelLat&quot;: 0.0,     &quot;Obj_DistLat&quot;: -0.4000000000000057}        至此当前帧解析完毕.  小端序列cve采集到的一条x1j报文:0x76d 00 00 00 00 ae 1f 00 00其0x76d报文定义如下:BO_ 1901 KeyCarFrameA1: 8 MINIEYE_TRANSMITTER SG_ on_route : 1|1@1+ (1,0) [0|1] &quot;&quot; Vector__XXX SG_ TargetVehicle_Status : 20|4@1+ (1,0) [0|15] &quot;&quot; Vector__XXX SG_ TargetVehicle_Width : 24|8@1+ (0.05,0) [0|12.5] &quot;M&quot; Vector__XXX SG_ FCW : 0|1@1+ (1,0) [0|1] &quot;&quot;  ADAS SG_ Vehicle_ID : 2|6@1+ (1,0) [0|63] &quot;&quot;  ADAS SG_ TargetVehicle_PosX : 8|12@1+ (0.0625,0) [0|250] &quot;m&quot;  ADAS SG_ TargetVehicle_PosY : 32|10@1- (0.0625,0) [-31.9375|31.9375] &quot;m&quot;  ADAS SG_ TargetVehicle_Type : 48|3@1+ (1,0) [0|7] &quot;&quot;  ADAS这里考虑TargetVehicle_PosY, 由上面分析可得 start_bit = 32, length = 10, scale = 0.0625, offset = 0,小端序, 有符号.      构建位图  此时位序与大端序号刚刚相反                            位序编号          7          6          5          4          3          2          1          0                                      0x00          0          0          0          0          0          0          0          0                          0x00          0          0          0          0          0          0          0          0                          0x00          0          0          0          0          0          0          0          0                          0x00          0          0          0          0          0          0          0          0                          0xae          1          0          1          0          1          1          1          0                          0x1f          0          0          0          1          1          1          1          1                          0x00          0          0          0          0          0          0          0          0                          0x00          0          0          0          0          0          0          0          0                      然后从位图中找到这10位是 0xae 加上 0xff的后两位 即:10101110 11  然后按照小端序排列为 1110101110, 即10进制为val = 942;  由于当前信号是有符号数据,且最高位为1,则说明该值为负数,需要取补码,补码为原码取反加1,则:val = ((~val) + 1) *-1 = -82  缩放加偏差为val = val * 0.0625 + 0 = -5.125      即算得 TargetVehicle_PosY在当前帧的值为-5.125, 其他信号按此步骤计算可得      {      &quot;TargetVehicle_PosX&quot;: 0.0,       &quot;TargetVehicle_Status&quot;: 0,       &quot;TargetVehicle_Type&quot;: 0,       &quot;FCW&quot;: 0,       &quot;on_route&quot;: 0,       &quot;TargetVehicle_PosY&quot;: -5.125,       &quot;Vehicle_ID&quot;: 0,       &quot;TargetVehicle_Width&quot;: 0.0  }      实现// 定义数据结构typedef struct can_frame{    int can_id;    uint8_t can_data[8];}can_frame;typedef struct singal{    int start;    int length;    float scale;    float offest;    float min_val;    float max_val;    bool little_order;    bool is_unsigned;    char* name;}singal;typedef struct dbc_message{    string name;    int can_id;    vector&amp;lt;singal&amp;gt; singals;}dbc_message;map&amp;lt;int, dbc_message&amp;gt; dbc; map&amp;lt;string, map&amp;lt;int, string&amp;gt; &amp;gt; val_table;// 加载dbcvoid add_dbc(char* dbc_path){        FILE* fp = fopen(dbc_path, &quot;r&quot;);        char buf[10086];        int last_bo_id = -1;        while (fgets(buf, 10085, fp) != NULL){            string target(buf);            target.erase(0, target.find_first_not_of(&quot; &quot;));            target.erase(target.find_last_not_of(&quot; &quot;) + 1);            if( target.substr(0, 3) == &quot;BO_&quot;){                regex reg(&quot;BO_\\\\s+(\\\\d+)\\\\s+(\\\\w+):&quot;);                smatch sm;                regex_search(target, sm, reg);                if(sm.empty()) continue;                               string desc = sm[2];                long long can_id = atoll(sm[1].str().c_str());                if(can_id &amp;gt; 0x7ff) can_id -= 0x80000000;                    if (dbc.find(can_id) != dbc.end())                {                    cout &amp;lt;&amp;lt; &quot;can_id conflict &quot; &amp;lt;&amp;lt; endl;                }                dbc_message dm;                dm.can_id = can_id;                dm.name = desc;                dbc[can_id] = dm;                last_bo_id = can_id;            }else if (target.substr(0, 3) == &quot;SG_&quot;){                regex reg(&quot;SG_\\\\s+(\\\\w+)\\\\s+:\\\\s+(\\\\d+)\\\\|(\\\\d+)@(\\\\d+)(.)\\\\s+\\\\((.+?),(.+?)\\\\)\\\\s+\\\\[(.*?)\\\\|(.*?)\\\\]\\\\s+\\&quot;(.*?)\\&quot;&quot;);                smatch sm;                regex_search(target, sm, reg);                if(sm.empty()) continue;                if( last_bo_id == -1) continue;                singal s;                s.name = (char*)malloc(strlen(sm[1].str().c_str()) + 1);                strcpy(s.name, sm[1].str().c_str());                s.start = atoi(sm[2].str().c_str());                s.length = atoi(sm[3].str().c_str());                s.little_order = atoi(sm[4].str().c_str());                s.is_unsigned = sm[5].str() == &quot;+&quot; ? true : false;                s.scale = atof(sm[6].str().c_str());                s.offest = atof(sm[7].str().c_str());                s.min_val = atof(sm[8].str().c_str());                s.max_val = atof(sm[9].str().c_str());                // sm[9] type                dbc[last_bo_id].singals.push_back(s);            }else if( target.substr(0, 4) == &quot;VAL_&quot;){                regex reg(&quot;VAL_\\\\s+(\\\\d+)\\\\s+(\\\\w+)\\\\s+(\\\\d+\\\\s+\\&quot;.+\\&quot;\\\\s*)+&quot;);                smatch sm;                regex_search(target, sm, reg);                if(sm.empty()) continue;                int can_id = atoi(sm[1].str().c_str());                string signal_name = sm[2].str();                string desc = sm[3].str();                string buf;                int desc_sz = desc.size();                int cnt = 0, val = 0;                string real_val = &quot;&quot;;                map&amp;lt;int, string&amp;gt; v = val_table[to_string(can_id) + &quot;_&quot; + signal_name];                for( int i = 0; i &amp;lt; desc_sz; i++) {                    if( desc[i] == &#39;&quot;&#39;) continue;                    if( desc[i] == &#39; &#39;) {                        if(!buf.empty()) {                            if(cnt &amp;amp; 1) {                                // cout &amp;lt;&amp;lt; val &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; buf &amp;lt;&amp;lt; endl;                                v[val] = buf;                            }else{                                val = atoi(buf.c_str());                            }                            buf.clear();                        }                        cnt += 1;                        continue;                    }                    buf += desc[i];                }                val_table[to_string(can_id) + &quot;_&quot; + signal_name] = v;                // for( int i = 0; i &amp;lt; sm.size(); i++ ) cout &amp;lt;&amp;lt; sm[i] &amp;lt;&amp;lt; endl;;            }        }        fclose(fp);        cout &amp;lt;&amp;lt; &quot;add dbc file finish...&quot; &amp;lt;&amp;lt; endl;    }// 解码信号double decode(singal s, can_frame t) {        assert(s.length &amp;gt; 0);                // for motorola deal start_bit        if(!s.little_order) s.start = 8 * (s.start / 8) + (7 - (s.start % 8));        uint64_t res = 0;        int now_len = s.length, len = s.length;        int now_start = s.start, start = s.start;        uint8_t buf[8], bit_lengths[8];        int start_bits = start / 8;        int end_bits = ( start + len - 1 ) / 8;        // printf(&quot;%d %d %d\\n&quot;, s.start, s.length, s.little_order);        // printf(&quot;%d %d\\n&quot;, start_bits, end_bits);        for (size_t i = start_bits ; i &amp;lt;= end_bits; i++){             // printf(&quot;%d *\\n&quot;, t.can_data[i]);              int dt = (i+1)*8-now_start;            if( dt &amp;lt;= now_len){                if(! s.little_order) {                    buf[i] = t.can_data[i] &amp;lt;&amp;lt; (8 - dt);                    buf[i] = buf[i] &amp;gt;&amp;gt; (8 - dt);                } else{                    buf[i] = t.can_data[i] &amp;gt;&amp;gt; (8 - dt);                }                now_len -= dt;                now_start += dt;                bit_lengths[i] = dt;            }else{                int now_dt = now_len;                // printf(&quot;\\n%d %d &quot;, dt, now_dt);                if ( ! s.little_order) {                    buf[i] = (t.can_data[i] &amp;lt;&amp;lt; (8 - dt));                    buf[i] = buf[i] &amp;gt;&amp;gt; (8 - now_dt);                }else {                    buf[i] = t.can_data[i] &amp;gt;&amp;gt; ( 8 - dt);                    buf[i] = buf[i] &amp;lt;&amp;lt; (8 - now_dt);                    buf[i] = buf[i] &amp;gt;&amp;gt; (8 - now_dt);                }                               now_len = 0;                now_start += now_dt;                bit_lengths[i] = now_dt;            }            // printf(&quot;%d &amp;amp;\\n&quot;, buf[i]);        }        // printf(&quot;\\n&quot;);        for (size_t i = 0 ; i &amp;lt;= end_bits-start_bits; i++){               uint8_t b = 0;            if( !s.little_order){                // if(i + start_bits + 1 &amp;lt;= end_bits) b = bit_lengths[i + start_bits + 1];                res = res &amp;lt;&amp;lt; bit_lengths[i+start_bits] | buf[i+start_bits];            }else{                // if(end_bits-i-1 &amp;gt;= 0) b = bit_lengths[end_bits-i-1];                res = res &amp;lt;&amp;lt; bit_lengths[end_bits-i] | buf[end_bits-i];            }            // printf(&quot;%d * &quot;, res);        }        // printf(&quot;res :%d\\n&quot;, res);        double real_res = res*1.0;        if (!s.is_unsigned &amp;amp;&amp;amp; (res &amp;gt;&amp;gt; (s.length-1) &amp;amp; 0x1))        {            res = ~res;            res = res &amp;lt;&amp;lt; 64 - s.length &amp;gt;&amp;gt; 64-s.length;            debug(res);            real_res = res*1.0;            debug(real_res);            real_res = (real_res + 1) * -1;            debug(real_res);        }        debug(s.scale);        debug(s.offest);        debug(s.max_val);        debug(s.min_val);        real_res = real_res * s.scale + s.offest;        real_res = real_res &amp;gt; s.max_val ? s.max_val : real_res;        real_res = real_res &amp;lt; s.min_val ? s.min_val : real_res;        // printf(&quot;\\n%f\\n&quot;, real_res);        return real_res;}完整代码见can_parser.cpp, 验证脚本见test_can.py.本人测试cve采集的一组x1j和ars数据时在1e-5的精度下能保证100%准确率. 由于未做大量验证,无法保证完全没有问题.使用第三方库python - cantoolsimport cantoolsdbc = cantools.database.load_file(&quot;/home/cao/work-git/cve/cve/dbc/ARS408.dbc&quot;, strict=False)rf = open(&quot;./test_can_parser_data/ars.txt&quot;, &quot;r&quot;)ids = [m.frame_id for m in dbc.messages]for line in rf:    cols = line.split()    can_id = int(cols[3], 16)    data = b&#39;&#39;.join([int(x, 16).to_bytes(1, &#39;little&#39;) for x in cols[4:]])    if can_id in ids:        j = dbc.decode_message(can_id, data, decode_choices=False)        print(json.dumps(j))        breakcpp - dbcc  github链接 : https://github.com/howerj/dbcc  安装完之后 dbcc ARS408.dbc 便会生成dbc对应的.h 和.c.      使用      #include &quot;ARS408.h&quot;  #include &amp;lt;linux/can.h&amp;gt;  int main(int argc, char const *argv[])  {      can_obj_ars408_h_t t;      double l = -1, lat = -1;      // 1611196534 520939 CAN6 0x60b 00 4e a4 01 80 20 01 7f      uint8_t data[8] = { 0x00, 0x4e, 0xa4, 0x01, 0x80, 0x20, 0x01, 0x7f};      printf(&quot;%lld\\n&quot;, *(uint64_t*)data);      int ret = unpack_message(&amp;amp;t, 0x60b, *(uint64_t*)data, 8, 0);      ret = decode_can_0x60b_Obj_DistLong(&amp;amp;t, &amp;amp;l);      ret = decode_can_0x60b_Obj_DistLat(&amp;amp;t, &amp;amp;lat);      printf(&quot;ret: %d\\n&quot;, ret);      // printf(&quot;dist_long: %lf, dis_lat: %lf, tmp: %lf\\n&quot;, t.can_0x60b_Obj_1_General.Obj_DistLong, t.can_0x60b_Obj_1_General.Obj_DistLat, val);      printf(&quot;dist_long: %lf, dis_lat: %lf\\n&quot;, l, lat);      return 0;  }      "
  },
  
  {
    "title": "PID控制器",
    "url": "/posts/pure_pid/",
    "categories": "算法, 控制算法",
    "tags": "PID, 反馈控制",
    "date": "2021-12-17 00:00:00 +0800",
    





    "snippet": "PID控制器  PID控制参数详解 PID  PID控制，即 比例（proportion） - 积分（integration） - 微分(differentiation) 控制是自动控制原理中定义的一种控制方法也可以称为是校正方法.积分形式:$U(t) = K_pe(t) + K_i\\int_0^te(t)dt + K_d\\cfrac{de(t)}{dt}$离散化:$U(t) = K_pe(t) + K_i\\sum{e(t)} + K_d(e(t) - e(t-1))$增量式:$U(t-1) = K_pe(t-1) + K_i\\sum{e(t-1)} + K_d(e(t-1) - e(t-2))$\\[\\begin{aligned}    \\Delta{U(t)} &amp;amp;= U(t) - U(t-1) \\\\ &amp;amp;=K_p(e(t)-e(t-1)) + K_ie(t) + K_d(e(t)-2e(t-1)+e(t-2))\\end{aligned}\\]如上图所示：Kp Ki Kd为pid三个参数.      比例环节成比例地反映控制系统的偏差信号e(t)，偏差一旦产生，控制器立即产生控制作用，以减小偏差。当仅有比例控制时系统输出存在稳态误差（Steady-state error）优点: 调整系统的开环比例系数，提高系统的稳态精度，减低系统的惰性，加快响应速度。缺点: 仅用P控制器,过大的开环比例系数不仅会使系统的超调量增大，而且会使系统稳定裕度变小，甚至不稳定。        积分环节控制器的输出与输入误差信号的积分成正比关系。主要用于消除静差，提高系统的无差度。积分作用的强弱取决于积分时间常数T,T越大，积分作用越弱，反之则越强。优点： 消除稳态误差。缺点： 积分控制器的加入会影响系统的稳定性，使系统的稳定裕度减小。        微分环节反映偏差信号的变化趋势，并能在偏差信号变得太大之前，在系统中引入一个有效的早期修正信号，从而加快系统的动作速度，减少调节时间。在微分控制中，控制器的输出与输入误差信号的微分（即误差的变化率）成正比关系.  无法单独起作用。优点：使系统的响应速度变快，超调减小，振荡减轻，对动态过程有“预测”作用。  代码实现输入误差与输入值，通过增量式pid调整double PurePid::step_control(double val, double err) {    double res = val;    errs[err_cnt%3] = err;        if(err_cnt &amp;gt;= 3)     {        res += _kp * (errs[err_cnt % 3] - errs[(err_cnt-1) % 3]) + _ki * errs[err_cnt % 3] + _kd * (errs[err_cnt % 3] - 2 * errs[(err_cnt - 1) % 3] + errs[(err_cnt - 2) % 3]);    }    err_cnt++;    return res;}"
  },
  
  {
    "title": "Ndk Chain",
    "url": "/posts/ndk-chain/",
    "categories": "",
    "tags": "",
    "date": "2021-11-15 00:00:00 +0800",
    





    "snippet": "cmake ndk 交叉编译      从官网下载ndk        生成独立的ndk工具链     ## 生成arm64版本的 ./build/tools/make_standalone_toolchain.sh \\ --arch arm64 \\ --install-dir=alone-sdk            cmake 配置     set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -fPIE&quot;) set(CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} -fPIE -pie&quot;) # 配置使用 NDK Standalone Toolchain 编译 set(NDK_STANDALONE_TOOLCHAIN /home/cao/Android/Sdk/ndk/21.3.6528147/alone-sdk) # set(CMAKE_SYSTEM_NAME AndroidARM) # set(CMAKE_SYSTEM_VERSION 3) set(CMAKE_C_COMPILER ${NDK_STANDALONE_TOOLCHAIN}/bin/aarch64-linux-android-gcc) set(CMAKE_CXX_COMPILER ${NDK_STANDALONE_TOOLCHAIN}/bin/aarch64-linux-android-g++) # set(CMAKE_FIND_ROOT_PATH ${NDK_STANDALONE_TOOLCHAIN}) set (CMAKE_ANDROID_ARCH_ABI arm64-v8a) # set (CMAKE_ANDROID_STANDALONE_TOOLCHAIN ~/ndk_toolchain) # 使用 NDK 提供的头文件 add_definitions(&quot;--sysroot=${NDK_STANDALONE_TOOLCHAIN}/sysroot&quot;)        android引入so                  将生成的.so放到src/main/jniLibs/arm64-v8a/,并将.h复制到默认的src/main/cpp                    配置CMakeLists               add_library(dds SHARED IMPORTED) #设置so路劲  ${CMAKE_SOURCE_DIR}是CMakeLists.txt的路径   ${ANDROID_ABI} 标识cpu类型 set_target_properties(dds PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/libdds.so) set_property(TARGET dds PROPERTY IMPORTED_NO_SONAME 1) # 链接dds库 target_link_libraries( # Specifies the target library.     native-lib     dds     flow_stream     # Links the target library to the log library     # included in the NDK.     ${log-lib})              配置app/build.gradle         ## defaultConfig下配置 externalNativeBuild {     cmake {         cppFlags &quot;&quot;         arguments &quot;-DANDROID_STL=c++_shared&quot;     } } ndk {     # 这里只配置 arm64-v8a,因为只生成了这个版本的库     abiFilters &#39;arm64-v8a&#39; } ## android 标签下配置 splits {     abi {         enable true         reset()         include &#39;x86&#39;, &#39;x86_64&#39;, &#39;armeabi-v7a&#39;, &#39;arm64-v8a&#39; //select ABIs to build APKs for         universalApk true //generate an additional APK that contains all the ABIs     } } # map for the version code project.ext.versionCodes = [&#39;armeabi&#39;: 1, &#39;armeabi-v7a&#39;: 2, &#39;arm64-v8a&#39;: 3, &#39;mips&#39;: 5, &#39;mips64&#39;: 6, &#39;x86&#39;: 8, &#39;x86_64&#39;: 9] android.applicationVariants.all { variant -&amp;gt;     // assign different version code for each output     variant.outputs.each { output -&amp;gt;         output.versionCodeOverride =                 project.ext.versionCodes.get(output.getFilter(com.android.build.OutputFile.ABI), 0) * 1000000 + android.defaultConfig.versionCode     } }        android使用          使用默认生成native-lib.cpp include头文件,创建好暴露接口即可      附数据对应 https://blog.csdn.net/smilestone322/article/details/88607717      "
  },
  
  {
    "title": "Ctypes Cpp Demo",
    "url": "/posts/ctypes-cpp-demo/",
    "categories": "",
    "tags": "",
    "date": "2021-11-10 00:00:00 +0800",
    





    "snippet": "cython调用c++动态库示例  cpp代码暴露的函数如下typedef struct can_frame{    int can_id;    uint8_t can_data[8];}can_frame;typedef struct singal{    int start;    int length;    float scale;    float offest;    float min_val;    float max_val;    bool little_order;    bool is_unsigned;    char* name;}singal;extern &quot;C&quot; {    float decode(singal s, can_frame t);    void add_dbc(char* dbc_path);    char* decode_message(can_frame t, bool use_val_table=true);}  在cmake中通过 add_library(test_can SHARED can_parser.cpp) 导出libtest_can.so,至此动态库导出完成。接下来python调用## 导入ctypesfrom ctypes import *## 加载动态库decode_dll = cdll.LoadLibrary(&quot;/home/cao/CLionProjects/pcv/build/lib/libtest_can.so&quot;)## 定义结构体，同cpp定义一致,左侧为变量名，右侧为类型。其中c语言与ctypes的类型转换见末尾class singal(Structure):    _fields_ = [        (&quot;start&quot;, c_int),        (&quot;length&quot;, c_int),        (&quot;scale&quot;, c_float),        (&quot;offest&quot;, c_float),        (&quot;min_val&quot;, c_float),        (&quot;max_val&quot;, c_float),        (&quot;little_order&quot;, c_bool),        (&quot;is_unsigned&quot;, c_bool),        (&quot;name&quot;, c_char_p)    ]class can_frame(Structure):    _fields_ = [        (&quot;can_id&quot;, c_int),        (&quot;can_data&quot;, c_ubyte*8)    ]## 调用add_dbc函数name = c_char_p(bytes(&quot;./dbc/QZ_x1q_20200224.dbc&quot;, &quot;utf-8&quot;)) # str -&amp;gt; bytes -&amp;gt; c_char_pdecode_dll.add_dbc(name)## 调用decodecan_id = 10086can_data = [0, 1, 2, 3, 4, 5, 6, 7]data = (c_ubyte*8)(*can_data)c = can_frame(can_id, data)s = singal(8, 12, 0.0625, 0, 0, 250, True, True, c_char_p(bytes(&quot;test&quot;, &quot;utf-8&quot;)))decode_dll.decode.restype = c_floatpx = decode_dll.decode(s, c)## 调用decode_messagedecode_dll.decode_message.restype = c_char_p  # 设置返回类型res = decode_dll.decode_message(c)res = res.decode()  # bytes -&amp;gt; str  附图官方链接基础数据类型¶ctypes 定义了一些和C兼容的基本数据类型：ctypes 类型C 类型Python 类型c_bool_Boolbool (1)c_charchar单字符字节对象c_wcharwchar_t单字符字符串c_bytechar整型c_ubyteunsigned char整型c_shortshort整型c_ushortunsigned short整型c_intint整型c_uintunsigned int整型c_longlong整型c_ulongunsigned long整型c_longlong__int64 或 long long整型c_ulonglongunsigned __int64 或 unsigned long long整型c_size_tsize_t整型c_ssize_tssize_t 或 Py_ssize_t整型c_floatfloat浮点数c_doubledouble浮点数c_longdoublelong double浮点数c_char_pchar * (以 NUL 结尾)字节串对象或 Nonec_wchar_pwchar_t * (以 NUL 结尾)字符串或 Nonec_void_pvoid *int 或 None"
  },
  
  {
    "title": "Shm",
    "url": "/posts/shm/",
    "categories": "",
    "tags": "",
    "date": "2021-10-18 00:00:00 +0800",
    





    "snippet": "采用share memory 做ipc通信介绍      共享内存就是允许两个不相关的进程访问同一个逻辑内存；共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式；不同进程之间共享的内存通常安排为同一段物理内存，进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址；而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。        共享内存是最快的可用IPC形式。        共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取；通常需要用其他的机制来同步对共享内存的访问，例如信号量、互斥锁。        主要有两类实现 System V， Posix两种实现， 两者间的区别及简单实现。  本文通过Posix和信号量实现ipc通信队列并支持多生产者和多消费者。实现过程原理      解释l为第一个数据的起始位置， r为最后一个数据的起始位置，id为当前写入的数据id（默认从0递增），data为原始数据，d_id为当前写入数据的id值，size为当前data+d_id+size之后的大小。buf为整个共享内存，l，r,id为header; size,d_id为数据的header。除了buf header剩余的空间为数据区，本质是个循环队列，这里大小为queue_size = buf_size - 12。        过程        写操作，读取l,r,id,封装当前数据（增加d_id=id+1和size）,判断(r-l+queue_size)%queue_size计算当前剩余空间是否能够放下当前数据，如果不够，(l + l_size)%queue_size,剩余空间增加l_size。循环之，直到剩余空间能够放下当先数据，然后复制到buf，得到新的r。更新l，r，id=id+1到buf header。写操作完成。        读操作, 读取l，r，id。read_index,read_fid（为已经读取的数据位置，数据的id，由read方维护），计算r处的r_id,l处的l_id.如果r_id&amp;lt;=read_fid,则当前无新数据可读;如果l_id&amp;lt;=read_id，则read_index移动read_size到下一个数据的起点，读取数据即可read_index=(read_size + read_index)%queue_size,read_id = read_index_id;如果l_id&amp;gt;read_id则数据已经被覆盖，read_index=l_index，read_id=l_id。至次读取数据完毕。        由于共享内存没有同步操作，所以每次读写操作之前都需要通过信号量来同步，确保每次读写分离。  主要函数解释  prepare()创建或挂载共享内存，创建或绑定信号量void parare(){    int fd = shm_open(topic, O_CREAT | O_EXCL | O_RDWR, 0644);    if (fd == -1){        fd = shm_open(topic, O_EXCL | O_RDWR, 0644);        if( fd == -1) {            perror(&quot;shm_open&quot;);            exit(EXIT_FAILURE);        }      }    if( ftruncate(fd, shm_size) == -1){        perror(&quot;ftruncate&quot;);        exit(EXIT_FAILURE);    }    buf = (uint8_t*)mmap(NULL, shm_size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED, fd, 0);    if (buf == MAP_FAILED){        perror(&quot;mmap&quot;);        exit(EXIT_FAILURE);    }    close(fd);    sem = sem_open(topic, O_CREAT | O_RDWR  | O_EXCL, 0644, 1);    if( sem == SEM_FAILED){        sem = sem_open(topic, O_RDWR  | O_EXCL, 0644, 1);        if(sem == SEM_FAILED) {            perror(&quot;sem_open&quot;);            exit(EXIT_FAILURE);        }    }}  write(uint8_t* data, uint32_t size)读取数据void write(uint8_t* data, uint32_t size){      if( sem_wait(sem) == -1) {        perror(&quot;sem_wait&quot;);        exit(EXIT_FAILURE);    }    uint32_t l = _uint8_2_uint32(0); //    uint32_t r = _uint8_2_uint32(4); //     uint32_t fid = _uint8_2_uint32(8);    // 构造数据    uint8_t* tmp = (uint8_t*)malloc(size + 8);    memcpy(tmp+8, data, size);    size += 8;    fid += 1;    for( int i = 0; i &amp;lt; 4; i++ ) tmp[3-i] = size &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    for( int i = 0; i &amp;lt; 4; i++ ) tmp[7-i] = fid &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    int real_size = (( r - l ) + queue_size) % queue_size;    int remain = queue_size - real_size - 1;    while( remain &amp;lt; size) {        uint32_t s = _uint8_2_uint32(l + 1 + head_size);        l = (l + s)%queue_size;        remain += s;    }    if( queue_size - r - 1 &amp;lt; size) {        int dt = size - queue_size + r + 1;        memcpy(buf + r + head_size + 1, tmp, queue_size - r - 1);        memcpy(buf + head_size, tmp + queue_size - r -1, dt);        r = dt - 1;    }else{        memcpy(buf + r + head_size + 1, tmp, size);        r = r + size;    }    for( int i = 0; i &amp;lt; 4; i++ ) buf[3-i] = l &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    for( int i = 0; i &amp;lt; 4; i++ ) buf[7-i] = r &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;        for( int i = 0; i &amp;lt; 4; i++ ) buf[11-i] = fid &amp;gt;&amp;gt; (i * 8) &amp;amp; 0xFF;    printf(&quot;write fid is %d\\n&quot;, fid);    if( sem_post(sem) == -1) {        perror(&quot;sem_post&quot;);        exit(EXIT_FAILURE);    }}  uint_8* read()读取数据uint8_t* read(){    if( sem_wait(sem) == -1) {        perror(&quot;sem_wait&quot;);        exit(EXIT_FAILURE);    }    uint32_t l = _uint8_2_uint32(0); //    uint32_t r = _uint8_2_uint32(4); //    uint32_t last_fid = _uint8_2_uint32(8);    if( read_index == -1) {        read_index = (l + 1)%queue_size;    }else{        if(last_fid &amp;lt;= read_fid) {            if( sem_post(sem) == -1) {                perror(&quot;sem_wait&quot;);                exit(EXIT_FAILURE);            }            return NULL;        }        uint32_t mi_fid = _uint8_2_uint32(l + 1 + head_size + 4);          if( mi_fid &amp;lt;= read_fid) {            uint32_t s = _uint8_2_uint32(read_index + head_size);            read_index = (s + read_index) % queue_size;        }else read_index = (l + 1)%queue_size;    }    uint32_t s = _uint8_2_uint32(read_index + head_size);    uint8_t* data = (uint8_t*)malloc(s);    if( s + read_index &amp;gt; queue_size){        uint32_t dt = s + read_index - queue_size;        memcpy(data, buf + head_size + read_index, s - dt);        memcpy(data + s - dt, buf + head_size, dt);    }else{        memcpy(data, buf + head_size + read_index, s);    }    read_fid = _uint8_2_uint32(read_index + head_size + 4);    printf(&quot;read fid os %d\\n&quot;, read_fid);    if( sem_post(sem) == -1) {        perror(&quot;sem_post&quot;);        exit(EXIT_FAILURE);    }    return data;    }  python接口extern &quot;C&quot;{    ShmFlow* shmflow = NULL;    void init_flow(char* topic, int size){        if(shmflow == NULL)  shmflow = new ShmFlow(topic, size);        printf(&quot;shmflow init ok\\n&quot;);    }    void write_data(char* data, int size) {        uint8_t* t = (uint8_t*)data;        shmflow-&amp;gt;write(t, size);    }    int read_data(char* data){        uint8_t* res = shmflow-&amp;gt;read();        if( res == NULL) return 0;        uint32_t tmp = 0;        for( uint32_t i = 0; i &amp;lt; 4; i++) tmp = (tmp &amp;lt;&amp;lt; 8) + res[i];        memcpy(data, res, tmp);        return 1;    }}  python调用示例读取数据def test_shmflow_read():    import cv2    import numpy as np    shmflow_dll = cdll.LoadLibrary(&quot;/home/cao/CLionProjects/pcv/build/lib/libshmflow.so&quot;)    topic = c_char_p(bytes(&quot;video&quot;, &#39;utf-8&#39;))    shmflow_dll.init_flow(topic, 1280*3*720*10)    while True:        d = create_string_buffer(1280 * 3 * 720 * 10)        res = shmflow_dll.read_data(d)        if res == 0:            continue        size = int.from_bytes(d.raw[:4], byteorder=&quot;big&quot;, signed=False)        fid = int.from_bytes(d.raw[4:8], byteorder=&quot;big&quot;, signed=False)        print(fid, size)        d = d.raw[8:size]        png = np.fromstring(d, dtype=np.uint8).reshape((720, 1280, 3))        cv2.imshow(&quot;----&quot;, png)        cv2.waitKey(110)写数据def test_shmflow_write():    import cv2    img = cv2.imread(&quot;/home/cao/pcview-v2/x1d3_view/pcview_data/20200527112701/cap-fig/20200527-113043-314863-cap.png&quot;)    shmflow_dll = cdll.LoadLibrary(&quot;/home/cao/CLionProjects/pcv/build/lib/libshmflow.so&quot;)    topic = c_char_p(bytes(&quot;video&quot;, &#39;utf-8&#39;))    shmflow_dll.init_flow(topic, 1280 * 3 * 720 * 10)    img = cv2.resize(img, (1280, 720))    img = img.tostring()    # t = np.fromstring(img, dtype=np.uint8).reshape((720, 1280, 3))    # cv2.imshow(&quot;---&quot;, t)    # cv2.waitKey(1000)    cp = c_char_p(img)    shmflow_dll.write_data(cp, 1280*720*3)亟待完善写和写互斥，写和读互斥，读和读不互斥感谢您阅读此文档"
  }
  
]

