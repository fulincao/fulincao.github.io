

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://fulincao.github.io/</id>
  <title>fulincao</title>
  <subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle>
  <updated>2022-01-06T20:43:40+08:00</updated>
  <author>
    <name>fulincao</name>
    <uri>https://fulincao.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://fulincao.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://fulincao.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator>
  <rights> © 2022 fulincao </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Cubic_spline</title>
    <link href="https://fulincao.github.io/posts/cubic_spline/" rel="alternate" type="text/html" title="Cubic_spline" />
    <published>2022-01-04T00:00:00+08:00</published>
  
    <updated>2022-01-04T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/cubic_spline/</id>
    <content src="https://fulincao.github.io/posts/cubic_spline/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
  

  
    <summary>
      





      三次样条(cubic spline)插值


  样条插值
 PythonRobotics


已知某些点而不知道具体方程时候，通常有拟合和插值两种做法。拟合不要求方程通过所有的已知点，整体趋势一致。插值则是每个已知点都必会穿过，但是高阶会出现龙格现象，所以一般采用分段插值。而三次样条插值则是分段采用一元三次方程进行插值

问题定义

已知n+1个点$[(x_0, y_0), (x_1, y_1),…,(x_{n-1}, y_{n-1}), (x_n, y_n)]$，n个区间段为$[(x0, x1), (x1, x2),…,(x_{n-1}, x_n)]$三次样条就是说每个小区间的曲线是一个三次方程，三次样条方程满足以下条件:

  在每个分段小区间$[x_i, x_{i+1}], S(x)=S_i(x) = a_i + b_ix + c_ix^2 + d_ix^3$
  满足插值条...
    </summary>
  

  </entry>

  
  <entry>
    <title>Lqr</title>
    <link href="https://fulincao.github.io/posts/LQR/" rel="alternate" type="text/html" title="Lqr" />
    <published>2022-01-03T00:00:00+08:00</published>
  
    <updated>2022-01-03T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/LQR/</id>
    <content src="https://fulincao.github.io/posts/LQR/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
  

  
    <summary>
      





      LQR调节器


  LQR百度百科
 LQR

  LQR (linear quadratic regulator)即线性二次型调节器，其对象是现代控制理论中以状态空间形式给出的线性系统，而目标函数为对象状态和控制输入的二次型函数。LQR最优设计是指设计出的状态反馈控制器 K要使二次型目标函数J 取最小值，而 K由权矩阵Q 与 R 唯一决定，故此 Q、 R 的选择尤为重要。LQR理论是现代控制理论中发展最早也最为成熟的一种状态空间设计法。特别可贵的是，LQR可得到状态线性反馈的最优控制规律，易于构成闭环最优控制。


推导

假设有一个线性系统能用状态向量的形式表示:
\(\begin{aligned}
    \dot{x} = Ax + Bu \qquad(1)
\end{aligned}\)
其中$x(t)\in R^n, u(t)\in R^m$,其中x为状态变量可观测，u...
    </summary>
  

  </entry>

  
  <entry>
    <title>Kinematics_module</title>
    <link href="https://fulincao.github.io/posts/kinematics_module/" rel="alternate" type="text/html" title="Kinematics_module" />
    <published>2021-12-20T00:00:00+08:00</published>
  
    <updated>2021-12-27T18:04:03+08:00</updated>
  
    <id>https://fulincao.github.io/posts/kinematics_module/</id>
    <content src="https://fulincao.github.io/posts/kinematics_module/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
  

  
    <summary>
      





      运动学模型

自行车模型


  自行车模型
 车辆运动学模型

  自行车模型基于如下几个假设：



  车辆在垂直方向的运动被忽略掉了，也就是说我们描述的车辆是一个二维平面上的运动物体（可以等价与我们是站在天空中的俯视视角）
  假设车辆的结构就像自行车一样，也就是说车辆的前面两个轮胎拥有一直的角度和转速等，同样后面的两个轮胎也是如此，那么前后的轮胎就可以各用一个轮胎来描述
  我们假设车辆运动也和自行车一样，这意味着是前面的轮胎控制这车辆的转角




自行车运动学模型

作为一种自行车模型，运动学自行车模型也假定车辆形如一辆自行车，整个的控制量可以简化为$\alpha, \delta_f, \delta_r$.其中$\alpha$是车辆的加速度，踩油门踏板意味着正的加速度，踩刹车踏板意味着负的加速度。$\delta_f$是前轮转角，$\delta_r$是后轮转角。这样我们使...
    </summary>
  

  </entry>

  
  <entry>
    <title>Pure_pursuit</title>
    <link href="https://fulincao.github.io/posts/pure_pursuit/" rel="alternate" type="text/html" title="Pure_pursuit" />
    <published>2021-12-18T00:00:00+08:00</published>
  
    <updated>2021-12-20T16:28:02+08:00</updated>
  
    <id>https://fulincao.github.io/posts/pure_pursuit/</id>
    <content src="https://fulincao.github.io/posts/pure_pursuit/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
  

  
    <summary>
      





      PurePursuit 纯预瞄算法

阿克曼转向

  阿克曼转向

  阿克曼转向是一种现代汽车的转向方式，在汽车转弯的时候，内外轮转过的角度不一样，内侧轮胎转弯半径小于外侧轮胎。根据阿克曼转向几何设计的车辆，沿着弯道转弯时，利用四连杆的相等曲柄使内侧轮的转向角比外侧轮大大约2~4度，使四个轮子路径的圆心大致上交会于后轴的延长线上瞬时转向中心，让车辆可以顺畅的转弯.下图就是理想的阿克曼转向。




$\alpha$汽车内轮转角
$\beta$汽车外轮转角
K两主销中心距离
L轴距
R转弯半径

转动形式:

  仅前轮转向，后轮角度不变。
  前后轮均可转向。
  (1) 前后轮角度相反，(2) 前后轮角度相同，这种模式可以实现全向运动。


转向特性的特点：

  汽车直线行驶时，4个车轮的轴线都互相平行，而且垂直于汽车纵向中心面。
  汽车在转向行驶过程中，全部车轮都必须绕一...
    </summary>
  

  </entry>

  
  <entry>
    <title>Pure_pid</title>
    <link href="https://fulincao.github.io/posts/pure_pid/" rel="alternate" type="text/html" title="Pure_pid" />
    <published>2021-12-17T00:00:00+08:00</published>
  
    <updated>2021-12-17T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/pure_pid/</id>
    <content src="https://fulincao.github.io/posts/pure_pid/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
  

  
    <summary>
      





      PID控制器


  PID控制参数详解
 PID

  PID控制，即 比例（proportion） - 积分（integration） - 微分(differentiation) 控制
是自动控制原理中定义的一种控制方法也可以称为是校正方法.




积分形式:$U(t) = K_pe(t) + K_i\int_0^te(t)dt + K_d\cfrac{de(t)}{dt}$

离散化:
$U(t) = K_pe(t) + K_i\sum{e(t)} + K_d(e(t) - e(t-1))$

增量式:
$U(t-1) = K_pe(t-1) + K_i\sum{e(t-1)} + K_d(e(t-1) - e(t-2))$

\[\begin{aligned}
    \Delta{U(t)} &amp;amp;= U(t) - U(t-1) \\ &amp;amp;=K_p(e(t)-e...
    </summary>
  

  </entry>

</feed>


