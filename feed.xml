

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://fulincao.github.io/</id>
  <title>fulincao</title>
  <subtitle>fulincao's blog</subtitle>
  <updated>2022-07-22T19:31:00+08:00</updated>
  <author>
    <name>fulincao</name>
    <uri>https://fulincao.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://fulincao.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://fulincao.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator>
  <rights> © 2022 fulincao </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>布隆过滤器</title>
    <link href="https://fulincao.github.io/posts/bloom_filter/" rel="alternate" type="text/html" title="布隆过滤器" />
    <published>2022-07-22T00:00:00+08:00</published>
  
    <updated>2022-07-22T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/bloom_filter/</id>
    <content src="https://fulincao.github.io/posts/bloom_filter/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="算法和数据结构" />
    
  

  
    <summary>
      





      
  布隆过滤器


基本定义: 布隆过滤器(Bloom Filter)是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。

基本原理:布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。

优点:

  插入和查询都是时间都是常数(O(k))
  节省很大的空间
  散列函数相互之间无依赖，可以并行实现
  不存储元素本身，某些对保密要求非常严格的场合有优势
  多个相同的布隆过滤器可以直接合并
  可以表示全集


缺点:

  会有很多假正例，即不在过滤器中的会被误判
  ...
    </summary>
  

  </entry>

  
  <entry>
    <title>机器学习模型评估指标</title>
    <link href="https://fulincao.github.io/posts/model_evaluation_metrics/" rel="alternate" type="text/html" title="机器学习模型评估指标" />
    <published>2022-07-20T00:00:00+08:00</published>
  
    <updated>2022-07-21T17:13:27+08:00</updated>
  
    <id>https://fulincao.github.io/posts/model_evaluation_metrics/</id>
    <content src="https://fulincao.github.io/posts/model_evaluation_metrics/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="机器学习" />
    
  

  
    <summary>
      





      做了很多次模型评估，在此记录一下。
模型评估主要分为两类: 分类，回归

分类
分类常用的指标有:

  Accuracy（准确率)
  Precision（精确率）
  Recall, Sensitivity（召回率，真正率，查全率，TPR）
  Specificity （FPR，假正率）
  F-Score （F值，Recall和Precision的调和值）
  ROC曲线（Receiver Operating Characteristic，横轴为FPR，纵轴为TPR）
  AUC （Area Under Curve，ROC曲线下的面积)


首先根据定义计算混淆矩阵


  
    
      实际\预测
      正
      负
    
  
  
    
      正
      TP
      FN
    
    
      负
      FP
...
    </summary>
  

  </entry>

  
  <entry>
    <title>FFT</title>
    <link href="https://fulincao.github.io/posts/fft/" rel="alternate" type="text/html" title="FFT" />
    <published>2022-06-30T00:00:00+08:00</published>
  
    <updated>2022-07-20T18:07:34+08:00</updated>
  
    <id>https://fulincao.github.io/posts/fft/</id>
    <content src="https://fulincao.github.io/posts/fft/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="信号处理" />
    
  

  
    <summary>
      





      最近了解了下fft,在此记录下:

离散傅里叶变换(Discrete Fourier Transform): 缩写为DFT，是傅里叶变换在时域和频域上都呈离散的形式，将信号的时域采样变换为其DTFT的频域采样。在形式上，变换两端（时域和频域上）的序列是有限长的，而实际上这两组序列都应当被认为是离散周期信号的主值序列。即使对有限长的离散信号作DFT，也应当将其看作其周期延拓的变换。在实际应用中通常采用快速傅里叶变换计算DFT。

快速傅里叶变换(Fast Fourier Transform, FFT): 是快速计算序列的离散傅里叶变换（DFT）或其逆变换的方法[1]。傅里叶分析将信号从原始域（通常是时间或空间）转换到频域的表示或者逆过来转换。FFT会通过把DFT矩阵分解为稀疏（大多为零）因子之积来快速计算此类变换。[2] 因此，它能够将计算DFT的复杂度从只用DFT定义计算需要的  $...
    </summary>
  

  </entry>

  
  <entry>
    <title>关于WAVE那些事情</title>
    <link href="https://fulincao.github.io/posts/wave/" rel="alternate" type="text/html" title="关于WAVE那些事情" />
    <published>2022-06-24T00:00:00+08:00</published>
  
    <updated>2022-07-20T18:07:34+08:00</updated>
  
    <id>https://fulincao.github.io/posts/wave/</id>
    <content src="https://fulincao.github.io/posts/wave/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="音频处理" />
    
  

  
    <summary>
      





      最近了解下wav文件, 记录下wave文件的格式和一些简单的音频处理

格式

  Wav Format
Wave文件格式


wave一般由两部分组成，一部分是头部，一部分是数据



wave文件头部一般如下所示:


  
    
      位置
      一般内容
      解释
    
  
  
    
      4 bytes
      “RIFF”
      文件类型格式
    
    
      4 bytes
      filesize
      其值为filesize字段后的大小，真正的文件大小为filesize + 8 bytes
    
    
      4 bytes
      WAVE
      文件格式
    
    
      4 bytes
      “fmt “
      chunk id,fmt即...
    </summary>
  

  </entry>

  
  <entry>
    <title>poco动态加载class</title>
    <link href="https://fulincao.github.io/posts/poco/" rel="alternate" type="text/html" title="poco动态加载class" />
    <published>2022-06-10T00:00:00+08:00</published>
  
    <updated>2022-07-20T18:07:34+08:00</updated>
  
    <id>https://fulincao.github.io/posts/poco/</id>
    <content src="https://fulincao.github.io/posts/poco/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="C++编程" />
    
  

  
    <summary>
      





      了解一下apollo mainboard的启动流程,觉得挺灵活的。在此记录一下,并自己简单实现了一下demo。

mainboard 启动流程


  启动命令mainboad -d xxx.dag
  读取dag文件，尤其是module_library字段和class_name
  通过poco动态加载module_library，并在module_library中加载class_name
  实例化对象Component
  调用其Init,Proc函数
mainboard根据dag文件动态加载不同的class，执行不同的操作。具有极大的灵活方便且统一调度。同时所有component都基于一个基类ComponentBase，约束了其行为。



  示例dag文件
    module_config {
  module_library : "XXXX.so"
  compone...
    </summary>
  

  </entry>

</feed>


