

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>fulincao</title>
  <subtitle>fulincao's blog</subtitle>
  <updated>2022-07-20T19:47:51+08:00</updated>
  <author>
    <name>fulincao</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator>
  <rights> © 2022 fulincao </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>机器学习模型评估指标</title>
    <link href="http://localhost:4000/posts/model_evaluation_metrics/" rel="alternate" type="text/html" title="机器学习模型评估指标" />
    <published>2022-07-20T00:00:00+08:00</published>
  
    <updated>2022-07-20T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/model_evaluation_metrics/</id>
    <content src="http://localhost:4000/posts/model_evaluation_metrics/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="机器学习" />
    
  

  
    <summary>
      





      虽然做了很多次模型评估

    </summary>
  

  </entry>

  
  <entry>
    <title>FFT</title>
    <link href="http://localhost:4000/posts/fft/" rel="alternate" type="text/html" title="FFT" />
    <published>2022-06-30T00:00:00+08:00</published>
  
    <updated>2022-07-20T18:07:34+08:00</updated>
  
    <id>http://localhost:4000/posts/fft/</id>
    <content src="http://localhost:4000/posts/fft/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="信号处理" />
    
  

  
    <summary>
      





      最近了解了下fft,在此记录下:

离散傅里叶变换(Discrete Fourier Transform): 缩写为DFT，是傅里叶变换在时域和频域上都呈离散的形式，将信号的时域采样变换为其DTFT的频域采样。在形式上，变换两端（时域和频域上）的序列是有限长的，而实际上这两组序列都应当被认为是离散周期信号的主值序列。即使对有限长的离散信号作DFT，也应当将其看作其周期延拓的变换。在实际应用中通常采用快速傅里叶变换计算DFT。

快速傅里叶变换(Fast Fourier Transform, FFT): 是快速计算序列的离散傅里叶变换（DFT）或其逆变换的方法[1]。傅里叶分析将信号从原始域（通常是时间或空间）转换到频域的表示或者逆过来转换。FFT会通过把DFT矩阵分解为稀疏（大多为零）因子之积来快速计算此类变换。[2] 因此，它能够将计算DFT的复杂度从只用DFT定义计算需要的  $...
    </summary>
  

  </entry>

  
  <entry>
    <title>关于WAVE那些事情</title>
    <link href="http://localhost:4000/posts/wave/" rel="alternate" type="text/html" title="关于WAVE那些事情" />
    <published>2022-06-24T00:00:00+08:00</published>
  
    <updated>2022-07-20T18:07:34+08:00</updated>
  
    <id>http://localhost:4000/posts/wave/</id>
    <content src="http://localhost:4000/posts/wave/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="音频处理" />
    
  

  
    <summary>
      





      最近了解下wav文件, 记录下wave文件的格式和一些简单的音频处理

格式

  Wav Format
Wave文件格式


wave一般由两部分组成，一部分是头部，一部分是数据



wave文件头部一般如下所示:


  
    
      位置
      一般内容
      解释
    
  
  
    
      4 bytes
      “RIFF”
      文件类型格式
    
    
      4 bytes
      filesize
      其值为filesize字段后的大小，真正的文件大小为filesize + 8 bytes
    
    
      4 bytes
      WAVE
      文件格式
    
    
      4 bytes
      “fmt “
      chunk id,fmt即...
    </summary>
  

  </entry>

  
  <entry>
    <title>poco动态加载class</title>
    <link href="http://localhost:4000/posts/poco/" rel="alternate" type="text/html" title="poco动态加载class" />
    <published>2022-06-10T00:00:00+08:00</published>
  
    <updated>2022-07-20T18:07:34+08:00</updated>
  
    <id>http://localhost:4000/posts/poco/</id>
    <content src="http://localhost:4000/posts/poco/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="C++编程" />
    
  

  
    <summary>
      





      了解一下apollo mainboard的启动流程,觉得挺灵活的。在此记录一下,并自己简单实现了一下demo。

mainboard 启动流程


  启动命令mainboad -d xxx.dag
  读取dag文件，尤其是module_library字段和class_name
  通过poco动态加载module_library，并在module_library中加载class_name
  实例化对象Component
  调用其Init,Proc函数
mainboard根据dag文件动态加载不同的class，执行不同的操作。具有极大的灵活方便且统一调度。同时所有component都基于一个基类ComponentBase，约束了其行为。



  示例dag文件
    module_config {
  module_library : "XXXX.so"
  compone...
    </summary>
  

  </entry>

  
  <entry>
    <title>匈牙利算法</title>
    <link href="http://localhost:4000/posts/hungarian/" rel="alternate" type="text/html" title="匈牙利算法" />
    <published>2022-06-09T00:00:00+08:00</published>
  
    <updated>2022-07-20T18:07:34+08:00</updated>
  
    <id>http://localhost:4000/posts/hungarian/</id>
    <content src="http://localhost:4000/posts/hungarian/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="算法和数据结构" />
    
  

  
    <summary>
      





      匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。本质是为了解决二分图匹配问题。大致理解如下:
有n个男的，m个女的。男的只能跟女的配对，且只能一对一配对。同时，如果男女配对需要消耗彩礼cost，不同男女之间的彩礼是不一样的。问如何尽可能的配对，同时配对所消耗的彩礼最小。匈牙利本质就是解决这种问题。具体可以看匈牙利算法详解,此算法常用于目标关联，目标融合，目标匹配等场景。本文主要记录如何实现。

cost相同，尽可能匹配多

#include &amp;lt;bits/stdc++.h&amp;gt;
#define INF 0x3f3f3f3f;
using namespace std;
int L[505][505];
int boy[505];
int used[505];
int k,m,n;  //可能的组合数k，女生数m，男生数n 

// 二分图匹配 
bool fi...
    </summary>
  

  </entry>

</feed>


