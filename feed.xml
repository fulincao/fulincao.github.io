

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://fulincao.github.io/</id>
  <title>fulincao</title>
  <subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle>
  <updated>2022-02-28T10:50:21+08:00</updated>
  <author>
    <name>fulincao</name>
    <uri>https://fulincao.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://fulincao.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://fulincao.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator>
  <rights> © 2022 fulincao </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>类型转换</title>
    <link href="https://fulincao.github.io/posts/class-cast/" rel="alternate" type="text/html" title="类型转换" />
    <published>2022-02-25T00:00:00+08:00</published>
  
    <updated>2022-02-25T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/class-cast/</id>
    <content src="https://fulincao.github.io/posts/class-cast/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="C++编程" />
    
  

  
    <summary>
      





      C++ 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：
关键字	|说明|
—-|—-|
static_cast	|用于良性转换，一般不会导致意外发生，风险很低。
const_cast	|用于 const 与非 const、volatile 与非 volatile 之间的转换。
reinterpret_cast	|高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。
dynamic_cast|	借助 RTTI，用于类型安全的向下转型（Downcasting）。


  具体实践


    </summary>
  

  </entry>

  
  <entry>
    <title>智能指针</title>
    <link href="https://fulincao.github.io/posts/smart-pointer/" rel="alternate" type="text/html" title="智能指针" />
    <published>2022-02-24T00:00:00+08:00</published>
  
    <updated>2022-02-24T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/smart-pointer/</id>
    <content src="https://fulincao.github.io/posts/smart-pointer/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="C++编程" />
    
  

  
    <summary>
      





      RAII与引用计数

  现代c++教程


在传统 C++ 中，需要手动释放资源，有可能就忘记了去释放资源而导致泄露。所以通常的做法是对于一个对象而言，在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。

凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 new 和 delete 去 『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针就包括 std::shared_ptr、std::unique_ptr、std::weak_ptr，使用它们需要包含头文件 。

std::shared_ptr
std::shared_ptr是一种智能指针，它能够记录多少个shared_ptr共同指向一个对...
    </summary>
  

  </entry>

  
  <entry>
    <title>动力学模型</title>
    <link href="https://fulincao.github.io/posts/dynamics_module/" rel="alternate" type="text/html" title="动力学模型" />
    <published>2022-02-09T00:00:00+08:00</published>
  
    <updated>2022-02-09T00:00:00+08:00</updated>
  
    <id>https://fulincao.github.io/posts/dynamics_module/</id>
    <content src="https://fulincao.github.io/posts/dynamics_module/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="模型" />
    
    <category term="动力学模型" />
    
  

  
    <summary>
      





      车辆动力学模型


  动力学模型


动力学主要研究作用于物体的力与物体运动的关系，车辆动力学模型一般用于分析车辆的平顺性和车辆操纵的稳定性。对于车来说，研究车辆动力学，主要是研究车辆轮胎及其相关部件的受力情况。比如纵向速度控制，通过控制轮胎转速实现；横向航向控制，通过控制轮胎转角实现。

正常情况下，车辆上的作用力沿着三个不同的轴分布：

  纵轴上的力包括驱动力和制动力，以及滚动阻力和拖拽阻力作滚摆运动；
  横轴上的力包括转向力、离心力和侧风力，汽车绕横轴作俯仰运动；
  立轴上的力包括车辆上下振荡施加的力，汽车绕立轴作偏摆或转向运动




而在单车模型假设的前提下，再作如下假设即可简单搭建车辆的动力学模型：

  只考虑纯侧偏轮胎特性，忽略轮胎力的纵横向耦合关系；
  用单车模型来描述车辆的运动，不考虑载荷的左右转移；
  忽略横纵向空气动力学。


其中需要考虑的受力点...
    </summary>
  

  </entry>

  
  <entry>
    <title>曲率和航向的计算</title>
    <link href="https://fulincao.github.io/posts/curvature_heading/" rel="alternate" type="text/html" title="曲率和航向的计算" />
    <published>2022-01-07T00:00:00+08:00</published>
  
    <updated>2022-01-10T11:19:52+08:00</updated>
  
    <id>https://fulincao.github.io/posts/curvature_heading/</id>
    <content src="https://fulincao.github.io/posts/curvature_heading/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="数学" />
    
  

  
    <summary>
      





      曲率和航向

  曲率
航向


曲线的曲率（curvature）就是针对曲线上某个点的切线方向角对弧长的转动率，通过微分来定义，表明曲线偏离直线的程度。数学上表明曲线在某一点的弯曲程度的数值。曲率越大，表示曲线的弯曲程度越大。曲率的倒数就是曲率半径。

设曲线直角坐标方程$y = f(x)$且具有二阶导数，那么曲率公式为：
\(\begin{aligned}
    K = \dfrac{|y^{''}|}{(1+y^{'2})^{\dfrac{3}{2}} }
\end{aligned}\)
航向为：
\(\begin{aligned}
    Yaw = \arctan(y')
\end{aligned}\)

如果曲线是由参数方程
\(\begin{aligned}
    x &amp;amp;= \psi(t) \\
    y &amp;amp;= \omega(t)
\end{ali...
    </summary>
  

  </entry>

  
  <entry>
    <title>三次样条插值</title>
    <link href="https://fulincao.github.io/posts/cubic_spline/" rel="alternate" type="text/html" title="三次样条插值" />
    <published>2022-01-04T00:00:00+08:00</published>
  
    <updated>2022-01-11T15:45:37+08:00</updated>
  
    <id>https://fulincao.github.io/posts/cubic_spline/</id>
    <content src="https://fulincao.github.io/posts/cubic_spline/" />
    <author>
      <name>fulincao</name>
    </author>

  
    
    <category term="算法" />
    
    <category term="控制算法" />
    
  

  
    <summary>
      





      三次样条(cubic spline)插值


  样条插值
 PythonRobotics


已知某些点而不知道具体方程时候，通常有拟合和插值两种做法。拟合不要求方程通过所有的已知点，整体趋势一致。插值则是每个已知点都必会穿过，但是高阶会出现龙格现象，所以一般采用分段插值。而三次样条插值则是分段采用一元三次方程进行插值

问题定义

已知n+1个点$[(x_0, y_0), (x_1, y_1),…,(x_{n-1}, y_{n-1}), (x_n, y_n)]$，n个区间段为$[(x0, x1), (x1, x2),…,(x_{n-1}, x_n)]$三次样条就是说每个小区间的曲线是一个三次方程，三次样条方程满足以下条件:

  在每个分段小区间$[x_i, x_{i+1}], S(x)=S_i(x) = a_i + b_ix + c_ix^2 + d_ix^3$
  满足插值条...
    </summary>
  

  </entry>

</feed>


